#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Cwd/Guard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CWD_GUARD';
  package Cwd::Guard;use strict;use warnings;use parent 'Exporter';our@EXPORT_OK=qw/cwd_guard/;our$Error;our$VERSION='0.04';use constant USE_FCHDIR=>eval {opendir my$dh,'.';chdir$dh;1};use if!USE_FCHDIR,Cwd=>qw/getcwd/;sub cwd_guard {my$dir=shift;__PACKAGE__->new($dir)}sub new {my$class=shift;my$dir=shift;my$cwd;if (USE_FCHDIR){opendir$cwd,'.'}else {$cwd=getcwd()}my$callback=sub {chdir$cwd};my$result=defined$dir ? chdir($dir): chdir();$Error=$!;return unless$result;bless$callback,$class}sub DESTROY {$_[0]->()}1;
CWD_GUARD

$fatpacked{"Kurado.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO';
  package Kurado;
  
  use 5.10.0;
  use strict;
  use warnings;
  
  our $VERSION = '0.01';
  
  1;
  
  
KURADO

$fatpacked{"Kurado/Agent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_AGENT';
  package Kurado::Agent;
  
  use 5.008005;
  use strict;
  use warnings;
  
  our $VERSION = '0.01';
  
  1;
  
KURADO_AGENT

$fatpacked{"Kurado/Agent/Collector.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_AGENT_COLLECTOR';
  package Kurado::Agent::Collector;
  
  use strict;
  use warnings;
  use Kurado::Util;
  
  our @FUNC = qw/memory loadavg uptime sys_version processors cpu_usage tcp_established disk_usage disk_io swaps traffic/;
  
  sub new {
      my ($class, $plugins) = @_;
      bless {
          plugins => $plugins
      }, $class;
  }
  
  sub metrics {
      my $self = shift;
      return $self->{metrics};
  }
  
  sub meta {
      my $self = shift;
      return $self->{meta};
  }
  
  sub collect {
      my ($self,$self_ip) = @_;
      $self->{metrics} = {};
      $self->{meta} = {};
      my %warn;
      my %result;
      for my $func (@FUNC){
          eval {
              $self->$func();
          };
          if ( $@ ) {
              $warn{$func} = $@;;
              $warn{$func} =~ s!(?:\n|\r)!!g;
          }
      }
      my $body;
      my $time = time();
      $body .= "$self_ip\tbase.metrics.$_\t".$self->{metrics}->{$_}."\t$time\n" for sort keys %{$self->{metrics}};
      $body .= "$self_ip\tbase.meta.$_\t".$self->{meta}->{$_}."\t$time\n" for sort keys %{$self->{meta}};
      $body .= "$self_ip\tbase.warn.$_\t".$warn{$_}."\t$time\n" for sort keys %warn;
      $body;
  }
  
  sub collect_plugins {
      my ($self,$self_ip) = @_;
      my $body = '';
      my $time = time;
      for my $plugin_key ( keys %{$self->{plugins}} ){
          eval {
              my ($result, $exit_code) = cap_cmd([$self->{plugins}->{$plugin_key}]);
              die "failed to exec plugin:$plugin_key: exit_code: $exit_code\n" if $exit_code != 0;
              for my $ret (split /\n/, $result) {
                  chomp($ret);
                  my @ret = split /\t/,$ret;
                  if ( $ret[0] !~ m!^(?:metrics|meta)\.! ) {
                      $ret[0] = "metrics.$ret[0]";
                  }
                  if ( $ret[0] =~ m!^metrics\.! && $ret[0] !~ m!\.(?:gauge|counter|derive|absolute)$! ) {
                      $ret[0] = "$ret[0].gauge";
                  }
                  $ret[0] = "$plugin_key.$ret[0]";
                  $ret[2] ||= $time;
                  $body .= join("\t", $self_ip, @ret[0,1,2])."\n";
              }
          };
          if ( $@ ) {
              my $warn = $@;
              $warn =~ s!(?:\n|\r)!!g;
              $body .= "$self_ip\t$plugin_key.warn.command\t$warn\t$time\n";
          }
      }
      $body;
  }
  
  sub memory {
      my $self = shift;
      my %MEMORY_ITEM = (
          'MemTotal'  => 'memory-total.gauge',
          'MemFree'   => 'memory-free.gauge',
          'Buffers'   => 'memory-buffers.gauge',
          'Cached'    => 'memory-cached.gauge',
          'SwapTotal' => 'memory-swap-total.gauge',
          'SwapFree'  => 'memory-swap-free.gauge',
      );
  
      open my $fh, '<:utf8', '/proc/meminfo' or die "$!\n";
      my %meminfo;
      while (<$fh>) {
          chomp;chomp;
          my($key, $val) = split /[\s:]+/, $_, 2;
          next unless $key;
          $meminfo{$key} = to_byte($val);
      }
      close $fh;
  
      my $metrics = $self->metrics;
      for my $k ( keys %MEMORY_ITEM ) {
          $metrics->{$MEMORY_ITEM{$k}} = int( defined $meminfo{$k} ? $meminfo{$k} :  0);
      }
  
      $metrics->{'memory-used.gauge'} = $metrics->{'memory-total.gauge'}
          - $metrics->{'memory-free.gauge'}
          - $metrics->{'memory-buffers.gauge'}
          - $metrics->{'memory-cached.gauge'};
      $metrics->{'memory-swap-used.gauge'} = $metrics->{'memory-swap-total.gauge'} - $metrics->{'memory-swap-free.gauge'};
      delete $metrics->{'memory-swap-free.gauge'}
  }
  
  
  sub loadavg {
      my $self = shift;
      open my $fh, '<', '/proc/loadavg' or die "$!\n";
      while (<$fh>) {
          if (my @e = split /\s+/) {
              $self->metrics->{'loadavg-1.gauge'}  = $e[0];
              $self->metrics->{'loadavg-5.gauge'}  = $e[1];
              $self->metrics->{'loadavg-15.gauge'} = $e[2];
              last;
          }
      }
      close $fh;
  }
  
  sub uptime {
      my $self = shift;
      open my $fh, '<', '/proc/uptime' or die "$!\n";
      while (<$fh>) {
          if (my @e = split /\s+/) {
              $self->meta->{'uptime'}  = int($e[0]);
              last;
          }
      }
      close $fh;
  }
  
  sub sys_version {
      my $self = shift;
      open my $fh, '<', '/proc/version' or die "$!\n";
      $self->meta->{'version'} = <$fh>;
      chomp $self->meta->{'version'};
      close $fh;
  }
  
  
  sub processors {
      my $self = shift;
      open my $fh, '<', '/proc/cpuinfo' or die "$!\n";
      while (<$fh>) {
          $self->metrics->{'processors.gauge'}++ if m!^processor\s*:!
      }
      close $fh;
  }
  
  
  sub cpu_usage {
      my $self = shift;
      open my $fh, '<', '/proc/stat' or die "$!\n";
      my @keys = qw(cpu-user cpu-nice cpu-system cpu-idle cpu-iowait cpu-irq cpu-softirq cpu-steal cpu-guest cpu-guest-nice);
      while (<$fh>) {
          if (/^cpu\s+/) {
              chomp;
              my(undef, @t) = split /\s+/;
              for my $k (@keys) {
                  my $v = shift @t;
                  $self->metrics->{"$k.derive"} = int(defined $v ? $v : 0);
              }
              last;
          }
      }
      close $fh;
  }
  
  sub tcp_established {
      my $self = shift;
      open my $fh, '<', '/proc/net/snmp' or die "$!\n";
      my $index;
      while (<$fh>) {
          if (/^Tcp:/) {
              my @vals = split /\s+/, $_;
              if (!$index) {
                  for my $label (@vals) {
                      last if $label eq 'CurrEstab';
                      $index++;
                  }
              }
              else {
                  $self->metrics->{'tcp-established.gauge'} = $vals[$index];
                  last;
              }
          }
      }
  }
  
  
  
  sub disk_usage {
      my $self = shift;
      open my $fh, '<', '/proc/mounts' or die "$!\n";
      my @mount_points;
      my %mount_points;
      while (<$fh>) {
          if ( m!^/dev/(.+?) (/.*?) ! ) {
              next if $2 eq '/boot'; # not required
              push @mount_points, $2;
              $mount_points{$2} = $1;
              $mount_points{$2} =~ s![^A-Za-z0-9_-]!_!g;
          }
      }
      return unless @mount_points;
      my ($result, $exit_code) = cap_cmd(['df',@mount_points]);
      die "failed to exec df\n" if $exit_code != 0;
      my @devices;
      for ( split /\n/, $result ) {
          chomp;chomp;
          my @d = split /\s+/, $_;
          next unless exists $mount_points{$d[5]};
          $self->metrics->{"disk-usage-".$mount_points{$d[5]}."-used.gauge"} = $d[2];
          $self->metrics->{"disk-usage-".$mount_points{$d[5]}."-available.gauge"} = $d[3];
          $self->meta->{"disk-usage-".$mount_points{$d[5]}."-mount"} = $d[5];
          push @devices, $mount_points{$d[5]};
      }
      $self->meta->{"disk-usage-devices"} = join ",", @devices if @devices;
  }
  
  sub translate_device_mapper {
      my $device = shift;;
      for my $d ( glob(q!/dev/mapper/*!) ) {
          my $s = readlink($d);
          next unless $s;
          ($s) = ( $s =~ m!(dm-.+)$! );
          if ( $s eq $device ) {
              $d =~ s!^/dev/!!;
              return $d;
          }        
      }
      die "cannot resolv $device\n";
  }
  
  sub disk_io {
      my $self = shift;
      my @stats = glob '/sys/block/*/stat';
      my @devices;
      for my $stat ( @stats ) {
          my ($device) = ( $stat =~ m!^/sys/block/(.+)/stat$! );
          next if $device =~ m!^(loop|ram)\d+$!;
          open my $fh, '<', $stat or die "$!\n";
          my $dstat = <$fh>;
          close $fh;
          $dstat =~ s!^\s+!!g;
          my @dstats = split /\s+/, $dstat;
          if ( $device =~ m!^dm-! ) {
              $device = translate_device_mapper($device);
          }
          # readd-ios read-merges read-sectors readd-ticks 0..3
          # write-ios write-merges write-sectors write-ticks 4..7
          # ios-in-prog tot-ticks rq-ticks 8..9
          next if $dstats[0] == 0 && $dstats[4] == 0;
          $device =~ s![^A-Za-z0-9_-]!_!g;
          push @devices, $device;
          $self->metrics->{"disk-io-".$device."-read-ios.derive"} = $dstats[0];
          $self->metrics->{"disk-io-".$device."-read-sectors.derive"} = $dstats[2];
          $self->metrics->{"disk-io-".$device."-write-ios.derive"} = $dstats[4];
          $self->metrics->{"disk-io-".$device."-write-sectors.derive"} = $dstats[6];
      }
      $self->meta->{"disk-io-devices"} = join ",", @devices if @devices;
  }
  
  
  sub swaps {
      my $self = shift;
      open my $fh, '<', '/proc/swaps' or die "$!\n";
  #   [vagrant@localhost ~]$ cat /proc/swaps 
  #   Filename                                Type            Size    Used    Priority
  #   /dev/dm-1                               partition       950264  208     -1
      my @swaps;
      while (<$fh>) {
          if ( m!^/dev/(.+?)\s*partition! ) {
              my $device = $1;
              if ( $device =~ m!^dm-! ) {
                  $device = translate_device_mapper($device);
              }
              $device =~ s![^A-Za-z0-9_-]!_!g;
              push @swaps, $device;
          }
      }
      $self->meta->{"disk-swap-devices"} = join ",", @swaps if @swaps;
  }
  
  sub traffic {
      my $self = shift;
  
      my ($result, $exit_code) = cap_cmd(['ip','-s','-o','link']);
      die "failed to exec ip link\n" if $exit_code != 0;
  
  #2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
  #    link/ether 00:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff
  #    RX: bytes  packets  errors  dropped overrun mcast   
  #    419890719  512995634 0       0       0       0      
  #    TX: bytes  packets  errors  dropped carrier collsns 
  #    2050758259 400885501 0       0       0       0 
  #5: eth3: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 1000
  #    link/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff
  #    RX: bytes  packets  errors  dropped overrun mcast   
  #    0          0        0       0       0       0      
  #    TX: bytes  packets  errors  dropped carrier collsns 
  #    0          0        0       0       0       0      
  #6: eth1.66@eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP 
  #    link/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff
  #    RX: bytes  packets  errors  dropped overrun mcast   
  #    4092101350 335780455 0       0       0       3122   
  #    TX: bytes  packets  errors  dropped carrier collsns 
  #    2759531860 774335892 0       0       0       0      
  
      my %up_interface;
      for ( split /\n/, $result ) {
          chomp;chomp;
          if ( m!^\d+:\s*([a-z0-9]+):\s<([^>]+)>\s(.*)$! ) {
              my $interface = $1;
              my $state = $2;
              my $stats = $3;
              next if $interface eq 'lo'; #skip loopback
              next unless grep { $_ eq "UP" } split /,/, $state; #not up
              $up_interface{$interface} = 1;
          }
      }
  
  # Inter-|   Receive                                                |  Transmit
  # face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed
  #    lo:    1070      18    0    0    0     0          0         0     1070      18    0    0    0     0       0          0
  #  eth0:10629449294 127380325    0    0    0     0          0  55232809        0       0    0    0    0     0       0          0
  #  eth1:41604925517001 425181836825    0 14412687    0 1493026          0 3223957693 612845800274320 583467665030    0    0    0     0       0          0
  #  eth2:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0
  #  eth3:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0
  #eth1.75:31640796844523 412711681474    0    0    0     0          0        14 588482011515562 284949044666    0    0    0     0       0          0
  
      open my $fh, '<', '/proc/net/dev' or die "$!\n";
      my @interfaces;
      while (<$fh>) {
          if ( m!^\s*(.+):\s*(.*)$! ) {
              my $interface = $1;
              my $stat = $2;
              next unless exists $up_interface{$interface};
              push @interfaces, $interface;
              my @stats = split /\s+/, $stat;
              $self->metrics->{"traffic-${interface}-rxbytes.derive"} = $stats[0];
              $self->metrics->{"traffic-${interface}-txbytes.derive"} = $stats[8];
          }
      }
      $self->meta->{"traffic-interfaces"} = join ",", @interfaces if @interfaces;
  }
  
  1;
KURADO_AGENT_COLLECTOR

$fatpacked{"Kurado/Agent/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_AGENT_CONFIG';
  package Kurado::Agent::Config;
  
  use strict;
  use warnings;
  use utf8;
  use Kurado::Agent::TOML;
  use boolean qw//;
  use Cwd::Guard qw/cwd_guard/;
  
  my $PARSER = Kurado::Agent::TOML->new;
  
  sub new {
      my $class = shift;
      my $path = shift;
      my $self = bless {
          plugins => {
          }
      }, $class;
      my $dir = cwd_guard($path);
      for my $inc_path ( glob '*.toml' ) {
          $self->parse_file($inc_path);
      }
      $self;
  }
  
  sub parse_file {
      my ($self, $path) = @_;
      my $ref = eval {
          $PARSER->parse_file($path);
      };
      die "can't load config $path: $@\n" if $@;
  
      my $plugins = delete $ref->{plugin};
      if ( $plugins && $plugins->{metrics} ) {
          for (keys %{$plugins->{metrics}}) {
              $self->{plugins}->{$_} = $plugins->{metrics}->{$_}->{command};
          }
      }
  }
  
  sub plugins { $_[0]->{plugins} || {} };
  
  
  
  1;
  
  
KURADO_AGENT_CONFIG

$fatpacked{"Kurado/Agent/TOML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_AGENT_TOML';
  package Kurado::Agent::TOML;
  
  use 5.008005;
  use strict;
  use warnings;
  use utf8;
  
  use boolean qw//;
  use TOML::Parser::Tokenizer qw/:constant/;
  use TOML::Parser::Util qw/unescape_str/;
  
  sub new {
      my $class = shift;
      my $args  = (@_ == 1 and ref $_[0] eq 'HASH') ? +shift : +{ @_ };
      return bless +{
          inflate_datetime => sub { $_[0] },
          inflate_boolean  => sub { $_[0] eq 'true' ? boolean::true : boolean::false },
          strict_mode      => 0,
          %$args,
      } => $class;
  }
  
  sub parse_file {
      my ($self, $file) = @_;
      open my $fh, '<:encoding(utf-8)', $file or die $!;
      return $self->parse_fh($fh);
  }
  
  sub parse_fh {
      my ($self, $fh) = @_;
      my $src = do { local $/; <$fh> };
      return $self->parse($src);
  }
  
  sub _tokenizer_class {
      my $self = shift;
      return 'TOML::Parser::Tokenizer';
  }
  
  our @TOKENS;
  our $ROOT;
  our $CONTEXT;
  sub parse {
      my ($self, $src) = @_;
  
      local $ROOT    = {};
      local $CONTEXT = $ROOT;
      local @TOKENS  = $self->_tokenizer_class->tokenize($src);
      return $self->_parse_tokens();
  }
  
  sub _parse_tokens {
      my $self = shift;
  
      while (my $token = shift @TOKENS) {
          my ($type, $val) = @$token;
          if ($type eq TOKEN_TABLE) {
              $self->_parse_table($val);
          }
          elsif ($type eq TOKEN_ARRAY_OF_TABLE) {
              $self->_parse_array_of_table($val);
          }
          elsif ($type eq TOKEN_KEY) {
              my $token = shift @TOKENS;
              die "Duplicate key. key:$val" if exists $CONTEXT->{$val};
              $CONTEXT->{$val} = $self->_parse_value_token($token);
          }
          elsif ($type eq TOKEN_COMMENT) {
              # pass through
          }
          else {
              die "Unknown case. type:$type";
          }
      }
  
      return $CONTEXT;
  }
  
  sub _parse_table {
      my ($self, $key) = @_;
  
      local $CONTEXT = $ROOT;
      for my $k (split /\./, $key) {
          if (exists $CONTEXT->{$k}) {
              $CONTEXT = ref $CONTEXT->{$k} eq 'ARRAY' ? $CONTEXT->{$k}->[-1] :
                         ref $CONTEXT->{$k} eq 'HASH'  ? $CONTEXT->{$k}       :
                         die "invalid structure. $key cannot be `Table`";
          }
          else {
              $CONTEXT = $CONTEXT->{$k} ||= +{};
          }
      }
  
      $self->_parse_tokens();
  }
  
  sub _parse_array_of_table {
      my ($self, $key) = @_;
      my @keys     = split /\./, $key;
      my $last_key = pop @keys;
  
      local $CONTEXT = $ROOT;
      for my $k (@keys) {
          if (exists $CONTEXT->{$k}) {
              $CONTEXT = ref $CONTEXT->{$k} eq 'ARRAY' ? $CONTEXT->{$k}->[-1] :
                         ref $CONTEXT->{$k} eq 'HASH'  ? $CONTEXT->{$k}       :
                         die "invalid structure. $key cannot be `Array of table`.";
          }
          else {
              $CONTEXT = $CONTEXT->{$k} ||= +{};
          }
      }
  
      $CONTEXT->{$last_key} = [] unless exists $CONTEXT->{$last_key};
      die "invalid structure. $key cannot be `Array of table`" unless ref $CONTEXT->{$last_key} eq 'ARRAY';
      push @{ $CONTEXT->{$last_key} } => $CONTEXT = {};
  
      $self->_parse_tokens();
  }
  
  sub _parse_value_token {
      my $self  = shift;
      my $token = shift;
  
      my ($type, $val) = @$token;
      if ($type eq TOKEN_COMMENT) {
          return; # pass through
      }
      elsif ($type eq TOKEN_INTEGER || $type eq TOKEN_FLOAT) {
          return 0+$val;
      }
      elsif ($type eq TOKEN_BOOLEAN) {
          return $self->inflate_boolean($val);
      }
      elsif ($type eq TOKEN_DATETIME) {
          return $self->inflate_datetime($val);
      }
      elsif ($type eq TOKEN_STRING) {
          return unescape_str($val);
      }
      elsif ($type eq TOKEN_ARRAY_BEGIN) {
          my @data;
          while (my $token = shift @TOKENS) {
              last if $token->[0] eq TOKEN_ARRAY_END;
              push @data => $self->_parse_value_token($token);
          }
          return \@data;
      }
      else {
          die "Unknown case. type:$type";
      }
  }
  
  sub inflate_datetime {
      my $self = shift;
      return $self->{inflate_datetime}->(@_);
  }
  
  sub inflate_boolean {
      my $self = shift;
      return $self->{inflate_boolean}->(@_);
  }
  
  1;
KURADO_AGENT_TOML

$fatpacked{"Kurado/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_CONFIG';
  package Kurado::Config;
  
  use strict;
  use warnings;
  use Mouse;
  use Mouse::Util::TypeConstraints;
  use File::Basename;
  
  subtype 'Natural'
      => as 'Int'
      => where { $_ > 0 };
  
  subtype 'Uint'
      => as 'Int'
      => where { $_ >= 0 };
  
  subtype 'Flag'
      => as 'Int'
      => where { $_ <= 1 };
  
  no Mouse::Util::TypeConstraints;
  
  sub load {
      my ($class,$ref,$path) = @_;
      $ref->{_path} = $path;
      __PACKAGE__->new($ref);
  }
  
  # path
  
  has '_path' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  # config
  
  has 'redis' => (
      is => 'ro',
      isa => 'Str',
      default => '127.0.0.1:6379',
  );
  
  has 'data_dir' => (
      is => 'ro',
      isa => 'Str',
      default => 'data',
  );
  
  has 'rolls_dir' => (
      is => 'ro',
      isa => 'Str',
      default => 'sample_rolls',
  );
  
  has 'metrics_plugin_dir' => (
      is => 'ro',
      isa => 'ArrayRef[Str]',
      default => 'sub { [qw/metrics_plugins metrics_site_plugins/] }',
  );
  
  # worker process numbers
  
  has 'web_worker' => (
      is => 'ro',
      isa => 'Natural',
      default => 5,
  );
  
  has 'update_worker' => (
      is => 'ro',
      isa => 'Natural',
      default => 2,
  );
  
  has 'fetch_worker' => (
      is => 'ro',
      isa => 'Natural',
      default => 2,
  );
  
  
  #rel2abs
  
  around ['data_dir','rolls_dir'] => sub {
      my $orig = shift;
      my $self = shift;
      my $dir = @_ ? $self->$orig(@_) : $self->$orig();
      File::Spec->rel2abs($dir, File::Basename::dirname($self->_path) );
  };
  
  around 'metrics_plugin_dir' => sub {
      my $orig = shift;
      my $self = shift;
      my $dirs = @_ ? $self->$orig(@_) : $self->$orig();
      [ map { File::Spec->rel2abs($_, File::Basename::dirname($self->_path)) } @$dirs ];
  };
  
  __PACKAGE__->meta->make_immutable();
  
  sub dump {
      my $self = shift;
      my %dump;
      $dump{$_} = $self->$_ for qw/_path redis data_dir rolls_dir metrics_plugin_dir web_worker update_worker fetch_worker/;
      return \%dump;
  }
  
  
  1;
  
KURADO_CONFIG

$fatpacked{"Kurado/ConfigLoader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_CONFIGLOADER';
  package Kurado::ConfigLoader;
  
  use strict;
  use warnings;
  use utf8;
  use YAML::XS qw//;
  use JSON::XS;
  use File::Spec;
  use Mouse;
  use Unicode::EastAsianWidth;
  
  use Kurado::Config;
  use Kurado::Object::Host;
  use Kurado::Object::Roll;
  use Kurado::Object::Plugin;
  use Kurado::Plugin::Compile;
  
  has 'path' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  __PACKAGE__->meta->make_immutable();
  
  
  sub yaml_head {
      my $ref = shift;
      my $dump = YAML::XS::Dump($ref);
      chomp($dump);
      my @dump = split /\n/, $dump;
      join("\n", map { "> $_"} splice(@dump,0,8), (@dump > 8 ? "..." : ""))."\n";
  }
  
  sub BUILD {
      my ($self) = @_;
      $self->{_roll_cache} = {};
      $self->{load_plugins} = {};
      $self->{service_hosts} = {};
      $self->parse_file();
  }
  
  sub parse_file {
      my ($self) = @_;
      my $path = $self->{path};
      my @configs = eval {
          YAML::XS::LoadFile($path);
      };
      die "Failed to load $path: $@" if $@;
      
      for ( @configs ) {
          if ( ! ref $_ || ref $_ ne "HASH" ) {
              die "config shuold be HASH(or dictionary):\n" . yaml_head($_); 
          }
      }
  
      my $main_config = shift @configs;
      $self->parse_main_config($main_config);
  
      $self->{services} = {};
      for my $service_config ( @configs ) {
          $self->parse_service_config($service_config);
      }
  }
  
  sub parse_main_config {
      my ($self, $config) = @_;
  
      my $main_config = $config->{config};
      die "There is no 'config' in:\n".yaml_head($config) unless $main_config;
      eval {
          $self->{config} = Kurado::Config->load($main_config, $self->{path});
      };
      die "failed to config: $@\n===\n".yaml_head($config) if $@;
  
      $self->{metrics_config} = $config->{metrics_config};
      $self->{metrics_config} ||= {};
      die "metrics_config should be HASH(or dictionary)\n".yaml_head($self->{metrics_config})
          if ! ref $self->{metrics_config} || ! ref $self->{metrics_config} eq 'HASH';
  }
  
  sub parse_service_config {
      my ($self,$config) = @_;
      my $service = $config->{service};
      die "There is no 'service' in:\n".yaml_head($config) unless $service;
      die "found duplicated service '$service'".yaml_head($config) if exists $self->{services}->{$service};
      my $servers_config = $config->{servers};
      $servers_config ||= [];
      die "metrics_config should be Array\n".yaml_head($servers_config)
          if ! ref $servers_config || ! ref $servers_config eq 'ARRAY';
      my @sections;
      my %labels;
      for my $server_config ( @$servers_config ) {
          my $roll = $server_config->{roll}
              or die "cannot find roll in service:$service servers:".yaml_head($server_config);
          my $hosts = $server_config->{hosts} || [];
          my $label = $server_config->{label} // '';
  
          # lebel の2重チェック
          if ( $label ) {
              die "found duplicated label '$label'".yaml_head($config) if exists $labels{$label};
          }
  
          my @hosts;
          for my $host_line ( @$hosts ) {
              my $host = eval {
                  $self->parse_host( $host_line, $roll, $service );
              };
              die "$@".yaml_head($config) if $@;
              $self->{service_hosts}{$service}++;
              push @hosts, $host;
          }
          
          if ( @sections && !$label ) {
              push @{$sections[-1]->{hosts}}, @hosts;
              next;
          }
  
          push @sections, {
              label => $label,
              hosts => \@hosts,
          };
          $labels{$label} = 1;
      }
  
      $self->{services}->{$service} = \@sections;
  }
  
  sub parse_host {
      my ($self, $line, $roll_name, $service) = @_;
  
      my ( $address, $hostname, $comments )  = split /\s+/, $line, 3;
      die "cannot find address in '$line'\n" unless $address;
      $hostname //= $address;
      $comments //= "";
      die "duplicated host entry address $address in '$line'\n" if exists $self->{hosts}{$address};
  
      my $roll = $self->load_roll( $roll_name );
      $self->{hosts}{$address} =  Kurado::Object::Host->new(
          address => $address,
          hostname => $hostname,
          comments => $comments,
          roll => $roll_name,
          metrics_config => $roll->metrics_config,
          plugins => $roll->plugins,
          service => $service
      );
      $self->{hosts}{$address};
  }
  
  sub load_roll {
      my ($self, $roll_name) = @_;
      # cache
      return $self->{_roll_cache}{$roll_name} if $self->{_roll_cache}{$roll_name};
      my $path = File::Spec->catfile($self->config->rolls_dir, $roll_name);
      my ($roll_config) = eval {
          YAML::XS::LoadFile($path);
      };
      die "Failed to load roll $path: $@" if $@;
      if ( ! ref $roll_config || ref $roll_config ne "HASH" ) {
          die "roll config shuold be HASH(or dictionary):\n" . yaml_head($roll_config); 
      }
      my $metrics_config = $self->merge_metrics_config($roll_config->{metrics_config} || {});
      my @plugins;
      for ( @{$roll_config->{metrics} || []} ) {
          push @plugins, $self->parse_plugin($_);
      }    
      
      $self->{_roll_cache}{$roll_name} = Kurado::Object::Roll->new(
          metrics_config => $metrics_config,
          plugins => \@plugins
      );    
      $self->{_roll_cache}{$roll_name};
  }
  
  sub parse_plugin {
      my ($self, $line) = @_;
      my ( $plugin, @arguments )  = split /:/, $line;
      die "cannot find plugin name: in '$line'\n" unless $plugin;
  
      # compile plugin
      my $pc = Kurado::Plugin::Compile->new(config=>$self->config);
      my @loaded_plugins;
      for my $type (qw/view fetch/) {
          my $compiled = eval {
              $pc->compile(
                  plugin => $plugin,
                  type => $type,
              );
          };
          die "failed load plugin plugin:$plugin,type:$type $@\n" if $@;
          push @loaded_plugins, $type if $compiled;
      }
      die "Could not find plugin '$plugin'\n" if @loaded_plugins == 0;
      $self->{load_plugins}{$plugin} = \@loaded_plugins;
      return Kurado::Object::Plugin->new(
          plugin => $plugin,
          arguments => \@arguments,
      );
  }
  
  sub config {
      $_[0]->{config};
  }
  
  sub metrics_config {
      $_[0]->{metrics_config};
  }
  
  my $_JSON = JSON::XS->new->utf8;
  sub merge_metrics_config {
      my ($self,$ref) = @_;
      $_JSON->decode($_JSON->encode({
          %{$self->{metrics_config}},
          %$ref
      }));
  }
  
  sub services {
      $_[0]->{services};
  }
  
  sub sorted_services {
      my $self = shift;
      [
          map {{
              service => $_,
              sections => $self->services->{$_},
              host_num => $self->{service_hosts}{$_},
          }} sort { lc($a) cmp lc($b) } keys %{$self->services}
      ];
  }
  
  sub hosts {
      $_[0]->{hosts};
  }
  
  sub host_by_address {
      my ($self,$address) = @_;
      return unless exists $self->{hosts}{$address};
      $self->{hosts}{$address};
  }
  
  sub plugins {
      my $self = shift;
      [ keys %{$self->{load_plugins}} ];
  }
  
  sub has_fetch_plugin {
      my ($self,$plugin) = @_;
      exists $self->{load_plugins}{$plugin} && grep { $_ eq 'fetch' } @{$self->{load_plugins}{$plugin}};
  }
  
  sub dump {
      my $self = shift;
      +{
          config => $self->config->dump,
          metrics_config => $self->metrics_config,
          services => $self->sorted_services,
      }
  }
  
  sub zlength {
      my $str = shift;
      my $width = 0;
      while ($str =~ m/(?:(\p{InFullwidth}+)|(\p{InHalfwidth}+))/go) {
          $width += ($1 ? length($1) * 2 : length($2));
      }
      $width;
  }
  
  sub statistics {
      my $self = shift;
      $self->sorted_services;
      my ($maxlen) = sort { $b <=> $a } map { zlength($_) } keys %{$self->services};
  
      $maxlen += 2;
      $maxlen = 50 if $maxlen < 50;
      my $body = "# REGISTERED HOSTS\n";
      $body .= "-". "-"x$maxlen . "+" ."-------\n";
      $body .= " SERVICE" . (" "x($maxlen-7)) . "| HOSTS \n";
      $body .= "-". "-"x$maxlen . "+" ."-------\n";
      for my $service (@{$self->sorted_services}) {
          $body .= " " . $service->{service} . (" "x($maxlen - zlength($service->{service}))) . '| ' . sprintf('% 5d',$service->{host_num}) . " \n"
      }
      $body .= "-"."-"x$maxlen . "+" ."-------\n";
  
      $body .= "\n# LOADED PLUGINS\n";
  
      $body .= " PLUGIN" . (" "x($maxlen-6)) . "|  TYPE \n";
      $body .= "-". "-"x$maxlen . "+" ."-------\n";
      for my $load_plugin (keys %{$self->{load_plugins}}) {
          for my $type ( @{$self->{load_plugins}{$load_plugin}} ) {
          $body .= " "
              . $load_plugin
              . (" "x($maxlen - zlength($load_plugin)))
              . '| '
              . sprintf('% 5s',$type) . " \n"
          }
      }
      $body .= "-"."-"x$maxlen . "+" ."-------\n";
  
      return "$body\n";
  }
  
  1;
  
KURADO_CONFIGLOADER

$fatpacked{"Kurado/Host.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_HOST';
  package Kurado::Host;
  
  use strict;
  use warnings;
  use utf8;
  use 5.10.0;
  use Mouse;
  use Log::Minimal;
  use Data::Validator;
  
  use Kurado::Plugin::Compile;
  use Kurado::Storage;
  use Kurado::RRD;
  
  has 'config_loader' => (
      is => 'ro',
      isa => 'Kurado::ConfigLoader',
      required => 1
  );
  
  has 'host' => (
      is => 'ro',
      isa => 'Kurado::Object::Host',
      required => 1
  );
  
  __PACKAGE__->meta->make_immutable();
  
  our $LAST_RECEIVED_EXPIRES = 300;
  
  sub config {
      $_[0]->config_loader->config;
  }
  
  sub plugins {
      my $self = shift;
      $self->host->plugins;
  }
  
  sub address {
      my $self = shift;
      $self->host->address;
  }
  
  sub hostname {
      my $self = shift;
      $self->host->hostname;
  }
  
  sub service {
      my $self = shift;
      $self->host->service;
  }
  
  sub comments {
      my $self = shift;
      $self->host->comments;
  }
  
  sub compile {
      my $self = shift;
      $self->{compile} ||= Kurado::Plugin::Compile->new(config=>$self->config);
  }
  
  sub storage {
      my $self = shift;
      $self->{storage} ||= Kurado::Storage->new(redis=>$self->config->redis);
  }
  
  sub metrics_list {
      my $self = shift;
  
      my @list;
      for my $plugin (@{$self->plugins}) {
          my $warn = $self->storage->get_warn_by_plugin(
              plugin => $plugin,
              address => $self->address,
          );
          
          my $last_received = $self->storage->get_last_recieved(
              plugin => $plugin,
              address => $self->address,            
          );
          if ( (!$last_received || $last_received < time - $LAST_RECEIVED_EXPIRES ) && !$self->config_loader->has_fetch_plugin($plugin->plugin) ) {
              $warn->{'__system__'} = 'Metrics are not updated in the last 5 minutes. This host or kurado_agent has been down';
              $warn->{'__system__'} .= '.last updated: ' . localtime($last_received) if $last_received;
          }
  
          #run list
          my $metrics = eval {
              my ($stdout, $stderr, $success) = $self->compile->run(
                  host => $self->host,
                  plugin => $plugin,
                  type => 'view',
              );
              die "$stderr\n" unless $success;
              warnf $stderr if $stderr;
              $self->parse_metrics_list($stdout);
          };
          if ( $@ ) {
              $warn->{_exec_plugin_} = $@;
          }
          push @list, {
              plugin => $plugin,
              warn => $warn,
              metrics => $metrics
          };
      }
      \@list;
  }
  
  # #       uptime  up 0 days,  8:56
  # # Traffic(eth0)
  # traffic-eth0
  # # CPU Memory
  # cpu
  # load-avg
  # memory-usage
  # tcp-established
  # # Disk Usage(/)
  # disk-usage-mapper_VolGroup-lv_root
  # # Disk Usage(mapper_VolGroup-lv_root)
  # disk-io-mapper_VolGroup-lv_root
  
  sub parse_metrics_list {
      my $self = shift;
      my $list = shift;
      my @metrics;
      for my $line ( split /\n/, $list ) {
          next unless $line;
          if ( $line =~ m/^#/ ) {
              $line =~ s!^# *!!g;
              $line =~ s! *$!!g;
              my ($label, @args) = split /\t/,$line;
              die "odd number of metrics_list meta in '# $line'" if @args % 2;
              my @meta;
              while ( @args ) {
                  my $key = shift(@args);
                  my $val = shift(@args);
                  push @meta, {key=>$key,value=>$val};
              }
              my %meta = @args;
              # label
              push @metrics, {
                  graphs => [],
                  label => $label,
                  meta => \@meta
              };
          }
          else {
              $line =~ s!^ *!!g;
              $line =~ s! *$!!g;
              if (!@metrics) {
                  push @metrics, {
                      graphs => [$line],
                      label => "",
                      meta => [],
                  };
              }
              else {
                  push @{$metrics[-1]{graphs}}, $line;
              }
          }
      }
      return \@metrics;
  }
  
  sub metrics_graph {
      state $rule = Data::Validator->new(
          graph => 'Str',
          plugin => 'Kurado::Object::Plugin',
          term => 'Str',
          from => 'Str',
          to => 'Str',
          width => 'Str'
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
      my ($img,$data);
      eval {
          my ($stdout, $stderr, $success) = $self->compile->run(
              host => $self->host,
              plugin => $args->{plugin},
              type => 'view',
              graph => $args->{graph},
          );
          die "$stderr\n" unless $success;
          warnf $stderr if $stderr;
          my $rrd = Kurado::RRD->new(data_dir => $self->config->data_dir);        
          ($img,$data) = $rrd->graph(
              def => $stdout,
              host => $self->host,
              plugin => $args->{plugin},
              term => $args->{term},
              from => $args->{from},
              to => $args->{to},
              width => $args->{width},
          );
      };
      die sprintf('address:%s plugin:%s graph:%s: %s'."\n",$self->host->address, $args->{plugin}->plugin, $args->{graph}, $@) if $@;
      return ($img,$data);
  }
  
  
  sub fetch_metrics {
      state $rule = Data::Validator->new(
          plugin => 'Kurado::Object::Plugin',
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
      my $body = '';
      eval {
          my ($stdout, $stderr, $success) = $self->compile->run(
              host => $self->host,
              plugin => $args->{plugin},
              type => 'fetch',
          );
          die "$stderr\n" unless $success;
          warnf $stderr if $stderr;
          $body .= $self->parse_fetched_metrics(
              plugin => $args->{plugin},
              result => $stdout
          );
      };
      if ( $@ ) {
          my $warn = $@;
          $warn =~ s!(?:\n|\r)!!g;
          my $time = time;
          my $plugin_key = $args->{plugin}->plugin_identifier_escaped;
          my $self_ip = $self->host->address;
          $body .= "$self_ip\t$plugin_key.warn.command\t$warn\t$time\n";
      }
      $body;
  }
  
  sub parse_fetched_metrics {
      state $rule = Data::Validator->new(
          plugin => 'Kurado::Object::Plugin',
          result => 'Str',
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
      my $time = time;
      my $result = $args->{result};
      my $plugin_key = $args->{plugin}->plugin_identifier_escaped;
      my $self_ip = $self->host->address;
      my $body = '';
      for my $ret (split /\n/, $result) {
          chomp($ret);
          my @ret = split /\t/,$ret;
          if ( $ret[0] !~ m!^(?:metrics|meta)\.! ) {
              $ret[0] = "metrics.$ret[0]";
          }
          if ( $ret[0] =~ m!^metrics\.! && $ret[0] !~ m!\.(?:gauge|counter|derive|absolute)$! ) {
              $ret[0] = "$ret[0].gauge";
          }
          $ret[0] = "$plugin_key.$ret[0]";
          $ret[2] ||= $time;
          $body .= join("\t", $self_ip, @ret[0,1,2])."\n";
      }
      $body;
  }
  
      # 2 = critical
      # 1 = warn
      # 0 = ok
  
  sub status {
      my $self = shift;
  
      if ( my ($base_plugin) = $self->host->has_plugin('base') ) {
          my $last_received = $self->storage->get_last_recieved(
              plugin => $base_plugin,
              address => $self->address,            
          );
          if ( !$last_received || $last_received < time - $LAST_RECEIVED_EXPIRES ) {
              return 2;
          }
      }
  
      my $has_warn = $self->storage->has_warn(
          address => $self->address,
      );
          
      return $has_warn ? 1 : 0;
  }
  
  1;
  
  
KURADO_HOST

$fatpacked{"Kurado/MQ.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_MQ';
  package Kurado::MQ;
  
  use strict;
  use warnings;
  use POSIX qw(EINTR EAGAIN EWOULDBLOCK :sys_wait_h);
  use IO::Socket qw(:crlf IPPROTO_TCP TCP_NODELAY);
  use IO::Socket::INET;
  use IO::Select;
  use Encode;
  
  our $READ_BYTES = 16 * 1024;
  
  sub new {
      my $class = shift;
      my %args = ref $_ ? %{$_[0]} : @_;
      %args = (
          server => '127.0.0.1:6379',
          keep_alive_timer => 180,
          timeout => 10,
          %args,
      );
      my $server = shift;
      my $self = bless \%args, $class;
      $self->connect;
      $self;
  }
  
  sub connect {
      my $self = shift;
      return $self->{sock} if $self->{sock};
      $self->{sockbuf} = '';
      $self->{message_id} = 1;
      my $socket = IO::Socket::INET->new(
          PeerAddr => $self->{server},
          Timeout => $self->{timeout},
      ) or die "Socket connect failed: $!";
      $socket->blocking(0);
      $socket->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1)
          or die "setsockopt(TCP_NODELAY) failed:$!";
      $self->{sock} = $socket;
  
      # ping 
      $self->{next_ping} = time + $self->{keep_alive_timer};
  
      $socket;
  }
  
  sub send_message {
      my $self = shift;
      my @msg = @_;
      return unless @msg;
      my $msg = '*'.scalar(@msg).$CRLF;
      for my $m (@msg) {
          $m = Encode::encode_utf8($m);
          $msg .= '$'.length($m).$CRLF;
          $msg .= $m.$CRLF;
      }
      $self->write_all($msg);
  }
  
  sub read_message {
      my $self = shift;
      $self->{sockbuf} = '';
      while (1) {
          my $msg = $self->parse_reply($self->{sockbuf});
          return $msg if (defined $msg);
          $self->read_timeout(\$self->{sockbuf}, $READ_BYTES, length $self->{sockbuf})
              or return;
      }
  }
  
  sub parse_reply {
      my $self = shift;
      my $buf = shift;
      return unless $buf =~ m/$CRLF$/sm;
      $buf =~ s/$CRLF$//sm;
  
      my $s = substr($buf,0,1,"");
      if ( $s eq '+' ) {
          # 1 line reply
          return Kurado::Agent::MQ::Msg->new($s);
      }
      elsif ( $s eq '-' ) {
          # error
          # -ERR unknown command 'a'
          return Kurado::Agent::MQ::Msg->new(undef,$s);
      }
      elsif ( $s eq ':' ) {
          # numeric
          # :1404956783
          return Kurado::Agent::MQ::Msg->new($s);
      }
      elsif ( $s eq '$' ) {
          # bulk
          # C: get mykey
          # S: $3
          # S: foo
          my @msg = split /$CRLF/,$buf, 2;
          return unless @msg == 2;
          if ( $msg[0] eq '-1' ) {
              return Kurado::Agent::MQ::Msg->new(undef);
          }
          return unless $msg[0] == length($msg[1]);
          return Kurado::Agent::MQ::Msg->new($msg[1]);
      }
      elsif ( $s eq '*' ) {
          # multibulk
          # *3
          # $3
          # foo
          # $-1
          # $3
          # baa
          #
          ## null list/timeout
          # *-1
          #
  
          my @msg = split /$CRLF/,$buf;
          my $n = shift @msg;
          return Kurado::Agent::MQ::Msg->new(undef) if $n eq '-1';
          my @res;
          while (my $k = shift @msg) {
              return unless $k =~ m!^\$(-?\d+)$!;
              my $length = $1;
              if ( $length eq '-1' ) {
                  push @res, undef;
                  next;
              }
              my $v = shift @msg;
              return unless length($v) == $length;
              push @res, $v;
          }
          return if @res != $n;
          return Kurado::Agent::MQ::Msg->new(\@res);
      }
      die "failed parse_reply\n";
  }
  
  sub watchfh_publisher {
      my ($self, $fh, $sub ) = @_;
      my $socket = $self->connect;
      my @fh = ref $fh eq 'ARRAY' ? @$fh : ($fh);
      my $s = IO::Select->new($socket, @fh);
      $self->{stop_loop} = 0;
      while ( !$self->{stop_loop} ) {
          my $read_timeout = $self->{next_ping} - time;
          my @can_read = $s->can_read($read_timeout);
          for my $rs (@can_read) {
              if ( fileno($rs) == fileno($socket) ) {
                  # redis socket
                  die "may be disconnected from server\n";
              }
              else {
                  my $msg = $sub->($rs);
                  if ( ref $msg ) {
                      $self->send_message(
                          'RPUSH', $msg->[0], $msg->[1]
                      ) or die "failed to send_message 'RPUSH': $!\n";
                      my $res = $self->read_message();
                      if ( !ref $res || !$res->success ) {
                          die "failed to push msg: ".$res->error."\n";
                      }
                  }
              }
          }
          if ( time >= $self->{next_ping} ) {
              $self->send_message('PING') 
                  or die "failed to send_message 'PING': $!\n";
              $self->read_message()
                  or die "failed to read Pong. maybe disconnected from server\n";
              $self->{next_ping} = time + $self->{keep_alive_timer};
          }
      }
  }
  
  sub timetick_publisher {
      my ($self, $interval, $max_delay, $sub ) = @_;
      my $socket = $self->connect;
  
      my $delay = int(rand($max_delay));
      my $next_tick = $interval + time;
      $next_tick = $next_tick - ($next_tick % $interval) + $delay;
  
      my $s = IO::Select->new($socket);
      $self->{stop_loop} = 0;
      while ( !$self->{stop_loop} ) {
          my $read_timeout = $next_tick > $self->{next_ping} ? $self->{next_ping} : $next_tick;
          $read_timeout = $read_timeout - time;
          if ( $s->can_read($read_timeout) ) {
              # redis socket
              die "may be disconnected from server\n";
          }
          # ping
          if ( time >= $self->{next_ping} ) {
              $self->send_message('PING') 
                  or die "failed to send_message 'PING': $!\n";
              $self->read_message()
                  or die "failed to read Pong. maybe disconnected from server\n";
              $self->{next_ping} = time + $self->{keep_alive_timer};
          }
          # app
          if ( time >= $next_tick  ) {
              $next_tick = time + $interval;
              $next_tick = $next_tick - ($next_tick % $interval) + $delay;
              my $msg = $sub->();
              if ( ref $msg ) {
                  $self->enqueue(@$msg);
              }
          }
      }
  }
  
  sub subscribe {
      my $self = shift;
      my %callbacks = @_;
      my $socket = $self->connect;
  
      my $queue_wait = int($self->{timeout}/2); # brocking time. half of timeout
      $queue_wait ||= 1;
      my @req = ('BLPOP');
      push @req, $_ for keys %callbacks;
      push @req, $queue_wait;
  
      my $s = IO::Select->new($socket);
      $self->{stop_loop} = 0;
      while ( !$self->{stop_loop} ) {
          $self->send_message(@req) 
              or die "failed to send_message 'BLPOP': $!\n";
          my $res = $self->read_message();
          if ( !ref $res || !$res->success ) {
              die "failed to pop msg: ".$res->error."\n";
          }
          if ( ! defined $res->message || ! ref $res->message ) {
              # timeout
              next;
          }
          my ($received_topic,$message) = @{$res->message};
          next unless exists $callbacks{$received_topic}; #??
          eval {
              $callbacks{$received_topic}->($received_topic,$message);
          };
          warn "[ERROR] $received_topic: $@\n" if $@;
      }
  }
  
  sub enqueue {
      my ($self,$key,$val) = @_;
      $self->send_message(
          'RPUSH', $key, $val
      ) or die "failed to send_message 'RPUSH': $!\n";
      my $res = $self->read_message();
      if ( !ref $res || !$res->success ) {
          die "failed to push msg: ".$res->error."\n";
      }
      $res;
  }
  
  # returns (positive) number of bytes read, or undef if the socket is to be closed
  sub read_timeout {
      my ($self, $buf, $len, $off, $timeout) = @_;
      $timeout ||= $self->{timeout};
      $self->do_io(undef, $buf, $len, $off, $timeout);
  }
  
  # returns (positive) number of bytes written, or undef if the socket is to be closed
  sub write_timeout {
      my ($self, $buf, $len, $off, $timeout) = @_;
      $timeout ||= $self->{timeout};
      $self->do_io(1, $buf, $len, $off, $timeout);
  }
  
  # writes all data in buf and returns number of bytes written or undef if failed
  sub write_all {
      my ($self, $buf, $timeout) = @_;
      $timeout ||= $self->{timeout};
      my $off = 0;
      while (my $len = length($buf) - $off) {
          my $ret = $self->write_timeout($buf, $len, $off, $timeout)
              or return;
          $off += $ret;
      }
      return length $buf;
  }
  
  # returns value returned by $cb, or undef on timeout or network error
  sub do_io {
      my ($self, $is_write, $buf, $len, $off, $timeout) = @_;
      my $sock = $self->{sock};
      my $ret;
   DO_READWRITE:
      # try to do the IO
      if ($is_write) {
          $ret = syswrite $sock, $buf, $len, $off
              and return $ret;
      } else {
          $ret = sysread $sock, $$buf, $len, $off
              and return $ret;
      }
      unless ((! defined($ret)
                   && ($! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK))) {
          die "cannot write/read mq socket\n";
          return;
      }
      # wait for data
   DO_SELECT:
      while (1) {
          my ($rfd, $wfd);
          my $efd = '';
          vec($efd, fileno($sock), 1) = 1;
          if ($is_write) {
              ($rfd, $wfd) = ('', $efd);
          } else {
              ($rfd, $wfd) = ($efd, '');
          }
          my $start_at = time;
          my $nfound = select($rfd, $wfd, $efd, $timeout);
          $timeout -= (time - $start_at);
          last if $nfound;
          return if $timeout <= 0;
      }
      goto DO_READWRITE;
  }
  
  1;
  
  package Kurado::Agent::MQ::Msg;
  
  use strict;
  use warnings;
  
  sub new {
      my $class = shift;
      my $msg = shift;
      bless {
          msg => $msg, 
          (@_) ? (err => $_[0]) : (),
      }, $class;
  }
  
  sub error {
      my $self = shift;
      return $self->{err} if exists $self->{err};
      return;
  }
  
  sub success {
      my $self = shift;
      exists $self->{err} ? 0 : 1;
  }
  
  sub message {
      my $self = shift;
      return $self->{msg};
  }
  
  
  1;
  
  
KURADO_MQ

$fatpacked{"Kurado/Metrics.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_METRICS';
  package Kurado::Metrics;
  
  use strict;
  use warnings;
  use Mouse;
  use Log::Minimal;
  use URI::Escape;
  
  use Kurado::RRD;
  use Kurado::Storage;
  use Kurado::Object::Msg;
  
  has 'config' => (
      is => 'ro',
      isa => 'Kurado::Config',
      required => 1
  );
  
  __PACKAGE__->meta->make_immutable();
  
  sub process_message {
      my ($self,$message) = @_;
      my $rrd = Kurado::RRD->new(data_dir=>$self->config->data_dir);
      my $storage = Kurado::Storage->new(redis=>$self->config->redis);
      my %uniq_address_plugin;
      foreach my $line ( split /\n/, $message ) {
          chomp $line;
          my $msg = eval {
              $self->parse_metrics_line($line);
          };
          if ($@) {
              warnf("'$line' has error '$@'. ignore it");
              next;
          }
          my $key = $msg->address ."\t".$msg->plugin->plugin_identifier;
          $uniq_address_plugin{$key} = $msg;
          if ( $msg->metrics_type eq 'metrics' ) {
              # rrd update
              #debugf("rrd update %s",$msg);
              eval {
                  $rrd->update(msg=>$msg);
              };
              critf('failed update rrd %s : %s', $msg, $@) if $@;
          }
          elsif ( $msg->metrics_type eq 'meta' ) {
              # update storage
              $storage->set(
                  msg => $msg,
                  expires => 60*60
              );
          }
          elsif ( $msg->metrics_type eq 'warn' ) {
              # update storage
              $storage->set_warn(msg => $msg);
          }
      }
  
      for my $key (keys %uniq_address_plugin) {
          $storage->set_last_recieved(
              msg => $uniq_address_plugin{$key},
          );        
      }
      
  }
  
  sub parse_metrics_line {
      my ($self, $line) = @_;
      my @msg = split /\t/, $line;
      if ( @msg != 4 ) {
          die "msg does not have 4 column. ignore it\n";
      }
      my ($address, $key, $value, $timestamp) = @msg;
  
      # base.metrics.tcp-established.gauge
      # base.meta.traffic-interfaces
      # base.warn.traffic-interfaces
  
      my ($plugin, $type, $metrics_key) = split /\./, $key, 3;
      if ( !$type || !$metrics_key ) {
          die "key does not contains two dot\n";
      }
  
      if ( $type !~ m!^(?:metrics|meta|warn)$! ) {
          die "invalid metrics-type\n";
      }
  
      if ( $type eq 'metrics' && $metrics_key !~ m!\.(?:gauge|counter|derive|absolute)$! ) {
          die "invalid rrd data type\n";
      }
      
      my $obj_plugin = Kurado::Object::Plugin->new_from_identifier(uri_unescape($plugin));
      return Kurado::Object::Msg->new(
          address => $address,
          plugin => $obj_plugin,
          metrics_type => $type,
          key => $metrics_key,
          value => $value,
          timestamp => $timestamp
      );
  }
  
  1;
  
KURADO_METRICS

$fatpacked{"Kurado/Object/Host.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_OBJECT_HOST';
  package Kurado::Object::Host;
  
  use strict;
  use warnings;
  use 5.10.0;
  use Mouse;
  use JSON::XS;
  
  has 'address' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  has 'hostname' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  has 'comments' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  has 'roll' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  has 'metrics_config' => (
      is => 'ro',
      isa => 'HashRef[Any]',
      required => 1
  );
  
  has 'plugins' => (
      is => 'ro',
      isa => 'ArrayRef[Kurado::Object::Plugin]',
      required => 1
  );
  
  has 'service' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  __PACKAGE__->meta->make_immutable();
  
  sub has_plugin {
      my $self = shift;
      my $plugin = shift;
      grep { $_->plugin eq $plugin } @{$self->plugins}
  }
  
  sub TO_JSON {
      my $self = shift;
      +{map { ($_ => $self->$_) } qw/address hostname comments roll metrics_config plugins/};
  }
  
  1;
  
KURADO_OBJECT_HOST

$fatpacked{"Kurado/Object/Msg.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_OBJECT_MSG';
  package Kurado::Object::Msg;
  
  use strict;
  use warnings;
  use utf8;
  use 5.10.0;
  use Mouse;
  
  has 'plugin' => (
      is => 'ro',
      isa => 'Kurado::Object::Plugin',
      required => 1
  );
  
  has 'address' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  has 'metrics_type' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  has 'key' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  has 'value' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  has 'timestamp' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  
  __PACKAGE__->meta->make_immutable();
  
  
  1;
  
  
KURADO_OBJECT_MSG

$fatpacked{"Kurado/Object/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_OBJECT_PLUGIN';
  package Kurado::Object::Plugin;
  
  use strict;
  use warnings;
  use utf8;
  use 5.10.0;
  use Mouse;
  use JSON::XS;
  use URI::Escape;
  
  has 'plugin' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  has 'arguments' => (
      is => 'ro',
      isa => 'ArrayRef[Str]',
      required => 1
  );
  
  __PACKAGE__->meta->make_immutable();
  
  sub new_from_identifier {
      my $class = shift;
      my $identifier = shift;
      my ($plugin, @args) = split /:/, $identifier;
      $class->new(
          plugin => $plugin,
          arguments => \@args,
      );
  }
  
  
  sub plugin_identifier {
      my $self = shift;
      my $str = $self->plugin . ((@{$self->arguments}) ? ':'.join(":",@{$self->arguments}) : '');
      $str;
  }
  
  sub plugin_identifier_escaped {
      my $self = shift;
      uri_escape($self->plugin_identifier, "^A-Za-z0-9\-_"); #escape dot
  }
  
  sub TO_JSON {
      my $self = shift;
      +{map { ($_ => $self->$_) } qw/plugin arguments/};
  }
  
  1;
  
  
KURADO_OBJECT_PLUGIN

$fatpacked{"Kurado/Object/Roll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_OBJECT_ROLL';
  package Kurado::Object::Roll;
  
  use strict;
  use warnings;
  use 5.10.0;
  use Mouse;
  use JSON::XS;
  
  has 'metrics_config' => (
      is => 'ro',
      isa => 'HashRef[Any]',
      required => 1
  );
  
  has 'plugins' => (
      is => 'ro',
      isa => 'ArrayRef[Kurado::Object::Plugin]',
      required => 1
  );
  
  __PACKAGE__->meta->make_immutable();
  
  sub TO_JSON {
      my $self = shift;
      +{map { ($_ => $self->$_) } qw/metrics_config plugins/};
  }
  
  
  1;
  
KURADO_OBJECT_ROLL

$fatpacked{"Kurado/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_PLUGIN';
  package Kurado::Plugin;
  
  use strict;
  use warnings;
  use utf8;
  use 5.10.0;
  use Getopt::Long;
  use Pod::Usage;
  use JSON::XS;
  use Text::MicroTemplate::DataSectionEx;
  
  my $_JSON = JSON::XS->new->utf8;
  
  our %BRIDGE = ();
  
  sub new {
      my $class = shift;
      my @args = @_;
      my @caller = caller;
      # ($package, $filename, $line) = caller;
      my $self = bless {
          caller => \@caller,
          args => \@args,
      }, $class;
      $self->parse_options();
      $self;
  }
  
  sub parse_options {
      my $self = shift;
      local @ARGV = @{$self->{args}};
  
      my $parser = Getopt::Long::Parser->new(
          config => [ "no_auto_abbrev", "no_ignore_case", "pass_through" ],
      );
  
      $parser->getoptions(
          "address=s"          => \$self->{address},
          "hostname=s"         => \$self->{hostname},
          "comments=s"         => \my @comments,
          "plugin-arguments=s" => \my @plugin_arguments,
          "graph=s"            => \$self->{graph},
          "h|help"             => \my $help,
          "v|version"          => \my $version,
          "metrics-config-json=s" => \$self->{metrics_config_json},
          "metrics-meta-json=s"   => \$self->{metrics_meta_json},
      );
  
      my $plugin_version = eval '$'.$self->{caller}->[0]."::VERSION";
      $plugin_version //= 'unknown';
  
      if ( $version ) {
          print "display/base.pl version $plugin_version\n";
          print "Try `$self->{caller}[1] --help` for more options.\n\n";
          exit 0;
      }
  
      if ( $help ) {
          pod2usage({
              -verbose => 99,
              -exitval => 'noexit',
              -output => *STDOUT,
          });
          exit(0);
      }
      if ( !$self->{address} || !$self->{hostname} ) {
          pod2usage({
              -msg => 'ERR: address and hostname are required',
              -verbose => 1,
              -exitval => 'noexit',
              -output => *STDERR,
          });
          exit(2);
      }
  
      $self->{comments} = \@comments;
      $self->{plugin_arguments} = \@plugin_arguments;
  }
  
  sub address {
      $_[0]->{address};
  }
  
  sub hostname {
      $_[0]->{hostname};
  }
  
  sub comments {
      $_[0]->{comments};
  }
  
  sub plugin_arguments {
      $_[0]->{plugin_arguments};
  }
  
  sub graph {
      $_[0]->{graph};
  }
  
  use Log::Minimal;
  
  sub meta_config {
      my ($self,$key) = @_;
  
      return $self->{$key} if $self->{$key};
      if ( $self->{"${key}_json"} ) {
          if ( $self->{"${key}_json"} =~ m!^{! ) {
              $self->{$key} = eval { $_JSON->decode($self->{"${key}_json"}) };
              die $@ if $@;
          }
          else {
              $self->{$key} = eval {
                  open(my $fh, '<', $self->{"${key}_json"}) or die $!;
                  my $json_text = do { local $/; <$fh> };
                  $_JSON->decode($json_text)
              };
              die $@ if $@;
          }
      }
      elsif ( $BRIDGE{"kurado.${key}"} && ref $BRIDGE{"kurado.${key}"}) {
          $self->{$key} = $BRIDGE{"kurado.${key}"};
      }
      elsif ( exists $ENV{"kurado.${key}_json"} ) {
          $self->{$key} = eval { $_JSON->decode($ENV{"kurado.${key}_json"}) };
          die $@ if $@;
      }
      else {
          $self->{$key} = {};
      }
      $self->{$key}
  }
  
  sub metrics_config {
      my $self = shift;
      $self->meta_config('metrics_config');
  }
  
  sub metrics_meta {
      my $self = shift;
      $self->meta_config('metrics_meta');
  }
  
  sub uptime2str {
      my $self = shift;
      my $uptime = shift;
      my $day = int( $uptime /86400 );
      my $hour = int( ( $uptime % 86400 ) / 3600 );
      my $min = int( ( ( $uptime % 86400 ) % 3600) / 60 );
      sprintf("up %d days, %2d:%02d", $day, $hour, $min);
  }
  
  sub unit {
      my $self = shift;
      my $n = shift;
      my($base, $unit);
  
      return $n unless $n =~ /^\d+$/;
      if ($n >= 1073741824) {
          $base = 1073741824;
          $unit = 'GB';
      } elsif ($n >= 1048576) {
          $base = 1048576;
          $unit = 'MB';
      } elsif ($n >= 1024) {
          $base = 1024;
          $unit = 'KB';
      } else {
          $base = 1;
          $unit = 'B';
      }
  
      $n = sprintf '%.2f', $n/$base;
      while($n =~ s/(.*\d)(\d\d\d)/$1,$2/){};
      return $n.$unit;
  }
  
  my @info_order = (
      [qr/^version$/i => 1],
      [qr/^uptime$/i => 2],
      [qr/^version/i => 3],
      [qr/^uptime/i => 4],
      [qr/version$/i => 5],
      [qr/uptime$/i => 6],
  );
  sub match_order {
      my $key = shift;
      my ($hit) = grep { $key =~ m!$_->[0]! } @info_order;
      return 999 unless $hit;
      $hit->[1];
  }
  sub sort_info {
      my $self = shift;
      sort {
          match_order($a) <=> match_order($b) || $a cmp $b
      } @_;
  }
  
  sub render {
      my $self = shift;
      my $template = shift;
      my $args = defined $_[0] && ref $_[0] ? $_[0] : { @_ };
      my $mt = Text::MicroTemplate::DataSectionEx->new(
          extension => "",
          package => $self->{caller}->[0],
          template_args => $args,
      );
      $mt->render($template);
  }
  
  1;
  
  
  
KURADO_PLUGIN

$fatpacked{"Kurado/Plugin/Compile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_PLUGIN_COMPILE';
  package Kurado::Plugin::Compile;
  
  use strict;
  use warnings;
  use utf8;
  use 5.10.0;
  use Mouse;
  use Log::Minimal;
  use Data::Validator;
  use File::Spec;
  use File::Basename;
  use Cwd::Guard;
  use POSIX 'SEEK_SET';
  use SelectSaver;
  use JSON::XS;
  use Capture::Tiny;
  
  use Kurado::Storage;
  
  my $_JSON = JSON::XS->new->utf8;
  
  has 'config' => (
      is => 'ro',
      isa => 'Kurado::Config',
      required => 1
  );
  
  __PACKAGE__->meta->make_immutable();
  
  our $RETURN_EXIT_VAL = undef;
  our $USE_REAL_EXIT;
  BEGIN {
      $USE_REAL_EXIT = 1;
  
      my $orig = *CORE::GLOBAL::exit{CODE};
  
      my $proto = $orig ? prototype $orig : prototype 'CORE::exit';
  
      $proto = $proto ? "($proto)" : '';
  
      $orig ||= sub {
          my $exit_code = shift;
  
          CORE::exit(defined $exit_code ? $exit_code : 0);
      };
  
      no warnings 'redefine';
  
      *CORE::GLOBAL::exit = eval qq{
          sub $proto {
              my \$exit_code = shift;
  
              \$orig->(\$exit_code) if \$USE_REAL_EXIT;
  
              die [ "EXIT\n", \$exit_code || 0 ]
          };
      };
      die $@ if $@;
  }
  
  # this helper function is placed at the top of the file to
  # hide variables in this file from the generated sub.
  sub _eval {
      no strict;
      no warnings;
  
      eval $_[0];
  }
  
  my %COMPILE;
  sub compile {
      state $rule = Data::Validator->new(
          plugin => 'Str',
          type => 'Str',
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
      my $path = $self->find_plugin($args);
  
      return unless $path;
  
      return $COMPILE{$path} if $COMPILE{$path};
  
      infof "found plugin %s/%s at %s", $args->{type}, $args->{plugin}, $path;
      my $dir = dirname $path;
      my $package = $self->_build_package($path);
      my $code = $self->_read_source($path);
  
      my $warnings = $code =~ /^#!.*\s-w\b/ ? 1 : 0;
      $code =~ s/^__END__\r?\n.*//ms;
      $code =~ s/^__DATA__\r?\n(.*)//ms;
      my $data = $1;
  
          my $eval = join "\n",
          "package $package;",
          "sub {",
          '  local $Kurado::Plugin::Compile::USE_REAL_EXIT = 0;',
          '  local ($0, $Kurado::Plugin::Compile::_dir, *DATA);',
          '  {',
          '    my ($data, $path, $dir) = @_[0..2];',
          '    $0 = $path;',
          '    $Kurado::Plugin::Compile::_dir = Cwd::Guard::cwd_guard $dir;',
         q!    open DATA, '<', \$data;!,   
          '  }',
          # NOTE: this is a workaround to fix a problem in Perl 5.10
         q!  local @SIG{keys %SIG} = do { no warnings 'uninitialized'; @{[]} = values %SIG };!,
          '  local $^W = $warnings;',
          '  my $rv = eval {',
          '    local @ARGV = @{ $_[3] };', # args to @ARGV
          '    local @_    = @{ $_[3] };', # args to @_ as well
          "    #line 1 $path",
          "    $code",
          '  };',
          '  my $exit_code = 0;',
          '  if ($@) {',
          '    die "$@\n" unless (ref($@) eq "ARRAY" and $@->[0] eq "EXIT\n");', #no exit
         q!    $exit_code = unpack('C', pack('C', sprintf('%.0f', $@->[1])));!, # ~128
          '    die "exited nonzero: $exit_code" if $exit_code != 0;',
          '  }',
          '  return $exit_code;',
          '};',"\n";
  
      my $sub = do {
          no warnings 'uninitialized'; # for 5.8
          # NOTE: this is a workaround to fix a problem in Perl 5.10
          local @SIG{keys %SIG} = @{[]} = values %SIG;
          local $USE_REAL_EXIT = 0;
  
          my $code = _eval $eval;
          my $exception = $@;
  
          die "Could not compile $path: $exception\n" if $exception;
  
          sub {
              my @args = @_;
              $code->($data, $path, $dir, \@args)
          };
      };
      infof "succeeded compiling plugin %s/%s", $args->{type}, $args->{plugin}, $path;
      $COMPILE{$path} = $sub;
      return $sub;
  }
  
  sub jdclone {
      my $ref = shift;
      $_JSON->decode($_JSON->encode($ref));
  }
  
  sub run {
      state $rule = Data::Validator->new(
          host => 'Kurado::Object::Host',
          plugin => 'Kurado::Object::Plugin',
          type => 'Str',
          graph => { isa => 'Str', optional => 1 },
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
      
      my $sub = $self->compile(
          plugin => $args->{plugin}->plugin,
          type => $args->{type},
      );
  
      my $storage = Kurado::Storage->new( redis => $self->config->redis );
      my $meta = $storage->get_by_plugin(
          plugin => $args->{plugin},
          address => $args->{host}->address,
      );
  
      my @params = ();
      push @params, '--address', $args->{host}->address;
      push @params, '--hostname', $args->{host}->hostname;
      push @params, '--comments', $args->{host}->comments if length $args->{host}->comments;
      for my $p_a ( @{$args->{plugin}->arguments} ) {
          push @params, '--plugin-arguments', $p_a;
      }
      push @params, '--graph', $args->{graph} if exists $args->{graph};
  
      my ($stdout, $stderr, $success) = Capture::Tiny::capture {
          local $Kurado::Plugin::BRIDGE{'kurado.metrics_config'} = jdclone($args->{host}->metrics_config);
          local $Kurado::Plugin::BRIDGE{'kurado.metrics_meta'} = jdclone($meta);
          #local $ENV{'kurado.metrics_config_json'} = $_JSON->encode($args->{metrics_config});
          #local $ENV{'kurado.metrics_meta_json'} = $_JSON->encode($meta);
          eval {
              $sub->(@params);
          };
          if ( $@ ) {
              warn "$@\n";
              return 0;
          }
          return 1;
      };
      return ($stdout, $stderr, $success);
  }
  
  sub find_plugin {
      state $rule = Data::Validator->new(
          plugin => 'Str',
          type => 'Str',
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
  
      for my $dir ( @{$self->config->metrics_plugin_dir} ) {
          my $path = File::Spec->catfile($dir,$args->{type},$args->{plugin}.'.pl');
          if ( -f $path ) {
              return $path;
          }
      }
  
      return;
  }
  
  sub _read_source {
      my($self, $file) = @_;
  
      open my $fh, "<", $file or die "$file: $!";
      return do { local $/; <$fh> };
  }
  
  sub _build_package {
      my($self, $path) = @_;
  
      my ($volume, $dirs, $file) = File::Spec->splitpath($path);
      my @dirs = File::Spec->splitdir($dirs);
      my $package = join '_', grep { defined && length } $volume, @dirs, $file;
  
      # Escape everything into valid perl identifiers
      $package =~ s/([^A-Za-z0-9_])/sprintf("_%2x", unpack("C", $1))/eg;
  
      # make sure that the sub-package doesn't start with a digit
      $package =~ s/^(\d)/_$1/;
  
      $package = "Kurado::Plugin::Compile::ROOT" . "::$package";
      return $package;
  }
  
  1;
  
KURADO_PLUGIN_COMPILE

$fatpacked{"Kurado/RRD.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_RRD';
  package Kurado::RRD;
  
  use strict;
  use warnings;
  use 5.10.0;
  use Mouse;
  use RRDs 1.4004;
  use File::Spec;
  use File::Basename;
  use File::Path qw/make_path/;
  use Data::Validator;
  use URI::Escape;
  use Log::Minimal;
  
  has 'data_dir' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  __PACKAGE__->meta->make_immutable();
  
  sub _create {
      my ($self,$path) = @_;
      return $path if -f $path;
  
      if ( $path !~ m!\.(gauge|counter|derive|absolute)\.rrd$! ) {
          die "invalid path. not contains data type: $path\n";
      }
      my $dst = uc($1);
  
      my @param = (
          '--start', time - 10,
          '--step', '60',
          "DS:n:${dst}:120:U:U",
          'RRA:AVERAGE:0.5:1:2880',    #1分   1分    2日 2*24*60/(1*1) daily用
          'RRA:AVERAGE:0.5:5:2880',   #5分   5分    10日 10*24*60/(5*1) weekly用
          'RRA:AVERAGE:0.5:60:960',   #1時間  60分  40日 40*24*60/(60*1) monthly用
          'RRA:AVERAGE:0.5:1440:1100', #24時間 1440分 1100日
          'RRA:MIN:0.5:1:2880', 
          'RRA:MIN:0.5:5:2880',
          'RRA:MIN:0.5:60:960',
          'RRA:MIN:0.5:1440:1100',
          'RRA:MAX:0.5:1:2880', 
          'RRA:MAX:0.5:5:2880',
          'RRA:MAX:0.5:60:960',
          'RRA:MAX:0.5:1440:1100',
      );
  
      eval {
          if ( ! -d dirname($path) ) {
              make_path(dirname($path)) or die "make_path: $!\n";
          }
          RRDs::create($path, @param);
          my $ERR=RRDs::error;
          die "$ERR\n" if $ERR;
      };
      die "rrd create failed: $@\n" if $@;
      return $path;
  }
  
  sub update {
      state $rule = Data::Validator->new(
          msg => 'Kurado::Object::Msg'
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
  
      my $path = File::Spec->catfile(
          $self->data_dir,
          $args->{msg}->address,
          $args->{msg}->plugin->plugin_identifier_escaped,
          uri_escape($args->{msg}->key) . '.rrd'
      );
  
      $self->_create($path);
  
      my @param = (
          '-t', 'n',
          '--', join(':', $args->{msg}->timestamp, $args->{msg}->value)
      );
      debugf('rrd update %s %s', join(" ", @param), $path);
      eval {
          RRDs::update($path, @param);
          my $ERR=RRDs::error;
          if ( $ERR && $ERR =~ /illegal attempt to update using time.*when last update time is.*minimum one second step/ ) {
              warnf('failed update rrd %s%s: %s',$path,\@param, $ERR);
          }
          else {
              die "$ERR\n" if $ERR;
          }
      };
      die "rrd update failed: $@\n" if $@;
      return 1;
  }
  
  sub graph {
      state $rule = Data::Validator->new(
          def => 'Str',
          host => 'Kurado::Object::Host',
          plugin => 'Kurado::Object::Plugin',
          term => 'Str',
          from => 'Str',
          to => 'Str',
          width => 'Str',
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
  
      my ($title,$def) = $self->parse_graph_def(
          plugin => $args->{plugin},
          host => $args->{host},
          def => $args->{def},
      );
  
      my $period_title;
      my $period;
      my $end = 'now';
      my $xgrid;
  
      if ( $args->{term} eq 'custom' ) {
          my $from_time = HTTP::Date::str2time($args->{from});  
          die "invalid from date: $args->{from}\n" unless $from_time;
          my $to_time = $args->{to} ? HTTP::Date::str2time($args->{to}) : time;
          die "invalid to date: $args->{to}\n" unless $to_time;
          die "from($args->{from}) is newer than to($args->{to})\n" if $from_time > $to_time;
          $period_title = "$args->{from} to $args->{to}";
          $period = $from_time;
          $end = $to_time;
          my $diff = $to_time - $from_time;
          if ( $diff < 3 * 60 * 60 ) {
              $xgrid = 'MINUTE:10:MINUTE:30:MINUTE:30:0:%H:%M';
          }
          elsif ( $diff < 4 * 24 * 60 * 60 ) {
              $xgrid = 'HOUR:6:DAY:1:HOUR:6:0:%H:%M';
          }
          elsif ( $diff < 14 * 24 * 60 * 60) {
              $xgrid = 'DAY:1:DAY:7:DAY:2:0:%m/%d';
          }
          elsif ( $diff < 45 * 24 * 60 * 60) {
              $xgrid = 'DAY:1:WEEK:1:WEEK:1:0:%m/%d';
          }
          else {
              $xgrid = 'WEEK:1:MONTH:1:MONTH:1:2592000:%b';
          }
      }
      elsif ( $args->{term} eq 'year' ) {
          $period_title = 'Year';
          $period = -1 * 60 * 60 * 24 * 400;
          $xgrid = 'MONTH:1:MONTH:1:MONTH:1:2592000:%b'
      }
      elsif ( $args->{term} eq 'month' ) {
          $period_title = 'Month';
          $period = -1 * 60 * 60 * 24 * 35;
          $xgrid = 'WEEK:1:WEEK:1:WEEK:1:604800:Week %W'
      }
      elsif ( $args->{term} eq 'week' ) {
          $period_title = 'Week';
          $period = -1 * 60 * 60 * 24 * 8;
          $xgrid = 'DAY:1:DAY:1:DAY:1:86400:%a'
      }
      elsif ( $args->{term} eq 'day' ) {
          $period_title = 'Day';
          $period = -1 * 60 * 60 * 33; # 33 hours
          $xgrid = 'HOUR:2:HOUR:4:HOUR:4:0:%H:%M';
      }
      elsif ( $args->{term} eq '3days' ) {
          $period_title = '3 Days';
          $period = -1 * 60 * 60 * 24 * 3;
          $xgrid = 'HOUR:6:DAY:1:HOUR:12:0:%H:%M';
      }
      elsif ( $args->{term} eq '8hours' ) {
          $period_title = '8 Hours';
          $period = -1 * 8 * 60 * 60;
          $xgrid = 'MINUTE:30:HOUR:1:HOUR:1:0:%H:%M';
      }
      elsif ( $args->{term} eq '4hours' ) {
          $period_title = '4 Hours';
          $period = -1 * 4 * 60 * 60;
          $xgrid = 'MINUTE:30:HOUR:1:HOUR:1:0:%H:%M';
      }
      else {
          $period_title = 'Hour';
          $period = -1 * 60 * 70;
          $xgrid = 'MINUTE:10:MINUTE:20:MINUTE:10:0:%H:%M';
      }
  
      $period_title = $period_title . ' ' . $args->{host}->hostname;
      my ($tmpfh, $tmpfile) = File::Temp::tempfile(UNLINK => 0, SUFFIX => ".png");
      my @opt = (
          $tmpfile,
          '-w', $args->{width},
          '-h', 100,
          '-l', 0, #minimum
          '-u', 2, #maximum
          '-x', $xgrid,
          '-s', $period,
          '-e', $end,
          '-v', $title,
          #'--slope-mode',
          '--disable-rrdtool-tag',
          '--color', 'BACK#'.uc('f3f3f3'),
          '--color', 'CANVAS#'.uc('ffffff'),
          '--color', 'GRID#'.uc('8f8f8f'),
          '--color', 'MGRID#'.uc('666666'),
          '--color', 'FONT#'.uc('222222'),
          '--color', 'FRAME#'.uc('222222'),
          '--color', 'AXIS#'.uc('111111'),
          '--color', 'SHADEA#'.uc('dddddd'), #none
          '--color', 'SHADEB#'.uc('dddddd'), #none
          '--color', 'ARROW#'.uc('f89407'), 
          '--border', 1,
          '-t', $period_title,
          '--font-render-mode', 'light',
          '--font', "TITLE:8:",
          '--font', "AXIS:8:",
          '--font', "LEGEND:8:",
          @$def,
      );
      my @graphv;
      eval {
          @graphv = RRDs::graph(map { Encode::encode_utf8($_) } @opt);
          my $ERR=RRDs::error;
          die "$ERR\n" if $ERR;
      };
      if ( $@ ) {
          unlink($tmpfile);
          die "draw graph failed: $@\n";
      }
  
      open( my $fh, '<:bytes', $tmpfile ) or die "cannot open graph tmpfile: $!\n";
      local $/;
      my $graph_img = <$fh>;
      unlink($tmpfile);
  
      die "something wrong with image\n" unless $graph_img;
  
      return ($graph_img,\@graphv);
  }
  
  sub parse_graph_def {
      state $rule = Data::Validator->new(
          def => 'Str',
          host => 'Kurado::Object::Host',
          plugin => 'Kurado::Object::Plugin',
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
  
  # DEF:ind=<%RRD_FOR traffic-eth1-rxbytes.derive %>:n:AVERAGE
  # DEF:outd=<%RRD_FOR traffic-eth1-txbytes.derive %>:n:AVERAGE
  # CDEF:in=ind,0,1250000000,LIMIT,8,*
  # CDEF:out=outd,0,1250000000,LIMIT,8,*
  # AREA:in#00C000:Inbound  
  # GPRINT:in:LAST:Cur\:%6.2lf%sbps
  # GPRINT:in:AVERAGE:Ave\:%6.2lf%sbps
  # GPRINT:in:MAX:Max\:%6.2lf%sbps\l
  # LINE1:out#0000FF:Outbound 
  # GPRINT:out:LAST:Cur\:%6.2lf%sbps
  # GPRINT:out:AVERAGE:Ave\:%6.2lf%sbps
  # GPRINT:out:MAX:Max\:%6.2lf%sbps\l
      my $def = $args->{def};
      $def =~ s!<%RRD(?:_FOR)?\s+(.+?\.(?:gauge|counter|derive|absolute))\s+%>!&rrd_path_for($self,$args->{plugin},$args->{host},$1)!ge;
      $def =~ s!<%RRD_EXTEND\s+(.+?) +(.+?) +(.+?\.(?:gauge|counter|derive|absolute))\s+%>!&rrd_path_extend($self,$1,$2,$3)!ge;
      $def =~ s!^DEF:([^:]+):[^:]+:(MAX|AVERAGE|MIN)!DEF:$1:n:$2!gms;
      my @def = grep {$_} grep { $_ !~ m!^\s*#! } split /\n/,$def;
      my $title = shift @def;
      $title,\@def;
  }
  
  
  sub rrd_path_for {
      my ($self, $plugin,$host,$key) = @_;
      File::Spec->catfile(
          $self->data_dir,
          $host->address,
          $plugin->plugin_identifier_escaped,
          uri_escape($key) . '.rrd'
      );
  }
  
  sub rrd_path_extend {
      my ($self, $plugin,$ip, $key) = @_;
      File::Spec->catfile(
          $self->data_dir,
          $ip,
          $plugin,
          uri_escape($key) . '.rrd'
      );
      
  }
  
  
  1;
  
  
KURADO_RRD

$fatpacked{"Kurado/ScoreBoard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_SCOREBOARD';
  package Kurado::ScoreBoard;
  
  use strict;
  use warnings;
  use utf8;
  use File::Temp qw/tempdir/;
  use File::Path qw/remove_tree/;
  use Parallel::Scoreboard;
  use Mouse;
  use Log::Minimal;
  
  has 'config' => (
      is => 'ro',
      isa => 'Kurado::Config',
      required => 1
  );
  
  __PACKAGE__->meta->make_immutable();
  
  sub BUILD {
      my $self = shift;
      $self->{scoreboard_dir} = tempdir( CLEANUP => 0, DIR => $self->config->data_dir );
      $self->{sb} = Parallel::Scoreboard->new(base_dir=>$self->{scoreboard_dir});
      $self->{pid} = $$;
  }
  
  sub DEMOLISH {
      my $self = shift;
      if ( $self->{pid} == $$ && $self->{scoreboard_dir}) {
          delete $self->{sb};
          remove_tree(delete $self->{scoreboard_dir});
      }
  }
  
  sub idle {
      my ($self,$caller) = @_;
      ($caller) = caller unless $caller;
      $self->{sb}->update(sprintf('%s %s %s',0,time,$caller));
  }
  
  sub busy {
      my $self = shift;
      my ($caller) = caller;
      $self->{sb}->update(sprintf('%s %s %s',1,time,$caller));
      return Kurado::ScoreBoard::Guard->new(sub { $self->idle($caller) }) if defined wantarray;
      1;
  }
  
  sub kill_zombie {
      my $self = shift;
      my $threshold = shift;
      $threshold ||= 30;
      my $stats = $self->{sb}->read_all();
      my $now = time ;
      for my $pid ( keys %$stats) {
          my($status,$time,$type) = split /\s+/, $stats->{$pid}, 3;
          if ( $status == 1 && $now - $time > $threshold ) {
              warnf 'kill zombie %s pid:%s', $type, $pid;
              kill 'TERM', $pid;
          }
      }
  }
  
  1;
  
  package Kurado::ScoreBoard::Guard;
  
  sub new {
      my $class = shift;
      my $cb = shift;
      bless { cb => $cb, pid => $$ }, $class;
  }
  
  sub DESTROY {
      my $self = shift;
      if ( defined $self->{pid} && $self->{pid} == $$ ) {
          $self->{cb}->();
      }
  }
  
  1;
  
  
  
KURADO_SCOREBOARD

$fatpacked{"Kurado/Storage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_STORAGE';
  package Kurado::Storage;
  
  use strict;
  use warnings;
  use utf8;
  use 5.10.0;
  use Mouse;
  use Data::Validator;
  use Redis::Fast;
  use List::MoreUtils;
  use Log::Minimal;
  
  has 'redis' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  __PACKAGE__->meta->make_immutable();
  
  my %REDIS_CONNECTION;
  sub connect {
      my $self = shift;
      $REDIS_CONNECTION{"$$-".$self->redis} ||= Redis::Fast->new(
          server => $self->redis,
          reconnect => 10,
          every => 100
      );
      $REDIS_CONNECTION{"$$-".$self->redis};
  }
  
  sub set {
      state $rule = Data::Validator->new(
          msg => 'Kurado::Object::Msg',
          expires => 'Str',
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
      $self->_set(
          (map { ( $_ => $args->{$_} ) } qw/msg expires/),
          type => 'storage',
      );
  }
  
  
  sub set_warn {
      state $rule = Data::Validator->new(
          msg => 'Kurado::Object::Msg'
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
  
      my @lt = localtime($args->{msg}->{timestamp});
      my $timestr = sprintf '%04d-%02d-%02dT%02d:%02d:%02d', $lt[5]+1900, $lt[4]+1, @lt[3,2,1,0];
      $self->_set(
          msg  => $args->{msg},
          type => '__warn__',
          expires => 5*60,
          value => "$timestr ".$args->{msg}->value
      );
  }
  
  sub _set {
      state $rule = Data::Validator->new(
          msg => 'Kurado::Object::Msg',         
          expires => 'Str',
          type => 'Str',
          value => { isa => 'Str', optional => 1},
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
   
      my $set_key  = join "/", $args->{type},
          $args->{msg}->address, $args->{msg}->plugin->plugin_identifier_escaped;
      my $key = join "/", $args->{type}, 
          $args->{msg}->address, $args->{msg}->plugin->plugin_identifier_escaped, $args->{msg}->key;
      my $connect = $self->connect;
      my $now = time;
      my $expire_at = $now + $args->{expires};
      my $value = (exists $args->{value}) ? $args->{value} : $args->{msg}->value;
      my @res;
      $connect->multi(sub {});
      $connect->zadd($set_key, $expire_at, $args->{msg}->key, sub {});
      $connect->set($key, $value, sub {});
      $connect->expireat($key, $expire_at, sub {});
      if ( $args->{type} eq '__warn__' ) { #XXX
          my $has_warn_key = join "/", '__warn__', $args->{msg}->address;
          $connect->set($has_warn_key, $now, 'EX', $args->{expires}, sub {});
      }
      $connect->exec(sub { @res = @_ });
      $connect->wait_all_responses;
      if ( my @err = grep { ! defined $_->[0] } @{$res[0]} ) {
          die "Storage->set error: $err[0][1]\n";
      }
      return 1;
  }
  
  sub delete {
      state $rule = Data::Validator->new(
          plugin => 'Kurado::Object::Plugin',
          address => 'Str',
          key => 'Str'
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
  
      my $set_key  = join "/", 'storage',
          $args->{address}, $args->{plugin}->plugin_identifier_escaped;
      my $key = join "/", 'storage', 
          $args->{address}, $args->{plugin}->plugin_identifier_escaped, $args->{key};
  
      my $connect = $self->connect;
  
      my @res;
      $connect->multi(sub{});
      $connect->zrem($set_key, $args->{key}, sub{});
      $connect->del($key, sub{});
      $connect->exec(sub { @res = @_ });
      $connect->wait_all_responses;
      if ( my @err = grep { ! defined $_->[0] } @{$res[0]} ) {
          die "Storage->delete error: $err[0][1]\n";
      }
      return 1;
  }
  
  *remove = \&delete;
  
  sub get_by_plugin {
      state $rule = Data::Validator->new(
          plugin => 'Kurado::Object::Plugin',
          address => 'Str',
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
  
      my $set_key  = join "/", 'storage',
          $args->{address}, $args->{plugin}->plugin_identifier_escaped;
  
      my $connect = $self->connect;
      my $time = time;
      $connect->zremrangebyscore($set_key, '-inf', '('.$time);
      my @keys = $connect->zrangebyscore($set_key, $time, '+inf');
      return {} unless @keys;
      my @values = $connect->mget(map { $set_key.'/'.$_  } @keys);
      my %ret = List::MoreUtils::pairwise { ($a, $b) } @keys, @values;
      return \%ret;
  }
  
  sub get_warn_by_plugin {
      state $rule = Data::Validator->new(
          plugin => 'Kurado::Object::Plugin',
          address => 'Str',
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
  
      my $set_key  = join "/", '__warn__',
          $args->{address}, $args->{plugin}->plugin_identifier_escaped;
  
      my $connect = $self->connect;
      my $time = time;
      $connect->zremrangebyscore($set_key, '-inf', '('.$time);
      my @keys = $connect->zrangebyscore($set_key, $time, '+inf');
      if ( !@keys ) {
          return {};
      }
      my @values = $connect->mget(map { $set_key.'/'.$_  } @keys);
      my %ret = List::MoreUtils::pairwise { ($a, $b) } @keys, @values;
      return \%ret;
  }
  
  sub set_last_recieved {
      state $rule = Data::Validator->new(
          msg => 'Kurado::Object::Msg',
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
  
      my $value = time;
      my $key = join "/", '__last_recieved__', $args->{msg}->address, $args->{msg}->plugin->plugin_identifier_escaped;
      $self->connect->set($key, $value, 'EX', 365*86400);
  }
  
  
  sub get_last_recieved {
      state $rule = Data::Validator->new(
          plugin => 'Kurado::Object::Plugin',
          address => 'Str',
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
  
      my $value = time;
      my $key = join "/", '__last_recieved__', $args->{address}, $args->{plugin}->plugin_identifier_escaped;
      $self->connect->get($key);
  }
  
  sub has_warn {
      state $rule = Data::Validator->new(
          address => 'Str',
      )->with('Method');
      my ($self, $args) = $rule->validate(@_);
      my $key = join "/", '__warn__', $args->{address};
      $self->connect->get($key);
      
  }
  
  
  1;
  
  
KURADO_STORAGE

$fatpacked{"Kurado/TinyTCP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_TINYTCP';
  package Kurado::TinyTCP;
  
  use strict;
  use warnings;
  use POSIX qw(EINTR EAGAIN EWOULDBLOCK :sys_wait_h);
  use IO::Socket qw(IPPROTO_TCP TCP_NODELAY);
  use IO::Socket::INET;
  use IO::Select;
  use Time::HiRes qw//;
  
  our $READ_BYTES = 16 * 1024;
  
  sub new {
      my $class = shift;
      my %args = ref $_ ? %{$_[0]} : @_;
      %args = (
          server => '127.0.0.1:6379',
          timeout => 10,
          %args,
      );
      my $server = shift;
      my $self = bless \%args, $class;
      $self->connect;
      $self;
  }
  
  sub connect {
      my $self = shift;
      return $self->{sock} if $self->{sock};
      my $socket = IO::Socket::INET->new(
          PeerAddr => $self->{server},
          Timeout => $self->{timeout},
      ) or die "Socket connect failed: $!\n";
      $socket->blocking(0);
      $socket->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1)
          or die "setsockopt(TCP_NODELAY) failed:$!\n";
      $self->{sock} = $socket;
      $socket;
  }
  
  sub read : method {
      my ($self, $timeout) = @_;
      $timeout ||= $self->{timeout};
      my $timeout_at = Time::HiRes::time + $timeout;
      my $buf = '';
      my $n = $self->do_io(undef, \$buf, $READ_BYTES, 0, $timeout_at);
      die $! != 0 ? "$!\n" : "timeout\n" if !defined $n;
      return $buf;
  }
  
  sub write : method {
      my ($self, $buf, $timeout) = @_;
      $timeout ||= $self->{timeout};
      my $timeout_at = Time::HiRes::time + $timeout;
      my $off = 0;
      while (my $len = length($buf) - $off) {
          my $n = $self->do_io(1, $buf, $len, $off, $timeout_at);
          die $! != 0 ? "$!\n" : "timeout\n" if !defined $n;
          $off += $n;
      }
      return length $buf;    
  }
  
  
  
  # returns value returned by $cb, or undef on timeout or network error
  sub do_io {
      my ($self, $is_write, $buf, $len, $off, $timeout_at) = @_;
      my $sock = $self->{sock};
      my $ret;
   DO_READWRITE:
      # try to do the IO
      if ($is_write) {
          $ret = syswrite $sock, $buf, $len, $off
              and return $ret;
      } else {
          $ret = sysread $sock, $$buf, $len, $off
              and return $ret;
      }
      unless ((! defined($ret)
                   && ($! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK))) {
          return;
      }
      # wait for data
   DO_SELECT:
      while (1) {
          my $timeout = $timeout_at - Time::HiRes::time;
          return if $timeout <= 0;
          my ($rfd, $wfd);
          my $efd = '';
          vec($efd, fileno($sock), 1) = 1;
          if ($is_write) {
              ($rfd, $wfd) = ('', $efd);
          } else {
              ($rfd, $wfd) = ($efd, '');
          }
          my $nfound = select($rfd, $wfd, $efd, $timeout);
          last if $nfound;
      }
      goto DO_READWRITE;
  }
  
  1;
KURADO_TINYTCP

$fatpacked{"Kurado/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_UTIL';
  package Kurado::Util;
  
  use strict;
  use warnings;
  use utf8;
  use base qw/Exporter/;
  use POSIX ":sys_wait_h";
  
  our @EXPORT = qw/cap_cmd to_byte supervisor/;
  
  sub cap_cmd {
      my ($cmdref) = @_;
      pipe my $logrh, my $logwh
          or die "Died: failed to create pipe:$!\n";
      my $pid = fork;
      if ( ! defined $pid ) {
          die "Died: fork failed: $!\n";
      } 
  
      elsif ( $pid == 0 ) {
          #child
          close $logrh;
          open STDOUT, '>&', $logwh
              or die "Died: failed to redirect STDOUT\n";
          close $logwh;
          exec @$cmdref;
          die "Died: exec failed: $!\n";
      }
      close $logwh;
      my $result;
      while(<$logrh>){
          $result .= $_;
      }
      close $logrh;
      while (wait == -1) {}
      my $exit_code = $?;
      $exit_code = $exit_code >> 8;
      return ($result, $exit_code);
  }
  
  # Convert string like a "123 KB" into as byte
  sub to_byte {
      my $s = shift;
      my $b = 0;
  
      ($s) = ($s =~ /^\s*(.+?)\s*$/); # trim
  
      if ($s =~ /^[0-9]+$/) {
          $b = $s;
      } elsif ($s =~ /^([0-9]+)\s*([a-zA-Z]+)$/) {
          $b = $1;
          my $u = lc $2;
          if ($u eq 'kb') {
              $b = $b * 1024;
          } elsif ($u eq 'mb') {
              $b = $b * 1024 * 1024;
          } elsif ($u eq 'gb') {
              $b = $b * 1024 * 1024 * 1024;
          } elsif ($u eq 'tb') {
              $b = $b * 1024 * 1024 * 1024 * 1024;
          } else {
              warnf("Unknown unit: %s", $u);
          }
      } else {
          warnf("Failed to convert into as byte: %s", $s);
      }
  
      return $b;
  }
  
  sub supervisor {
      my $cb = shift;
      my $opts = @_ == 1 ? shift : { @_ };
      $opts->{interval} ||= 3;
  
      my @signals_received;
      $SIG{$_} = sub {
          warn "sig:$_[0]";
          push @signals_received, $_[0];
      } for (qw/INT TERM HUP/);
      $SIG{PIPE} = 'IGNORE';
      $SIG{CHLD} = sub {};
  
      my $pid;
      my $initial=1;
      while (1) {
          if ( $pid ) {
              my $kid = waitpid($pid, WNOHANG);
              if ( $kid == -1 ) {
                  $pid = undef;
              }
              elsif ( $kid ) {
                  my $status = $? >> 8;
                  warn "[supervisor] process $pid died with status:$status\n" unless @signals_received;
                  $pid = undef;
              }
          }
  
          if ( grep { $_ ne 'HUP' } @signals_received ) {
              warn "[supervisor] signals_received: " . join(",",  @signals_received) . "\n";
              last;
          }
  
          while ( my $signals_received = shift @signals_received ) {
              if ( $pid && $signals_received eq 'HUP' ) {
                  warn "[supervisor] HUP signal received, send TERM to $pid\n";
                  kill 'TERM', $pid;
                  waitpid( $pid, 0 );
                  $pid = undef;
              }
          }
  
          select( undef, undef, undef, $pid ? 60 : $opts->{interval}) if ! $initial;
          $initial=0;
  
          if ( ! defined $pid ) {
              $pid = fork();
              die "failed fork: $!\n" unless defined $pid;
              next if $pid; #main process
  
              # child process
              $SIG{$_} = 'DEFAULT' for (qw/INT TERM HUP CHLD/);
  
              $cb->();
              POSIX::_exit(255);
          }
      }  
  
      if ( $pid ) {
          kill 'TERM', $pid;
          waitpid( $pid, 0 );
      }
  }
  
  
  1;
  
KURADO_UTIL

$fatpacked{"Kurado/Web.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_WEB';
  package Kurado::Web;
  
  use strict;
  use warnings;
  use utf8;
  use 5.10.0;
  use Kossy;
  use Log::Minimal;
  use Kurado::Host;
  use Kurado::Object::Plugin;
  
  
  our $VERSION = '0.01';
  
  sub config_loader {
      $_[0]->{config_loader}
  }
  
  filter 'fill_config' => sub {
      my ($app) = @_;
      sub {
          my ($self, $c) = @_;
          $c->stash->{config_loader} = $self->config_loader;
          $app->($self, $c);
      };
  };
  
  filter 'get_server' => sub {
      my ($app) = @_;
      sub {
          my ($self, $c) = @_;
          my $address = $c->req->param('address');
          $c->halt('400') unless $address;
          my $host = $self->config_loader->host_by_address($address);
          $c->halt('404') unless $host;        
          $c->stash->{host} = Kurado::Host->new(
              config_loader => $self->config_loader,
              host => $host,
          );
          $app->($self, $c);
      };
  };
  
  filter 'get_plugin' => sub {
      my ($app) = @_;
      sub {
          my ($self, $c) = @_;
          my $plugin = $c->req->param('plugin_identifier');
          $c->halt('400') unless $plugin;
          $c->stash->{plugin} = Kurado::Object::Plugin->new_from_identifier($plugin);
          $app->($self, $c);
      };
  };
  
  
  get '/' => [qw/fill_config/] => sub {
      my ($self, $c)  = @_;
  
      my @services;
      if ( my $service = $c->req->param('service') ) {
          $c->halt(404) unless exists $self->config_loader->services->{$service};
          my $sections = $self->config_loader->services->{$service};
          push @services, {
              service => $service,
              sections => $sections
          };
      }
  
      $c->render('index.tx', {
          services => @services ? \@services : $self->config_loader->sorted_services,
      });
  };
  
  get '/server' => [qw/fill_config get_server/] => sub {
      my ($self, $c)  = @_;
      my $time = time;
      $time = $time - ($time%(60*15));
      my $result = $c->req->validator([
          'term' => {
              default => 'day',
              rule => [
                  [['CHOICE',qw/month day 3days 8hours 4hours 1hour custom/],'invalid drawing term'],
              ],
          },
          'from' => {
              default => timestr($time-3600*32),
              rule => [
                  [sub{ HTTP::Date::str2time($_[1]) }, 'invalid From datetime'],
              ],
          },
          'to' => {
              default => timestr($time),
              rule => [
                  [sub{ HTTP::Date::str2time($_[1]) }, 'invalid To datetime'],
              ],
          },
      ]);
      if ( $result->has_error ) {
          $c->halt(400,join("\n",@{$result->messages}));
      }
  
      my $s_width=400; 
      my $m_width=500; 
      my $l_width=1100;
      my %terms = (
          day => [{term=>"day",width=>$m_width},{term=>"week",width=>$m_width}],
          month => [{term=>"day",width=>400},{term=>"week",width=>$s_width},{term=>"month",width=>$s_width},{term=>"year",width=>$s_width}],
          "3days" => [{term=>"3days",width=>$l_width}],
          "8hours" => [{term=>"8hours",width=>$l_width}],
          "4hours" => [{term=>"4hours",width=>$l_width}],
          "1hour" => [{term=>"1hour",width=>$l_width}],
          custom => [{term=>"custom",width=>$l_width}],
      );
      my $term = $result->valid('term');
      my $terms = $terms{$term};
      my $plugin_identifier = $c->req->param('plugin_identifier');
  
      my $merge_nav = sub {
          my ($te, $pl) = @_;
          my @params = (address => $c->stash->{host}->address);
          if ( $te eq 'custom' ) {
              push @params, 'from', $result->valid('from');
              push @params, 'to', $result->valid('to');
          }
          push @params, 'term', $te if $te;
          push @params, 'plugin_identifier', $pl if $pl;
          return [@params];
      };
  
      $c->render('server.tx', { terms => $terms, term => $term, plugin_identifier => $plugin_identifier, result => $result, merge_nav => $merge_nav });
  };
  
  
  get '/servers' => [qw/fill_config/] => sub {
      my ($self, $c)  = @_;
      my $time = time;
      $time = $time - ($time%(60*15));
      my $result = $c->req->validator([
          'term' => {
              default => 'day',
              rule => [
                  [['CHOICE',qw/day week month year 3days 8hours 4hours 1hour custom/],'invalid drawing term'],
              ],
          },
          'from' => {
              default => timestr($time-3600*32),
              rule => [
                  [sub{ HTTP::Date::str2time($_[1]) }, 'invalid From datetime'],
              ],
          },
          'to' => {
              default => timestr($time),
              rule => [
                  [sub{ HTTP::Date::str2time($_[1]) }, 'invalid To datetime'],
              ],
          },
          '@address' => {
              rule => [
                  [['@SELECTED_NUM',1,500],'# of address should be in 1 to 500'],
                  ['@SELECTED_UNIQ','found duplicated address'],
              ],
          },
      ]);
      if ( $result->has_error ) {
          $c->halt(400,join("\n",@{$result->messages}));
      }
  
      my @address = $result->valid('address');
  
      # 2 = critical
      # 1 = warn
      # 0 = ok
  
      my @hosts;
      my %uniq_plugins;
      my @uniq_plugins;
      for my $address ( @address ) {
          my $host = $self->config_loader->host_by_address($address);
          if ( !$host ) {
              next;
          }
          for my $plugin (@{$host->plugins}) {
              next if $uniq_plugins{$plugin->plugin_identifier};
              push @uniq_plugins, $plugin->plugin_identifier;
              $uniq_plugins{$plugin->plugin_identifier} = 1;
          }
          push @hosts, Kurado::Host->new(
              config_loader => $self->config_loader,
              host => $host,
          );
      }
  
      my $s_width=420; 
      my %terms = (
          day => [{term=>"day",width=>$s_width}],
          week => [{term=>"week",width=>$s_width}],
          month => [{term=>"month",width=>$s_width}],
          year => [{term=>"year",width=>$s_width}],
          "3days" => [{term=>"3days",width=>$s_width}],
          "8hours" => [{term=>"8hours",width=>$s_width}],
          "4hours" => [{term=>"4hours",width=>$s_width}],
          "1hour" => [{term=>"1hour",width=>$s_width}],
          custom => [{term=>"custom",width=>$s_width}],
      );
      my $term = $result->valid('term');
      my $terms = $terms{$term};
      my $plugin_identifier = $c->req->param('plugin_identifier');
      my @host_query = map { ("address",$_->address) } @hosts;
      my $merge_nav = sub {
          my ($te, $pl, $adr) = @_;
          my @params;
          if ( $te eq 'custom' ) {
              push @params, 'from', $result->valid('from');
              push @params, 'to', $result->valid('to');
          }
          push @params, 'term', $te if $te;
          push @params, 'plugin_identifier', $pl if $pl;
          return [address => $adr, @params] if $adr;
          return [@host_query, @params];
      };
  
      $c->render('servers.tx', {
          terms => $terms,
          term => $term,
          plugin_identifier => $plugin_identifier,
          result => $result,
          hosts=>\@hosts,
          merge_nav => $merge_nav,
          uniq_plugins => \@uniq_plugins,
      });
  };
  
  
  sub timestr {
      my $time = shift;
      my @lt = localtime($time);
      sprintf('%04d-%02d-%02d %02d:%02d:%02d',$lt[5]+1900,$lt[4]+1,@lt[3,2,1,0]);
      
  }
  
  get '/graph' => [qw/fill_config get_server get_plugin/] => sub {
      my ($self, $c)  = @_;
      my $result = $c->req->validator([
          'term' => {
              default => 'day',
              rule => [
                  [['CHOICE',qw/year month week day 3days 8hours 4hours 1hour custom/],'invalid drawing term'],
              ],
          },
          'from' => {
              default => timestr(time-3600*32),
              rule => [
                  [sub{ HTTP::Date::str2time($_[1]) }, 'invalid From datetime'],
              ],
          },
          'to' => {
              default => timestr(time),
              rule => [
                  [sub{ HTTP::Date::str2time($_[1]) }, 'invalid To datetime'],
              ],
          },
          'width' => {
              default => 460,
              rule => [
                  ['NATURAL','invalid width'],
              ],
          },
          'graph' => {
              rule => [
                  ['NOT_NULL', 'missing graph key'],
              ],
          }
      ]);
      if ( $result->has_error ) {
          $c->halt(400,join("\n",@{$result->messages}));
      }
      eval {
          my ($img,$data) = $c->stash->{host}->metrics_graph(
              plugin => $c->stash->{plugin},
              graph => $result->valid('graph'),
              term => $result->valid('term'),
              from => $result->valid('from'),
              to => $result->valid('to'),
              width => $result->valid('width'),
          );
          $c->res->content_type('text/plain');
          $c->res->body($img);
      };
      if ($@) {
          $c->halt(500,$@);
      }
      return $c->res;
  };
  
  router [qw/GET POST/] => '/api/host-status' => [qw/fill_config/] => sub {
      my ($self, $c)  = @_;
      my $result = $c->req->validator([
          '@address' => {
              rule => [
                  [['@SELECTED_NUM',1,500],'# of address should be in 1 to 500'],
                  ['@SELECTED_UNIQ','found duplicated address'],
              ],
          },
      ]);
      if ( $result->has_error ) {
          $c->halt(400,join("\n",@{$result->messages}));
      }
      my @address = $result->valid('address');
  
      # 2 = critical
      # 1 = warn
      # 0 = ok
  
      my %result;
      for my $address ( @address ) {
          my $host = $self->config_loader->host_by_address($address);
          if ( !$host ) {
              $result{$address} = 2;
              next;
          }
          my $host_obj = Kurado::Host->new(
              config_loader => $self->config_loader,
              host => $host,
          );
          $result{$address} = $host_obj->status;
      }
      $c->render_json(\%result);
  };
  
  1;
  
  
KURADO_WEB

$fatpacked{"Kurado/Worker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_WORKER';
  package Kurado::Worker;
  
  use strict;
  use warnings;
  use Mouse;
  use Proclet;
  use Plack::Loader;
  use Plack::Builder;
  
  use Kurado::ScoreBoard;
  use Kurado::Worker::Updater;
  use Kurado::Worker::TimeMage;
  use Kurado::Worker::Fetcher;
  use Kurado::Web;
  
  has 'config_loader' => (
      is => 'ro',
      isa => 'Kurado::ConfigLoader',
      required => 1
  );
  
  has 'root_dir' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  
  __PACKAGE__->meta->make_immutable();
  
  sub run {
      my $self = shift;
      
      my $sb = Kurado::ScoreBoard->new(
          config => $self->config_loader->config,
      );
      my $proclet = Proclet->new(
          err_respawn_interval => 3,
          exec_notice => 0,
      );
      my $updater = Kurado::Worker::Updater->new(
          scoreboard => $sb,
          config_loader => $self->config_loader
      );
      my $fetcher = Kurado::Worker::Fetcher->new(
          scoreboard => $sb,
          config_loader => $self->config_loader
      );
  
      my $timemage = Kurado::Worker::TimeMage->new(
          config_loader => $self->config_loader
      );
  
      $proclet->service(
          code => sub {
              local $Log::Minimal::PRINT = sub {
                  my ( $time, $type, $message, $trace,$raw_message) = @_;
                  warn "[$type] $message at $trace\n";
              };
              local $0 = 'Kurado::Worker::Updater';
              $updater->run();
          },
          worker => 1,
          tag => 'updater'
      );
  
      $proclet->service(
          code => sub {
              local $Log::Minimal::PRINT = sub {
                  my ( $time, $type, $message, $trace,$raw_message) = @_;
                  warn "[$type] $message at $trace\n";
              };
              local $0 = 'Kurado::Worker::Fetcher';
              $fetcher->run();
          },
          worker => 1,
          tag => 'fetcher'
      );
  
      $proclet->service(
          code => sub {
              local $Log::Minimal::PRINT = sub {
                  my ( $time, $type, $message, $trace,$raw_message) = @_;
                  warn "[$type] $message at $trace\n";
              };
              local $0 = 'Kurado::Worker::TimeMage';
              $timemage->run();
          },
          worker => 1,
          tag => 'timemage',
          every => '* * * * *', # every minutes
      );
  
      $proclet->service(
          code => sub {
              local $Log::Minimal::PRINT = sub {
                  my ( $time, $type, $message, $trace,$raw_message) = @_;
                  warn "[$type] $message at $trace\n";
              };
              local $0 = 'Kurado::Worker::KillZombie';
              while(1) {
                  $sb->kill_zombie(30);
                  select undef, undef, undef, 3;
              }
          },
          worker => 1,
          tag => 'watcher'
      );
  
  
      my $app = Kurado::Web->new(
          config_loader => $self->config_loader,
          root_dir => $self->root_dir,
      );
      my $psgi_app = builder {
          enable 'ReverseProxy';
          enable 'Static',
              path => qr!^/(?:(?:css|fonts|js|img)/|favicon\.ico$)!,
                  root => $self->root_dir . '/public';
          $app->psgi;
      };
  
      $proclet->service(
          code => sub {
              local $Log::Minimal::PRINT = sub {
                  my ( $time, $type, $message, $trace,$raw_message) = @_;
                  warn "[$type] $message at $trace\n";
              };
              local $0 = 'Kurado:Web';
              my $loader = Plack::Loader->load(
                  'Starlet',
                  port => 5434,
                  host => 0,
                  max_workers => $self->config_loader->config->web_worker,
              );
              $loader->run($psgi_app);
          },
          tag => 'web',
      );
  
      $proclet->run;
  }
  
  1;
  
KURADO_WORKER

$fatpacked{"Kurado/Worker/Fetcher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_WORKER_FETCHER';
  package Kurado::Worker::Fetcher;
  
  use strict;
  use warnings;
  use Mouse;
  use Parallel::Prefork;
  use Log::Minimal;
  
  use Kurado::MQ;
  use Kurado::Host;
  
  has 'config_loader' => (
      is => 'ro',
      isa => 'Kurado::ConfigLoader',
      required => 1
  );
  
  has 'scoreboard' => (
      is => 'ro',
      isa => 'Kurado::ScoreBoard',
      required => 1
  );
  
  
  __PACKAGE__->meta->make_immutable();
  
  sub config {
      $_[0]->config_loader->config;
  }
  
  sub run {
      my $self = shift;
      my $pm = Parallel::Prefork->new({
          max_workers  => $self->config->fetch_worker,
          trap_signals => {
              TERM => 'TERM',
              HUP  => 'TERM',
          }
      });
      while ($pm->signal_received ne 'TERM') {
          $pm->start(sub{
              my $mq = Kurado::MQ->new(server => $self->config->redis);
              local $SIG{TERM} = sub {
                  $mq->{stop_loop} = 1;
              };
              $self->scoreboard->idle;
              my $process = 0;
              $mq->subscribe(
                  "kurado-fetch" => sub {
                      my ($topic, $message) = @_;
                      my $gurad = $self->scoreboard->busy;
                      my ($address, $plugin_identifier) = split /\t/, $message, 2;
                      my $host = $self->config_loader->host_by_address($address);
                      if (!$host) {
                          warnf 'address"%s is not found. skip it', $address;
                          return;
                      }
                      $process++;
                      $mq->{stop_loop} =  1 if $process > 500;
                      my $plugin = Kurado::Object::Plugin->new_from_identifier($plugin_identifier);
                      my $host_obj = Kurado::Host->new(
                          config_loader => $self->config_loader,
                          host => $host,
                      );
                      my $metrics = $host_obj->fetch_metrics(plugin => $plugin);
                      $mq->enqueue('kurado-update',$metrics);
                  },
              );
          });
      }
      $pm->wait_all_children();
  }
  
  
  
  1;
  
  
KURADO_WORKER_FETCHER

$fatpacked{"Kurado/Worker/TimeMage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_WORKER_TIMEMAGE';
  package Kurado::Worker::TimeMage;
  
  use strict;
  use warnings;
  use Mouse;
  use Parallel::Prefork;
  use Log::Minimal;
  
  use Kurado::MQ;
  
  has 'config_loader' => (
      is => 'ro',
      isa => 'Kurado::ConfigLoader',
      required => 1
  );
  
  __PACKAGE__->meta->make_immutable();
  
  sub run {
      my $self = shift;
      my $hosts = $self->config_loader->hosts;
      my $mq = Kurado::MQ->new( server => $self->config_loader->config->redis );
      for my $adrs ( keys %$hosts ) {
          my $host = $hosts->{$adrs};
          for my $plugin ( @{$host->plugins} ) {
              next unless $self->config_loader->has_fetch_plugin($plugin->plugin);
              my $msg = $host->address ."\t". $plugin->plugin_identifier;
              debugf("enqueue %s", $msg);
              $mq->enqueue('kurado-fetch',$msg);
          }
      }
  }
  
  
  1;
  
  
  
  
  
KURADO_WORKER_TIMEMAGE

$fatpacked{"Kurado/Worker/Updater.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'KURADO_WORKER_UPDATER';
  package Kurado::Worker::Updater;
  
  use strict;
  use warnings;
  use Mouse;
  use Parallel::Prefork;
  use Log::Minimal;
  
  use Kurado::MQ;
  use Kurado::Metrics;
  
  has 'config_loader' => (
      is => 'ro',
      isa => 'Kurado::ConfigLoader',
      required => 1
  );
  
  has 'scoreboard' => (
      is => 'ro',
      isa => 'Kurado::ScoreBoard',
      required => 1
  );
  
  
  __PACKAGE__->meta->make_immutable();
  
  sub config {
      $_[0]->config_loader->config
  }
  
  sub run {
      my $self = shift;
      my $pm = Parallel::Prefork->new({
          max_workers  => $self->config->update_worker,
          trap_signals => {
              TERM => 'TERM',
              HUP  => 'TERM',
          }
      });
      while ($pm->signal_received ne 'TERM') {
          $pm->start(sub{
              my $mq = Kurado::MQ->new(server => $self->config->redis);
              my $metrics = Kurado::Metrics->new(config => $self->config);
              local $SIG{TERM} = sub {
                  $mq->{stop_loop} = 1;
              };
              $self->scoreboard->idle;
              $mq->subscribe(
                  "kurado-update" => sub {
                      my ($topic, $message) = @_;
                      my $gurad = $self->scoreboard->busy;
                      $metrics->process_message($message);
                  },
              );
          });
      }
      $pm->wait_all_children();
  }
  
  
  
  1;
  
  
KURADO_WORKER_UPDATER

$fatpacked{"Pod/Escapes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ESCAPES';
  package Pod::Escapes;use strict;use warnings;use 5.006;use vars qw(%Code2USASCII %Name2character %Name2character_number %Latin1Code_to_fallback %Latin1Char_to_fallback $FAR_CHAR $FAR_CHAR_NUMBER $NOT_ASCII @ISA $VERSION @EXPORT_OK %EXPORT_TAGS);require Exporter;@ISA=('Exporter');$VERSION='1.06';@EXPORT_OK=qw(%Code2USASCII %Name2character %Name2character_number %Latin1Code_to_fallback %Latin1Char_to_fallback e2char e2charnum);%EXPORT_TAGS=('ALL'=>\@EXPORT_OK);$FAR_CHAR="?" unless defined$FAR_CHAR;$FAR_CHAR_NUMBER=ord($FAR_CHAR)unless defined$FAR_CHAR_NUMBER;$NOT_ASCII='A' ne chr(65)unless defined$NOT_ASCII;sub e2char {my$in=$_[0];return undef unless defined$in and length$in;if($in =~ m/^(0[0-7]*)$/s){$in=oct$in}elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s){$in=hex $1}if($NOT_ASCII){unless($in =~ m/^\d+$/s){$in=$Name2character{$in};return undef unless defined$in;$in=ord$in}return$Code2USASCII{$in}|| $Latin1Code_to_fallback{$in}|| $FAR_CHAR}if($in =~ m/^\d+$/s){if($] < 5.007 and $in > 255){return$FAR_CHAR}else {return chr($in)}}else {return$Name2character{$in}}}sub e2charnum {my$in=$_[0];return undef unless defined$in and length$in;if($in =~ m/^(0[0-7]*)$/s){$in=oct$in}elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s){$in=hex $1}if($in =~ m/^[0-9]+$/s){return 0 + $in}else {return$Name2character_number{$in}}}%Name2character_number=('lt'=>60,'gt'=>62,'quot'=>34,'amp'=>38,'apos'=>39,'sol'=>47,'verbar'=>124,'lchevron'=>171,'rchevron'=>187,'nbsp',160,'iexcl',161,'cent',162,'pound',163,'curren',164,'yen',165,'brvbar',166,'sect',167,'uml',168,'copy',169,'ordf',170,'laquo',171,'not',172,'shy',173,'reg',174,'macr',175,'deg',176,'plusmn',177,'sup2',178,'sup3',179,'acute',180,'micro',181,'para',182,'middot',183,'cedil',184,'sup1',185,'ordm',186,'raquo',187,'frac14',188,'frac12',189,'frac34',190,'iquest',191,'Agrave',192,'Aacute',193,'Acirc',194,'Atilde',195,'Auml',196,'Aring',197,'AElig',198,'Ccedil',199,'Egrave',200,'Eacute',201,'Ecirc',202,'Euml',203,'Igrave',204,'Iacute',205,'Icirc',206,'Iuml',207,'ETH',208,'Ntilde',209,'Ograve',210,'Oacute',211,'Ocirc',212,'Otilde',213,'Ouml',214,'times',215,'Oslash',216,'Ugrave',217,'Uacute',218,'Ucirc',219,'Uuml',220,'Yacute',221,'THORN',222,'szlig',223,'agrave',224,'aacute',225,'acirc',226,'atilde',227,'auml',228,'aring',229,'aelig',230,'ccedil',231,'egrave',232,'eacute',233,'ecirc',234,'euml',235,'igrave',236,'iacute',237,'icirc',238,'iuml',239,'eth',240,'ntilde',241,'ograve',242,'oacute',243,'ocirc',244,'otilde',245,'ouml',246,'divide',247,'oslash',248,'ugrave',249,'uacute',250,'ucirc',251,'uuml',252,'yacute',253,'thorn',254,'yuml',255,'fnof',402,'Alpha',913,'Beta',914,'Gamma',915,'Delta',916,'Epsilon',917,'Zeta',918,'Eta',919,'Theta',920,'Iota',921,'Kappa',922,'Lambda',923,'Mu',924,'Nu',925,'Xi',926,'Omicron',927,'Pi',928,'Rho',929,'Sigma',931,'Tau',932,'Upsilon',933,'Phi',934,'Chi',935,'Psi',936,'Omega',937,'alpha',945,'beta',946,'gamma',947,'delta',948,'epsilon',949,'zeta',950,'eta',951,'theta',952,'iota',953,'kappa',954,'lambda',955,'mu',956,'nu',957,'xi',958,'omicron',959,'pi',960,'rho',961,'sigmaf',962,'sigma',963,'tau',964,'upsilon',965,'phi',966,'chi',967,'psi',968,'omega',969,'thetasym',977,'upsih',978,'piv',982,'bull',8226,'hellip',8230,'prime',8242,'Prime',8243,'oline',8254,'frasl',8260,'weierp',8472,'image',8465,'real',8476,'trade',8482,'alefsym',8501,'larr',8592,'uarr',8593,'rarr',8594,'darr',8595,'harr',8596,'crarr',8629,'lArr',8656,'uArr',8657,'rArr',8658,'dArr',8659,'hArr',8660,'forall',8704,'part',8706,'exist',8707,'empty',8709,'nabla',8711,'isin',8712,'notin',8713,'ni',8715,'prod',8719,'sum',8721,'minus',8722,'lowast',8727,'radic',8730,'prop',8733,'infin',8734,'ang',8736,'and',8743,'or',8744,'cap',8745,'cup',8746,'int',8747,'there4',8756,'sim',8764,'cong',8773,'asymp',8776,'ne',8800,'equiv',8801,'le',8804,'ge',8805,'sub',8834,'sup',8835,'nsub',8836,'sube',8838,'supe',8839,'oplus',8853,'otimes',8855,'perp',8869,'sdot',8901,'lceil',8968,'rceil',8969,'lfloor',8970,'rfloor',8971,'lang',9001,'rang',9002,'loz',9674,'spades',9824,'clubs',9827,'hearts',9829,'diams',9830,'OElig',338,'oelig',339,'Scaron',352,'scaron',353,'Yuml',376,'circ',710,'tilde',732,'ensp',8194,'emsp',8195,'thinsp',8201,'zwnj',8204,'zwj',8205,'lrm',8206,'rlm',8207,'ndash',8211,'mdash',8212,'lsquo',8216,'rsquo',8217,'sbquo',8218,'ldquo',8220,'rdquo',8221,'bdquo',8222,'dagger',8224,'Dagger',8225,'permil',8240,'lsaquo',8249,'rsaquo',8250,'euro',8364,);{%Name2character=();my($name,$number);while(($name,$number)=each%Name2character_number){if($] < 5.007 and $number > 255){$Name2character{$name}=$FAR_CHAR}else {$Name2character{$name}=chr$number}}$Name2character{'lt' }='<';$Name2character{'gt' }='>';$Name2character{'quot'}='"';$Name2character{'amp' }='&';$Name2character{'apos'}="'";$Name2character{'sol' }='/';$Name2character{'verbar'}='|'}%Code2USASCII=(32,' ',33,'!',34,'"',35,'#',36,'$',37,'%',38,'&',39,"'",40,'(',41,')',42,'*',43,'+',44,',',45,'-',46,'.',47,'/',48,'0',49,'1',50,'2',51,'3',52,'4',53,'5',54,'6',55,'7',56,'8',57,'9',58,':',59,';',60,'<',61,'=',62,'>',63,'?',64,'@',65,'A',66,'B',67,'C',68,'D',69,'E',70,'F',71,'G',72,'H',73,'I',74,'J',75,'K',76,'L',77,'M',78,'N',79,'O',80,'P',81,'Q',82,'R',83,'S',84,'T',85,'U',86,'V',87,'W',88,'X',89,'Y',90,'Z',91,'[',92,"\\",93,']',94,'^',95,'_',96,'`',97,'a',98,'b',99,'c',100,'d',101,'e',102,'f',103,'g',104,'h',105,'i',106,'j',107,'k',108,'l',109,'m',110,'n',111,'o',112,'p',113,'q',114,'r',115,'s',116,'t',117,'u',118,'v',119,'w',120,'x',121,'y',122,'z',123,'{',124,'|',125,'}',126,'~',);%Latin1Code_to_fallback=();@Latin1Code_to_fallback{0xA0 .. 0xFF}=(' ',qq{!},qq{C/},'PS',qq{\$?},qq{Y=},qq{|},'SS',qq{"},qq{(c)},'a',qq{<<},qq{!},"",qq{(r)},qq{-},'deg',qq{+-},'2','3',qq{'},'u','P',qq{*},qq{,},'1','o',qq{>>},qq{1/4},qq{1/2},qq{3/4},qq{?},'A','A','A','A','A','A','AE','C','E','E','E','E','I','I','I','I','D','N','O','O','O','O','O','x','O','U','U','U','U','U','Th','ss','a','a','a','a','a','a','ae','c','e','e','e','e','i','i','i','i','d','n','o','o','o','o','o',qq{/},'o','u','u','u','u','y','th','y',);{%Latin1Char_to_fallback=();my($k,$v);while(($k,$v)=each%Latin1Code_to_fallback){$Latin1Char_to_fallback{chr$k}=$v}}1;
POD_ESCAPES

$fatpacked{"Pod/Man.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_MAN';
  package Pod::Man;require 5.005;use strict;use subs qw(makespace);use vars qw(@ISA %ESCAPES $PREAMBLE $VERSION);use Carp qw(croak);use Encode qw(encode);use Pod::Simple ();@ISA=qw(Pod::Simple);$VERSION='2.28';BEGIN {my$parent=defined (&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : undef;unless (defined&DEBUG){*DEBUG=$parent || sub () {10}}}BEGIN {*ASCII=\&Pod::Simple::ASCII}BEGIN {*pretty=\&Pod::Simple::pretty}my%FORMATTING=(DEFAULT=>{cleanup=>1,convert=>1,guesswork=>1,literal=>0 },Data=>{cleanup=>0,convert=>0,guesswork=>0,literal=>0 },Verbatim=>{guesswork=>0,literal=>1 },C=>{guesswork=>0,literal=>1 },X=>{cleanup=>0,guesswork=>0 },);sub new {my$class=shift;my$self=$class->SUPER::new;$self->nbsp_for_S (1);if (my$preserve_whitespace=$self->can ('preserve_whitespace')){$self->$preserve_whitespace (1)}else {$self->fullstop_space_harden (1)}$self->accept_targets (qw/man MAN roff ROFF/);$self->merge_text (1);%$self=(%$self,@_);if ($$self{stderr}and not $$self{errors}){$$self{errors}='stderr'}delete $$self{stderr};if (not defined $$self{errors}){$$self{errors}='pod'}if ($$self{errors}eq 'stderr' || $$self{errors}eq 'die'){$self->no_errata_section (1);$self->complain_stderr (1);if ($$self{errors}eq 'die'){$$self{complain_die}=1}}elsif ($$self{errors}eq 'pod'){$self->no_errata_section (0);$self->complain_stderr (0)}elsif ($$self{errors}eq 'none'){$self->no_whining (1)}else {croak (qq(Invalid errors setting: "$$self{errors}"))}delete $$self{errors};$self->init_fonts;$self->init_quotes;$self->init_page;$$self{MAGIC_CPP}=1;$$self{MAGIC_EMDASH}=1;$$self{MAGIC_FUNC}=1;$$self{MAGIC_MANREF}=1;$$self{MAGIC_SMALLCAPS}=1;$$self{MAGIC_VARS}=1;return$self}sub toescape {(length ($_[0])> 1 ? '\f(' : '\f').$_[0]}sub init_fonts {my ($self)=@_;for (qw/fixed fixedbold fixeditalic fixedbolditalic/){my$font=$$self{$_};if (defined ($font)&& (length ($font)< 1 || length ($font)> 2)){croak qq(roff font should be 1 or 2 chars, not "$font")}}$$self{fixed}||='CW';$$self{fixedbold}||='CB';$$self{fixeditalic}||='CI';$$self{fixedbolditalic}||='CB';$$self{FONTS}={'000'=>'\fR','001'=>'\fI','010'=>'\fB','011'=>'\f(BI','100'=>toescape ($$self{fixed}),'101'=>toescape ($$self{fixeditalic}),'110'=>toescape ($$self{fixedbold}),'111'=>toescape ($$self{fixedbolditalic})}}sub init_quotes {my ($self)=(@_);$$self{quotes}||='"';if ($$self{quotes}eq 'none'){$$self{LQUOTE}=$$self{RQUOTE}=''}elsif (length ($$self{quotes})==1){$$self{LQUOTE}=$$self{RQUOTE}=$$self{quotes}}elsif ($$self{quotes}=~ /^(.)(.)$/ || $$self{quotes}=~ /^(..)(..)$/){$$self{LQUOTE}=$1;$$self{RQUOTE}=$2}else {croak(qq(Invalid quote specification "$$self{quotes}"))}$$self{LQUOTE}=~ s/\"/\"\"/;$$self{RQUOTE}=~ s/\"/\"\"/}sub init_page {my ($self)=@_;my@version=($] =~ /^(\d+)\.(\d{3})(\d{0,3})$/);$version[2]||=0;$version[2]*= 10 ** (3 - length$version[2]);for (@version){$_ += 0}my$version=join ('.',@version);$$self{center}='User Contributed Perl Documentation' unless defined $$self{center};$$self{release}='perl v' .$version unless defined $$self{release};$$self{indent}=4 unless defined $$self{indent};for (qw/center release/){$$self{$_}=~ s/\"/\"\"/g if $$self{$_}}}sub _handle_text {my ($self,$text)=@_;DEBUG > 3 and print "== $text\n";my$tag=$$self{PENDING}[-1];$$tag[2].= $self->format_text ($$tag[1],$text)}sub method_for_element {my ($self,$element)=@_;$element =~ tr/A-Z-/a-z_/;$element =~ tr/_a-z0-9//cd;return$element}sub _handle_element_start {my ($self,$element,$attrs)=@_;DEBUG > 3 and print "++ $element (<",join ('> <',%$attrs),">)\n";my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){DEBUG > 2 and print "<$element> starts saving a tag\n";$$self{IN_NAME}=0 if ($element ne 'Para' && length ($element)> 1);my$formatting={%{$$self{PENDING}[-1][1]|| $FORMATTING{DEFAULT}},%{$FORMATTING{$element}|| {}},};push (@{$$self{PENDING}},[$attrs,$formatting,'' ]);DEBUG > 4 and print "Pending: [",pretty ($$self{PENDING}),"]\n"}elsif (my$start_method=$self->can ("start_$method")){$self->$start_method ($attrs,'')}else {DEBUG > 2 and print "No $method start method, skipping\n"}}sub _handle_element_end {my ($self,$element)=@_;DEBUG > 3 and print "-- $element\n";my$method=$self->method_for_element ($element);if (my$cmd_method=$self->can ("cmd_$method")){DEBUG > 2 and print "</$element> stops saving a tag\n";my$tag=pop @{$$self{PENDING}};DEBUG > 4 and print "Popped: [",pretty ($tag),"]\n";DEBUG > 4 and print "Pending: [",pretty ($$self{PENDING}),"]\n";my$text=$self->$cmd_method ($$tag[0],$$tag[2]);if (defined$text){if (@{$$self{PENDING}}> 1){$$self{PENDING}[-1][2].= $text}else {$self->output ($text)}}}elsif (my$end_method=$self->can ("end_$method")){$self->$end_method ()}else {DEBUG > 2 and print "No $method end method, skipping\n"}}sub format_text {my ($self,$options,$text)=@_;my$guesswork=$$options{guesswork}&&!$$self{IN_NAME};my$cleanup=$$options{cleanup};my$convert=$$options{convert};my$literal=$$options{literal};if ($cleanup){$text =~ s/\\/\\e/g;$text =~ s/-/\\-/g;$text =~ s/_(?=_)/_\\|/g}if ($convert &&!$$self{utf8}&& ASCII){$text =~ s/([^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg}if ($literal){$text =~ s/(?<!\\\*)\'/\\*\(Aq/g;$text =~ s/(?<!\\\*)\`/\\\`/g}if ($guesswork){$text=$self->guesswork ($text)}return$text}sub quote_literal {my$self=shift;local $_=shift;my$index='(?: \[.*\] | \{.*\} )?';return qq{"$_"} if $$self{IN_NAME};m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \\\*\(Aq .* \\\*\(Aq                           # quoted and escaped
         | \\?\` .* ( \' | \\\*\(Aq )                     # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [-+]? ( \d[\d.]* | \.\d+ ) (?: [eE][-+]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xso and return '\f(FS' .$_ .'\f(FE';return '\f(FS\*(C`' .$_ ."\\*(C'\\f(FE"}sub guesswork {my$self=shift;local $_=shift;DEBUG > 5 and print "   Guesswork called on [$_]\n";s{
          ( (?:\G|^|\s) [\(\"]* [a-zA-Z] ) ( \\- )?
          ( (?: [a-zA-Z\']+ \\-)+ )
          ( [a-zA-Z\']+ ) (?= [\)\".?!,;:]* (?:\s|\Z|\\\ ) )
          \b
      } {
          my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
          $hyphen ||= '';
          $main =~ s/\\-/-/g;
          $prefix . $hyphen . $main . $suffix;
      }egx;if ($$self{MAGIC_EMDASH}){s{          (\s) \\-\\- (\s)                } { $1 . '\*(--' . $2 }egx;s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx}if ($$self{MAGIC_SMALLCAPS}){s{
              ( ^ | [\s\(\"\'\`\[\{<>] | \\[ ]  )                     # (1)
              ( [A-Z] [A-Z] (?: [/A-Z+:\d_\$&] | \\- | [.,\"\s] )* )  # (2)
              (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | \\[ ] | $ )      # (3)
          } {
              $1 . '\s-1' . $2 . '\s0'
          }egx}if ($$self{MAGIC_FUNC}){s{
              ( \b | \\s-1 )
              ( [A-Za-z_] ([:\w] | \\s-?[01])+ \(\) )
          } {
              $1 . '\f(IS' . $2 . '\f(IE'
          }egx}if ($$self{MAGIC_MANREF}){s{
              ( \b | \\s-1 )
              ( [A-Za-z_] (?:[.:\w] | \\- | \\s-?[01])+ )
              ( \( \d [a-z]* \) )
          } {
              $1 . '\f(IS' . $2 . '\f(IE\|' . $3
          }egx}if ($$self{MAGIC_VARS}){s{
             ( ^ | \s+ )
             ( [\$\@%] [\w:]+ )
             (?! \( )
          } {
              $1 . '\f(FS' . $2 . '\f(FE'
          }egx}s{ \" ([^\"]+) \" } { '\*(L"' . $1 . '\*(R"' }egx;if ($$self{MAGIC_CPP}){s{ \b C\+\+ } {\\*\(C+}gx}DEBUG > 5 and print "   Guesswork returning [$_]\n";return $_}sub mapfonts {my ($self,$text)=@_;my ($fixed,$bold,$italic)=(0,0,0);my%magic=(F=>\$fixed,B=>\$bold,I=>\$italic);my$last='\fR';$text =~ s<
          \\f\((.)(.)
      > <
          my $sequence = '';
          my $f;
          if ($last ne '\fR') { $sequence = '\fP' }
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $f = $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
          if ($f eq $last) {
              '';
          } else {
              if ($f ne '\fR') { $sequence .= $f }
              $last = $f;
              $sequence;
          }
      >gxe;return$text}sub textmapfonts {my ($self,$text)=@_;my ($fixed,$bold,$italic)=(0,0,0);my%magic=(F=>\$fixed,B=>\$bold,I=>\$italic);$text =~ s<
          \\f\((.)(.)
      > <
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
      >gxe;return$text}sub switchquotes {my ($self,$command,$text,$extra)=@_;$text =~ s/\\\*\([LR]\"/\"/g;my$c_is_quote=($$self{LQUOTE}=~ /\"/)|| ($$self{RQUOTE}=~ /\"/);my$fixedpat=join '|',@{$$self{FONTS}}{'100','101','110','111'};$fixedpat =~ s/\\/\\\\/g;$fixedpat =~ s/\(/\\\(/g;if ($text =~ m/\"/ || $text =~ m/$fixedpat/){$text =~ s/\"/\"\"/g;my$nroff=$text;my$troff=$text;$troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;if ($c_is_quote and $text =~ m/\\\*\(C[\'\`]/){$nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;$nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;$troff =~ s/\\\*\(C[\'\`]//g}$nroff=qq("$nroff") .($extra ? " $extra" : '');$troff=qq("$troff") .($extra ? " $extra" : '');$nroff =~ s/\Q$$self{FONTS}{100}\E(.*?)\\f[PR]/$1/g;$nroff =~ s/\Q$$self{FONTS}{101}\E(.*?)\\f([PR])/\\fI$1\\f$2/g;$nroff =~ s/\Q$$self{FONTS}{110}\E(.*?)\\f([PR])/\\fB$1\\f$2/g;$nroff =~ s/\Q$$self{FONTS}{111}\E(.*?)\\f([PR])/\\f\(BI$1\\f$2/g;if ($nroff ne $troff){return ".ie n $command $nroff\n.el $command $troff\n"}else {return "$command $nroff\n"}}else {$text=qq("$text") .($extra ? " $extra" : '');return "$command $text\n"}}sub protect {my ($self,$text)=@_;$text =~ s/^([.\'\\])/\\&$1/mg;return$text}sub makespace {my ($self)=@_;$self->output (".PD\n")if $$self{ITEMS}> 1;$$self{ITEMS}=0;$self->output ($$self{INDENT}> 0 ? ".Sp\n" : ".PP\n")if $$self{NEEDSPACE}}sub outindex {my ($self,$section,$index)=@_;my@entries=map {split m%\s*/\s*%}@{$$self{INDEX}};return unless ($section || @entries);$$self{INDEX}=[];my@output;if (@entries){push@output,['Xref',join (' ',@entries)]}if ($section){$index =~ s/\\-/-/g;$index =~ s/\\(?:s-?\d|.\(..|.)//g;push@output,[$section,$index ]}for (@output){my ($type,$entry)=@$_;$entry =~ s/\s+/ /g;$entry =~ s/\"/\"\"/g;$entry =~ s/\\/\\\\/g;$self->output (".IX $type " .'"' .$entry .'"' ."\n")}}sub output {my ($self,@text)=@_;if ($$self{ENCODE}){print {$$self{output_fh}}encode ('UTF-8',join ('',@text))}else {print {$$self{output_fh}}@text}}sub start_document {my ($self,$attrs)=@_;if ($$attrs{contentless}&&!$$self{ALWAYS_EMIT_SOMETHING}){DEBUG and print "Document is contentless\n";$$self{CONTENTLESS}=1}else {delete $$self{CONTENTLESS}}$$self{ENCODE}=0;if ($$self{utf8}){$$self{ENCODE}=1;eval {my@options=(output=>1,details=>1);my$flag=(PerlIO::get_layers ($$self{output_fh},@options))[-1];if ($flag & PerlIO::F_UTF8 ()){$$self{ENCODE}=0}}}if (!$$self{CONTENTLESS}){my ($name,$section);if (defined $$self{name}){$name=$$self{name};$section=$$self{section}|| 1}else {($name,$section)=$self->devise_title}my$date=$$self{date}|| $self->devise_date;$self->preamble ($name,$section,$date)unless$self->bare_output or DEBUG > 9}$$self{INDENT}=0;$$self{INDENTS}=[];$$self{INDEX}=[];$$self{IN_NAME}=0;$$self{ITEMS}=0;$$self{ITEMTYPES}=[];$$self{SHIFTWAIT}=0;$$self{SHIFTS}=[];$$self{PENDING}=[[]]}sub end_document {my ($self)=@_;if ($$self{complain_die}&& $self->errors_seen){croak ("POD document had syntax errors")}return if$self->bare_output;return if ($$self{CONTENTLESS}&&!$$self{ALWAYS_EMIT_SOMETHING});$self->output (q(.\" [End document]) ."\n")if DEBUG}sub devise_title {my ($self)=@_;my$name=$self->source_filename || '';my$section=$$self{section}|| 1;$section=3 if (!$$self{section}&& $name =~ /\.pm\z/i);$name =~ s/\.p(od|[lm])\z//i;if ($section !~ /^3/){require File::Basename;$name=uc File::Basename::basename ($name)}else {require File::Spec;my ($volume,$dirs,$file)=File::Spec->splitpath ($name);my@dirs=File::Spec->splitdir ($dirs);my$cut=0;my$i;for ($i=0;$i < @dirs;$i++){if ($dirs[$i]=~ /perl/){$cut=$i + 1;$cut++ if ($dirs[$i + 1]&& $dirs[$i + 1]eq 'lib');last}}if ($cut > 0){splice (@dirs,0,$cut);shift@dirs if ($dirs[0]=~ /^(site|vendor)(_perl)?$/);shift@dirs if ($dirs[0]=~ /^[\d.]+$/);shift@dirs if ($dirs[0]=~ /^(.*-$^O|$^O-.*|$^O)$/)}shift@dirs if$dirs[0]eq 'lib';splice (@dirs,0,2)if ($dirs[0]eq 'blib' && $dirs[1]eq 'lib');$name=join ('::',(grep {$_ ? $_ : ()}@dirs),$file)}return ($name,$section)}sub devise_date {my ($self)=@_;my$input=$self->source_filename;my$time;if ($input){$time=(stat$input)[9]|| time}else {$time=time}my ($year,$month,$day)=(localtime$time)[5,4,3];return sprintf ("%04d-%02d-%02d",$year + 1900,$month + 1,$day)}sub preamble {my ($self,$name,$section,$date)=@_;my$preamble=$self->preamble_template (!$$self{utf8});my$index="$name $section";$index =~ s/\"/\"\"/g;for ($name,$section){if (/\s/){s/\"/\"\"/g;$_='"' .$_ .'"'}}$date =~ s/\"/\"\"/g;$preamble =~ s/\@CFONT\@/$$self{fixed}/;$preamble =~ s/\@LQUOTE\@/$$self{LQUOTE}/;$preamble =~ s/\@RQUOTE\@/$$self{RQUOTE}/;chomp$preamble;my$version=$self->version_report;$self->output (<<"----END OF HEADER----");$self->output (".\\\" [End of preamble]\n")if DEBUG}sub cmd_para {my ($self,$attrs,$text)=@_;my$line=$$attrs{start_line};$self->makespace;if ($$self{SHIFTWAIT}){$self->output (".RS $$self{INDENT}\n");push (@{$$self{SHIFTS}},$$self{INDENT});$$self{SHIFTWAIT}=0}$self->output (".\\\" [At source line $line]\n")if defined ($line)&& DEBUG &&!$$self{IN_NAME};$text=reverse$text;$text =~ s/\A\s*?(?= \\|\S|\z)/\n/;$text=reverse$text;$self->output ($self->protect ($self->textmapfonts ($text)));$self->outindex;$$self{NEEDSPACE}=1;return ''}sub cmd_verbatim {my ($self,$attrs,$text)=@_;return unless$text =~ /\S/;$text=reverse$text;$text =~ s/\A\s*/\n/;$text=reverse$text;my@lines=split (/\n/,$text);my$unbroken=0;for (@lines){last if /^\s*$/;$unbroken++}$unbroken=10 if ($unbroken > 12 &&!$$self{MAGIC_VNOPAGEBREAK_LIMIT});$text =~ s/^/\\&/gm;$self->makespace;$self->output (".Vb $unbroken\n$text.Ve\n");$$self{NEEDSPACE}=1;return ''}sub cmd_data {my ($self,$attrs,$text)=@_;$text =~ s/^\n+//;$text =~ s/\n{0,2}$/\n/;$self->output ($text);return ''}sub heading_common {my ($self,$text,$line)=@_;$text =~ s/\s+$//;$text =~ s/\s*\n\s*/ /g;if ($$self{ITEMS}> 1){$$self{ITEMS}=0;$self->output (".PD\n")}$self->output (".\\\" [At source line $line]\n")if defined ($line)&& DEBUG;return$text}sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\\s-?\d//g;$text=$self->heading_common ($text,$$attrs{start_line});my$isname=($text eq 'NAME' || $text =~ /\(NAME\)/);$self->output ($self->switchquotes ('.SH',$self->mapfonts ($text)));$self->outindex ('Header',$text)unless$isname;$$self{NEEDSPACE}=0;$$self{IN_NAME}=$isname;return ''}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->output ($self->switchquotes ('.SS',$self->mapfonts ($text)));$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=0;return ''}sub cmd_head3 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->makespace;$self->output ($self->textmapfonts ('\f(IS' .$text .'\f(IE')."\n");$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=1;return ''}sub cmd_head4 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->makespace;$self->output ($self->textmapfonts ($text)."\n");$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=1;return ''}sub cmd_b {return $_[0]->{IN_NAME}? $_[2]: '\f(BS' .$_[2].'\f(BE'}sub cmd_i {return $_[0]->{IN_NAME}? $_[2]: '\f(IS' .$_[2].'\f(IE'}sub cmd_f {return $_[0]->{IN_NAME}? $_[2]: '\f(IS' .$_[2].'\f(IE'}sub cmd_c {return $_[0]->quote_literal ($_[2])}sub cmd_x {my ($self,$attrs,$text)=@_;push (@{$$self{INDEX}},$text);return ''}sub cmd_l {my ($self,$attrs,$text)=@_;if ($$attrs{type}eq 'url'){my$to=$$attrs{to};if (defined$to){my$tag=$$self{PENDING}[-1];$to=$self->format_text ($$tag[1],$to)}if (not defined ($to)or $to eq $text){return "<$text>"}elsif ($$self{nourls}){return$text}else {return "$text <$$attrs{to}>"}}else {return$text}}sub over_common_start {my ($self,$type,$attrs)=@_;my$line=$$attrs{start_line};my$indent=$$attrs{indent};DEBUG > 3 and print " Starting =over $type (line $line, indent ",($indent || '?'),"\n";unless (defined ($indent)&& $indent =~ /^[-+]?\d{1,4}\s*$/){$indent=$$self{indent}}if (@{$$self{SHIFTS}}< @{$$self{INDENTS}}){$self->output (".RS $$self{INDENT}\n");push (@{$$self{SHIFTS}},$$self{INDENT})}push (@{$$self{INDENTS}},$$self{INDENT});push (@{$$self{ITEMTYPES}},$type);$$self{INDENT}=$indent + 0;$$self{SHIFTWAIT}=1}sub over_common_end {my ($self)=@_;DEBUG > 3 and print " Ending =over\n";$$self{INDENT}=pop @{$$self{INDENTS}};pop @{$$self{ITEMTYPES}};if (@{$$self{SHIFTS}}> @{$$self{INDENTS}}){$self->output (".RE\n");pop @{$$self{SHIFTS}}}if (@{$$self{INDENTS}}> 0){$self->output (".RE\n");$self->output (".RS $$self{INDENT}\n")}$$self{NEEDSPACE}=1;$$self{SHIFTWAIT}=0}sub start_over_bullet {my$s=shift;$s->over_common_start ('bullet',@_)}sub start_over_number {my$s=shift;$s->over_common_start ('number',@_)}sub start_over_text {my$s=shift;$s->over_common_start ('text',@_)}sub start_over_block {my$s=shift;$s->over_common_start ('block',@_)}sub end_over_bullet {$_[0]->over_common_end}sub end_over_number {$_[0]->over_common_end}sub end_over_text {$_[0]->over_common_end}sub end_over_block {$_[0]->over_common_end}sub item_common {my ($self,$type,$attrs,$text)=@_;my$line=$$attrs{start_line};DEBUG > 3 and print "  $type item (line $line): $text\n";$text =~ s/\s+$//;my ($item,$index);if ($type eq 'bullet'){$item="\\\(bu";$text =~ s/\n*$/\n/}elsif ($type eq 'number'){$item=$$attrs{number}.'.'}else {$item=$text;$item =~ s/\s*\n\s*/ /g;$text='';$index=$item if ($item =~ /\w/)}if (@{$$self{SHIFTS}}==@{$$self{INDENTS}}){$self->output (".RE\n");pop @{$$self{SHIFTS}}}$self->output (".PD 0\n")if ($$self{ITEMS}==1);$item=$self->textmapfonts ($item);$self->output ($self->switchquotes ('.IP',$item,$$self{INDENT}));$$self{NEEDSPACE}=0;$$self{ITEMS}++;$$self{SHIFTWAIT}=0;if ($text){$text =~ s/\s*$/\n/;$self->makespace;$self->output ($self->protect ($self->textmapfonts ($text)));$$self{NEEDSPACE}=1}$self->outindex ($index ? ('Item',$index): ())}sub cmd_item_bullet {my$self=shift;$self->item_common ('bullet',@_)}sub cmd_item_number {my$self=shift;$self->item_common ('number',@_)}sub cmd_item_text {my$self=shift;$self->item_common ('text',@_)}sub cmd_item_block {my$self=shift;$self->item_common ('block',@_)}sub parse_from_file {my$self=shift;$self->reinit;if (ref ($_[0])eq 'HASH'){my$opts=shift @_;if (defined ($$opts{-cutting})&&!$$opts{-cutting}){$$self{in_pod}=1;$$self{last_was_blank}=1}}my$retval=$self->SUPER::parse_from_file (@_);my$fh=$self->output_fh ();my$oldfh=select$fh;my$oldflush=$|;$|=1;print$fh '';$|=$oldflush;select$oldfh;return$retval}sub parse_from_filehandle {my$self=shift;return$self->parse_from_file (@_)}sub parse_file {my ($self,$in)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_file ($in)}sub parse_lines {my ($self,@lines)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_lines (@lines)}sub parse_string_document {my ($self,$doc)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_string_document ($doc)}@ESCAPES{0xA0 .. 0xFF}=("\\ ",undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,"\\%",undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,"A\\*`","A\\*'","A\\*^","A\\*~","A\\*:","A\\*o","\\*(Ae","C\\*,","E\\*`","E\\*'","E\\*^","E\\*:","I\\*`","I\\*'","I\\*^","I\\*:","\\*(D-","N\\*~","O\\*`","O\\*'","O\\*^","O\\*~","O\\*:",undef,"O\\*/","U\\*`","U\\*'","U\\*^","U\\*:","Y\\*'","\\*(Th","\\*8","a\\*`","a\\*'","a\\*^","a\\*~","a\\*:","a\\*o","\\*(ae","c\\*,","e\\*`","e\\*'","e\\*^","e\\*:","i\\*`","i\\*'","i\\*^","i\\*:","\\*(d-","n\\*~","o\\*`","o\\*'","o\\*^","o\\*~","o\\*:",undef,"o\\*/","u\\*`","u\\*'","u\\*^","u\\*:","y\\*'","\\*(th","y\\*:",)if ASCII;sub preamble_template {my ($self,$accents)=@_;my$preamble=<<'----END OF PREAMBLE----';if ($accents){$preamble .= <<'----END OF PREAMBLE----'}return$preamble}1;
  .\\" Automatically generated by $version
  .\\"
  .\\" Standard preamble:
  .\\" ========================================================================
  $preamble
  .\\" ========================================================================
  .\\"
  .IX Title "$index"
  .TH $name $section "$date" "$$self{release}" "$$self{center}"
  .\\" For nroff, turn off justification.  Always turn off hyphenation; it makes
  .\\" way too many mistakes in technical documents.
  .if n .ad l
  .nh
  ----END OF HEADER----
  .de Sp \" Vertical space (when we can't use .PP)
  .if t .sp .5v
  .if n .sp
  ..
  .de Vb \" Begin verbatim text
  .ft @CFONT@
  .nf
  .ne \\$1
  ..
  .de Ve \" End verbatim text
  .ft R
  .fi
  ..
  .\" Set up some character translations and predefined strings.  \*(-- will
  .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
  .\" double quote, and \*(R" will give a right double quote.  \*(C+ will
  .\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
  .\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
  .\" nothing in troff, for use with C<>.
  .tr \(*W-
  .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
  .ie n \{\
  .    ds -- \(*W-
  .    ds PI pi
  .    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
  .    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
  .    ds L" ""
  .    ds R" ""
  .    ds C` @LQUOTE@
  .    ds C' @RQUOTE@
  'br\}
  .el\{\
  .    ds -- \|\(em\|
  .    ds PI \(*p
  .    ds L" ``
  .    ds R" ''
  .    ds C`
  .    ds C'
  'br\}
  .\"
  .\" Escape single quotes in literal strings from groff's Unicode transform.
  .ie \n(.g .ds Aq \(aq
  .el       .ds Aq '
  .\"
  .\" If the F register is turned on, we'll generate index entries on stderr for
  .\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
  .\" entries marked with X<> in POD.  Of course, you'll have to process the
  .\" output yourself in some meaningful fashion.
  .\"
  .\" Avoid warning from groff about undefined register 'F'.
  .de IX
  ..
  .nr rF 0
  .if \n(.g .if rF .nr rF 1
  .if (\n(rF:(\n(.g==0)) \{
  .    if \nF \{
  .        de IX
  .        tm Index:\\$1\t\\n%\t"\\$2"
  ..
  .        if !\nF==2 \{
  .            nr % 0
  .            nr F 2
  .        \}
  .    \}
  .\}
  .rr rF
  ----END OF PREAMBLE----
  .\"
  .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
  .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
  .    \" fudge factors for nroff and troff
  .if n \{\
  .    ds #H 0
  .    ds #V .8m
  .    ds #F .3m
  .    ds #[ \f1
  .    ds #] \fP
  .\}
  .if t \{\
  .    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
  .    ds #V .6m
  .    ds #F 0
  .    ds #[ \&
  .    ds #] \&
  .\}
  .    \" simple accents for nroff and troff
  .if n \{\
  .    ds ' \&
  .    ds ` \&
  .    ds ^ \&
  .    ds , \&
  .    ds ~ ~
  .    ds /
  .\}
  .if t \{\
  .    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
  .    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
  .    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
  .    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
  .    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
  .    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
  .\}
  .    \" troff and (daisy-wheel) nroff accents
  .ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
  .ds 8 \h'\*(#H'\(*b\h'-\*(#H'
  .ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
  .ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
  .ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
  .ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
  .ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
  .ds ae a\h'-(\w'a'u*4/10)'e
  .ds Ae A\h'-(\w'A'u*4/10)'E
  .    \" corrections for vroff
  .if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
  .if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
  .    \" for low resolution devices (crt and lpr)
  .if \n(.H>23 .if \n(.V>19 \
  \{\
  .    ds : e
  .    ds 8 ss
  .    ds o a
  .    ds d- d\h'-1'\(ga
  .    ds D- D\h'-1'\(hy
  .    ds th \o'bp'
  .    ds Th \o'LP'
  .    ds ae ae
  .    ds Ae AE
  .\}
  .rm #[ #] #H #V #F C
  ----END OF PREAMBLE----
POD_MAN

$fatpacked{"Pod/ParseLink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PARSELINK';
  package Pod::ParseLink;require 5.004;use strict;use vars qw(@EXPORT @ISA $VERSION);use Exporter;@ISA=qw(Exporter);@EXPORT=qw(parselink);$VERSION='1.10';sub _parse_section {my ($link)=@_;$link =~ s/^\s+//;$link =~ s/\s+$//;return (undef,$1)if ($link =~ /^"\s*(.*?)\s*"$/);my ($page,$section)=split (/\s*\/\s*/,$link,2);$section =~ s/^"\s*(.*?)\s*"$/$1/ if$section;if ($page && $page =~ / / &&!defined ($section)){$section=$page;$page=undef}else {$page=undef unless$page;$section=undef unless$section}return ($page,$section)}sub _infer_text {my ($page,$section)=@_;my$inferred;if ($page &&!$section){$inferred=$page}elsif (!$page && $section){$inferred='"' .$section .'"'}elsif ($page && $section){$inferred='"' .$section .'" in ' .$page}return$inferred}sub parselink {my ($link)=@_;$link =~ s/\s+/ /g;my$text;if ($link =~ /\|/){($text,$link)=split (/\|/,$link,2)}if ($link =~ /\A\w+:[^:\s]\S*\Z/){my$inferred;if (defined ($text)&& length ($text)> 0){return ($text,$text,$link,undef,'url')}else {return ($text,$link,$link,undef,'url')}}else {my ($name,$section)=_parse_section ($link);my$inferred;if (defined ($text)&& length ($text)> 0){$inferred=$text}else {$inferred=_infer_text ($name,$section)}my$type=($name && $name =~ /\(\S*\)/)? 'man' : 'pod';return ($text,$inferred,$name,$section,$type)}}1;
POD_PARSELINK

$fatpacked{"Pod/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE';
  require 5;package Pod::Simple;use strict;use Carp ();BEGIN {*DEBUG=sub () {0}unless defined&DEBUG}use integer;use Pod::Escapes 1.04 ();use Pod::Simple::LinkSection ();use Pod::Simple::BlackBox ();use vars qw($VERSION @ISA @Known_formatting_codes @Known_directives %Known_formatting_codes %Known_directives $NL);@ISA=('Pod::Simple::BlackBox');$VERSION='3.28';@Known_formatting_codes=qw(I B C L E F S X Z);%Known_formatting_codes=map(($_=>1),@Known_formatting_codes);@Known_directives=qw(head1 head2 head3 head4 item over back);%Known_directives=map(($_=>'Plain'),@Known_directives);$NL=$/ unless defined$NL;BEGIN {if(defined&ASCII){}elsif(chr(65)eq 'A'){*ASCII=sub () {1}}else {*ASCII=sub () {''}}unless(defined&MANY_LINES){*MANY_LINES=sub () {20}}DEBUG > 4 and print "MANY_LINES is ",MANY_LINES(),"\n";unless(MANY_LINES()>= 1){die "MANY_LINES is too small (",MANY_LINES(),")!\nAborting"}if(defined&UNICODE){}elsif($] >= 5.008){*UNICODE=sub() {1}}else {*UNICODE=sub() {''}}}if(DEBUG > 2){print "# We are ",ASCII ? '' : 'not ',"in ASCII-land\n";print "# We are under a Unicode-safe Perl.\n"}__PACKAGE__->_accessorize('nbsp_for_S','source_filename','source_dead','output_fh','hide_line_numbers','line_count','pod_para_count','no_whining','no_errata_section','complain_stderr','doc_has_started','bare_output','keep_encoding_directive','nix_X_codes','merge_text','preserve_whitespace','strip_verbatim_indent','parse_characters','content_seen','errors_seen','codes_in_verbatim','code_handler','cut_handler','pod_handler','whiteline_handler','parse_empty_lists',);sub any_errata_seen {return shift->{'errors_seen'}|| 0}sub detected_encoding {return shift->{'detected_encoding'}}sub encoding {my$this=shift;return$this->{'encoding'}unless @_;$this->_handle_encoding_line("=encoding $_[0]");if ($this->{'_processed_encoding'}){delete$this->{'_processed_encoding'};if(!$this->{'encoding_command_statuses'}){DEBUG > 2 and print " CRAZY ERROR: encoding wasn't really handled?!\n"}elsif($this->{'encoding_command_statuses'}[-1]){$this->scream("=encoding $_[0]",sprintf "Couldn't do %s: %s",$this->{'encoding_command_reqs' }[-1],$this->{'encoding_command_statuses'}[-1],)}else {DEBUG > 2 and print " (encoding successfully handled.)\n"}return$this->{'encoding'}}else {return undef}}BEGIN {*pretty=\&Pod::Simple::BlackBox::pretty;*stringify_lol=\&Pod::Simple::BlackBox::stringify_lol}sub version_report {my$class=ref($_[0])|| $_[0];if($class eq __PACKAGE__){return "$class $VERSION"}else {my$v=$class->VERSION;return "$class $v (" .__PACKAGE__ ." $VERSION)"}}sub output_string {my$this=shift;return$this->{'output_string'}unless @_;require Pod::Simple::TiedOutFH;my$x=(defined($_[0])and ref($_[0]))? $_[0]: \($_[0]);$$x='' unless defined $$x;DEBUG > 4 and print "# Output string set to $x ($$x)\n";$this->{'output_fh'}=Pod::Simple::TiedOutFH->handle_on($_[0]);return $this->{'output_string'}=$_[0]}sub abandon_output_string {$_[0]->abandon_output_fh;delete $_[0]{'output_string'}}sub abandon_output_fh {$_[0]->output_fh(undef)}sub new {my$class=ref($_[0])|| $_[0];return bless {'accept_codes'=>{map(($_=>$_),@Known_formatting_codes)},'accept_directives'=>{%Known_directives },'accept_targets'=>{},},$class}sub _handle_element_start {my($self,$element_name,$attr_hash_r)=@_;return}sub _handle_element_end {my($self,$element_name)=@_;return}sub _handle_text {my($self,$text)=@_;return}sub accept_directive_as_verbatim {shift->_accept_directives('Verbatim',@_)}sub accept_directive_as_data {shift->_accept_directives('Data',@_)}sub accept_directive_as_processed {shift->_accept_directives('Plain',@_)}sub _accept_directives {my($this,$type)=splice @_,0,2;for my$d (@_){next unless defined$d and length$d;Carp::croak "\"$d\" isn't a valid directive name" unless$d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;Carp::croak "\"$d\" is already a reserved Pod directive name" if exists$Known_directives{$d};$this->{'accept_directives'}{$d}=$type;DEBUG > 2 and print "Learning to accept \"=$d\" as directive of type $type\n"}DEBUG > 6 and print "$this\'s accept_directives : ",pretty($this->{'accept_directives'}),"\n";return sort keys %{$this->{'accept_directives'}}if wantarray;return}sub unaccept_directive {shift->unaccept_directives(@_)};sub unaccept_directives {my$this=shift;for my$d (@_){next unless defined$d and length$d;Carp::croak "\"$d\" isn't a valid directive name" unless$d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;Carp::croak "But you must accept \"$d\" directives -- it's a builtin!" if exists$Known_directives{$d};delete$this->{'accept_directives'}{$d};DEBUG > 2 and print "OK, won't accept \"=$d\" as directive.\n"}return sort keys %{$this->{'accept_directives'}}if wantarray;return}sub accept_target {shift->accept_targets(@_)}sub accept_target_as_text {shift->accept_targets_as_text(@_)}sub accept_targets {shift->_accept_targets('1',@_)}sub accept_targets_as_text {shift->_accept_targets('force_resolve',@_)}sub _accept_targets {my($this,$type)=splice @_,0,2;for my$t (@_){next unless defined$t and length$t;$this->{'accept_targets'}{$t}=$type;DEBUG > 2 and print "Learning to accept \"$t\" as target of type $type\n"}return sort keys %{$this->{'accept_targets'}}if wantarray;return}sub unaccept_target {shift->unaccept_targets(@_)}sub unaccept_targets {my$this=shift;for my$t (@_){next unless defined$t and length$t;delete$this->{'accept_targets'}{$t};DEBUG > 2 and print "OK, won't accept \"$t\" as target.\n"}return sort keys %{$this->{'accept_targets'}}if wantarray;return}sub accept_code {shift->accept_codes(@_)}sub accept_codes {my$this=shift;for my$new_code (@_){next unless defined$new_code and length$new_code;if(ASCII){Carp::croak "\"$new_code\" isn't a valid element name" if$new_code =~ m/[\x00-\x2C\x2F\x39\x3B-\x40\x5B-\x5E\x60\x7B-\x7F]/ or $new_code =~ m/^[-\.0-9]/s or $new_code =~ m/:[-\.0-9]/s}$this->{'accept_codes'}{$new_code}=$new_code}return}sub unaccept_code {shift->unaccept_codes(@_)}sub unaccept_codes {my$this=shift;for my$new_code (@_){next unless defined$new_code and length$new_code;if(ASCII){Carp::croak "\"$new_code\" isn't a valid element name" if$new_code =~ m/[\x00-\x2C\x2F\x39\x3B-\x40\x5B-\x5E\x60\x7B-\x7F]/ or $new_code =~ m/^[-\.0-9]/s or $new_code =~ m/:[-\.0-9]/s}Carp::croak "But you must accept \"$new_code\" codes -- it's a builtin!" if grep$new_code eq $_,@Known_formatting_codes;delete$this->{'accept_codes'}{$new_code};DEBUG > 2 and print "OK, won't accept the code $new_code<...>.\n"}return}sub parse_string_document {my$self=shift;my@lines;for my$line_group (@_){next unless defined$line_group and length$line_group;pos($line_group)=0;while($line_group =~ m/([^\n\r]*)(\r?\n?)/g){$self->parse_lines($1)if length($1)or length($2)or pos($line_group)!=length($line_group)}}$self->parse_lines(undef);return$self}sub _init_fh_source {my($self,$source)=@_;return}sub parse_file {my($self,$source)=(@_);if(!defined$source){Carp::croak("Can't use empty-string as a source for parse_file")}elsif(ref(\$source)eq 'GLOB'){$self->{'source_filename'}='' .($source)}elsif(ref$source){$self->{'source_filename'}='' .($source)}elsif(!length$source){Carp::croak("Can't use empty-string as a source for parse_file")}else {{local*PODSOURCE;open(PODSOURCE,"<$source")|| Carp::croak("Can't open $source: $!");$self->{'source_filename'}=$source;$source=*PODSOURCE{IO}}$self->_init_fh_source($source)}$self->{'source_fh'}=$source;my($i,@lines);until($self->{'source_dead'}){splice@lines;for($i=MANY_LINES;$i--;){local $/=$NL;push@lines,scalar(<$source>);last unless defined$lines[-1]}my$at_eof=!$lines[-1];pop@lines if$at_eof;s/\r\n?/\n/g for@lines;@lines=split(/(?<=\n)/,join('',@lines));push@lines,undef if$at_eof;$self->parse_lines(@lines)}delete($self->{'source_fh'});return$self}sub parse_from_file {my($self,$source,$to)=@_;$self=$self->new unless ref($self);if(!defined$source){$source=*STDIN{IO}}elsif(ref(\$source)eq 'GLOB'){}elsif(ref($source)){}elsif(!length$source or $source eq '-' or $source =~ m/^<&(STDIN|0)$/i){$source=*STDIN{IO}}if(!defined$to){$self->output_fh(*STDOUT{IO})}elsif(ref(\$to)eq 'GLOB'){$self->output_fh($to)}elsif(ref($to)){$self->output_fh($to)}elsif(!length$to or $to eq '-' or $to =~ m/^>&?(?:STDOUT|1)$/i){$self->output_fh(*STDOUT{IO})}else {require Symbol;my$out_fh=Symbol::gensym();DEBUG and print "Write-opening to $to\n";open($out_fh,">$to")or Carp::croak "Can't write-open $to: $!";binmode($out_fh)if$self->can('write_with_binmode')and $self->write_with_binmode;$self->output_fh($out_fh)}return$self->parse_file($source)}sub whine {my$self=shift(@_);++$self->{'errors_seen'};if($self->{'no_whining'}){DEBUG > 9 and print "Discarding complaint (at line $_[0]) $_[1]\n because no_whining is on.\n";return}return$self->_complain_warn(@_)if$self->{'complain_stderr'};return$self->_complain_errata(@_)}sub scream {my$self=shift(@_);++$self->{'errors_seen'};return$self->_complain_warn(@_)if$self->{'complain_stderr'};return$self->_complain_errata(@_)}sub _complain_warn {my($self,$line,$complaint)=@_;return printf STDERR "%s around line %s: %s\n",$self->{'source_filename'}|| 'Pod input',$line,$complaint}sub _complain_errata {my($self,$line,$complaint)=@_;if($self->{'no_errata_section'}){DEBUG > 9 and print "Discarding erratum (at line $line) $complaint\n because no_errata_section is on.\n"}else {DEBUG > 9 and print "Queuing erratum (at line $line) $complaint\n";push @{$self->{'errata'}{$line}},$complaint}return 1}sub _get_initial_item_type {my($self,$para)=@_;return$para->[1]{'~type'}if$para->[1]{'~type'};return$para->[1]{'~type'}='text' if join("\n",@{$para}[2 .. $#$para])=~ m/^\s*(\d+)\.?\s*$/s and $1 ne '1';return$self->_get_item_type($para)}sub _get_item_type {my($self,$para)=@_;return$para->[1]{'~type'}if$para->[1]{'~type'};my$content=join "\n",@{$para}[2 .. $#$para];if($content =~ m/^\s*\*\s*$/s or $content =~ m/^\s*$/s){splice @$para,2;$para->[1]{'~orig_content'}=$content;return$para->[1]{'~type'}='bullet'}elsif($content =~ m/^\s*\*\s+(.+)/s){$para->[1]{'~orig_content'}=$content;$para->[1]{'~_freaky_para_hack'}=$1;DEBUG > 2 and print " Tolerating $$para[2] as =item *\\n\\n$1\n";splice @$para,2;return$para->[1]{'~type'}='bullet'}elsif($content =~ m/^\s*(\d+)\.?\s*$/s){$para->[1]{'~orig_content'}=$content;$para->[1]{'number'}=$1;splice @$para,2;return$para->[1]{'~type'}='number'}else {return$para->[1]{'~type'}='text'}}sub _make_treelet {my$self=shift;my$treelet;if(!@_){return ['']}if(ref $_[0]and ref $_[0][0]and $_[0][0][0]eq '~Top'){DEBUG and print "Applying precooked treelet hack to $_[0][0]\n";$treelet=$_[0][0];splice @$treelet,0,2;return$treelet}else {$treelet=$self->_treelet_from_formatting_codes(@_)}if($self->_remap_sequences($treelet)){$self->_treat_Zs($treelet);$self->_treat_Ls($treelet);$self->_treat_Es($treelet);$self->_treat_Ss($treelet);$self->_wrap_up($treelet)}else {DEBUG and print "Formatless treelet gets fast-tracked.\n"}splice @$treelet,0,2;return$treelet}sub _wrap_up {my($self,@stack)=@_;my$nixx=$self->{'nix_X_codes'};my$merge=$self->{'merge_text' };return unless$nixx or $merge;DEBUG > 2 and print "\nStarting _wrap_up traversal.\n",$merge ? (" Merge mode on\n"): (),$nixx ? (" Nix-X mode on\n"): (),;my($i,$treelet);while($treelet=shift@stack){DEBUG > 3 and print " Considering children of this $treelet->[0] node...\n";for($i=2;$i < @$treelet;++$i){DEBUG > 3 and print " Considering child at $i ",pretty($treelet->[$i]),"\n";if($nixx and ref$treelet->[$i]and $treelet->[$i][0]eq 'X'){DEBUG > 3 and print "   Nixing X node at $i\n";splice(@$treelet,$i,1);redo}elsif($merge and $i!=2 and !ref$treelet->[$i]and!ref$treelet->[$i - 1]){DEBUG > 3 and print "   Merging ",$i-1,":[$treelet->[$i-1]] and $i\:[$treelet->[$i]]\n";$treelet->[$i-1].= (splice(@$treelet,$i,1))[0];DEBUG > 4 and print "    Now: ",$i-1,":[$treelet->[$i-1]]\n";--$i;next}elsif(ref$treelet->[$i]){DEBUG > 4 and print "  Enqueuing ",pretty($treelet->[$i])," for traversal.\n";push@stack,$treelet->[$i];if($treelet->[$i][0]eq 'L'){my$thing;for my$attrname ('section','to'){if(defined($thing=$treelet->[$i][1]{$attrname})and ref$thing){unshift@stack,$thing;DEBUG > 4 and print "  +Enqueuing ",pretty($treelet->[$i][1]{$attrname})," as an attribute value to tweak.\n"}}}}}}DEBUG > 2 and print "End of _wrap_up traversal.\n\n";return}sub _remap_sequences {my($self,@stack)=@_;if(@stack==1 and @{$stack[0]}==3 and!ref$stack[0][2]){DEBUG and print "Skipping _remap_sequences: formatless treelet.\n";return 0}my$map=($self->{'accept_codes'}|| die "NO accept_codes in $self?!?");my$start_line=$stack[0][1]{'start_line'};DEBUG > 2 and printf "\nAbout to start _remap_sequences on treelet from line %s.\n",$start_line || '[?]' ;DEBUG > 3 and print " Map: ",join('; ',map "$_=" .(ref($map->{$_})? join(",",@{$map->{$_}}): $map->{$_}),sort keys %$map),("B~C~E~F~I~L~S~X~Z" eq join '~',sort keys %$map)? "  (all normal)\n" : "\n" ;my($is,$was,$i,$treelet);while($treelet=shift@stack){DEBUG > 3 and print " Considering children of this $treelet->[0] node...\n";for($i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];DEBUG > 4 and print "  Noting child $i : $treelet->[$i][0]<...>\n";$is=$treelet->[$i][0]=$map->{$was=$treelet->[$i][0]};if(DEBUG > 3){if(!defined$is){print "   Code $was<> is UNKNOWN!\n"}elsif($is eq $was){DEBUG > 4 and print "   Code $was<> stays the same.\n"}else {print "   Code $was<> maps to ",ref($is)? ("tags ",map("$_<",@$is),'...',map('>',@$is),"\n"): "tag $is<...>.\n"}}if(!defined$is){$self->whine($start_line,"Deleting unknown formatting code $was<>");$is=$treelet->[$i][0]='1'}if(ref$is){my@dynasty=@$is;DEBUG > 4 and print "    Renaming $was node to $dynasty[-1]\n";$treelet->[$i][0]=pop@dynasty;my$nugget;while(@dynasty){DEBUG > 4 and printf "    Grafting a new %s node between %s and %s\n",$dynasty[-1],$treelet->[0],$treelet->[$i][0],;splice @$treelet,$i,1,[pop(@dynasty),{},$treelet->[$i]]}}elsif($is eq '0'){splice(@$treelet,$i,1);--$i}elsif($is eq '1'){splice(@$treelet,$i,1 =>splice @{$treelet->[$i]},2);--$i}else {unshift@stack,$treelet->[$i]}}}DEBUG > 2 and print "End of _remap_sequences traversal.\n\n";if(@_==2 and @{$_[1]}==3 and!ref $_[1][2]){DEBUG and print "Noting that the treelet is now formatless.\n";return 0}return 1}sub _ponder_extend {my($self,$para)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG > 2 and print "Ogling extensor: =extend $content\n";if($content =~ m/^
        (\S+)         # 1 : new item
        \s+
        (\S+)         # 2 : fallback(s)
        (?:\s+(\S+))? # 3 : element name(s)
        \s*
        $
      /xs){my$new_letter=$1;my$fallbacks_one=$2;my$elements_one;$elements_one=defined($3)? $3 : $1;DEBUG > 2 and print "Extensor has good syntax.\n";unless($new_letter =~ m/^[A-Z]$/s or $new_letter){DEBUG > 2 and print " $new_letter isn't a valid thing to entend.\n";$self->whine($para->[1]{'start_line'},"You can extend only formatting codes A-Z, not like \"$new_letter\"");return}if(grep$new_letter eq $_,@Known_formatting_codes){DEBUG > 2 and print " $new_letter isn't a good thing to extend, because known.\n";$self->whine($para->[1]{'start_line'},"You can't extend an established code like \"$new_letter\"");return}unless($fallbacks_one =~ m/^[A-Z](,[A-Z])*$/s or $fallbacks_one eq '0' or $fallbacks_one eq '1'){$self->whine($para->[1]{'start_line'},"Format for second =extend parameter must be like" ." M or 1 or 0 or M,N or M,N,O but you have it like " .$fallbacks_one);return}unless($elements_one =~ m/^[^ ,]+(,[^ ,]+)*$/s){$self->whine($para->[1]{'start_line'},"Format for third =extend parameter: like foo or bar,Baz,qu:ux but not like " .$elements_one);return}my@fallbacks=split ',',$fallbacks_one,-1;my@elements=split ',',$elements_one,-1;for my$f (@fallbacks){next if exists$Known_formatting_codes{$f}or $f eq '0' or $f eq '1';DEBUG > 2 and print "  Can't fall back on unknown code $f\n";$self->whine($para->[1]{'start_line'},"Can't use unknown formatting code '$f' as a fallback for '$new_letter'");return}DEBUG > 3 and printf "Extensor: Fallbacks <%s> Elements <%s>.\n",@fallbacks,@elements;my$canonical_form;for my$e (@elements){if(exists$self->{'accept_codes'}{$e}){DEBUG > 1 and print " Mapping '$new_letter' to known extension '$e'\n";$canonical_form=$e;last}else {DEBUG > 1 and print " Can't map '$new_letter' to unknown extension '$e'\n"}}if(defined$canonical_form){$self->{'accept_codes'}{$new_letter}=$canonical_form;DEBUG > 2 and print "Extensor maps $new_letter => known element $canonical_form.\n"}else {$self->{'accept_codes'}{$new_letter}=(@fallbacks==1)? $fallbacks[0]: \@fallbacks;DEBUG > 2 and print "Extensor maps $new_letter => fallbacks @fallbacks.\n"}}else {DEBUG > 2 and print "Extensor has bad syntax.\n";$self->whine($para->[1]{'start_line'},"Unknown =extend syntax: $content")}return}sub _treat_Zs {my($self,@stack)=@_;my($i,$treelet);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for($i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];unless($treelet->[$i][0]eq 'Z'){unshift@stack,$treelet->[$i];next}DEBUG > 1 and print "Nixing Z node @{$treelet->[$i]}\n";unless(@{$treelet->[$i]}==2 or (@{$treelet->[$i]}==3 and $treelet->[$i][2]eq '')){$self->whine($start_line,"A non-empty Z<>")}splice(@$treelet,$i,1);--$i}}return}sub _treat_Ls {my($self,@stack)=@_;my($i,$treelet);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for(my$i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];unless($treelet->[$i][0]eq 'L'){unshift@stack,$treelet->[$i];next}my$ell=$treelet->[$i];DEBUG > 1 and print "Ogling L node $ell\n";if(@{$ell}==2 or (@{$ell}==3 and $ell->[2]eq '')){$self->whine($start_line,"An empty L<>");$treelet->[$i]='L<>';next}if((!ref$ell->[2]&& $ell->[2]=~ /\A\s/)||(!ref$ell->[-1]&& $ell->[-1]=~ /\s\z/)){$self->whine($start_line,"L<> starts or ends with whitespace")}if (my ($url_index,$text_part,$url_part)=sub {for (2..$#$ell){next if ref$ell->[$_];next unless$ell->[$_]=~ m/^(?:([^|]*)\|)?(\w+:[^:\s]\S*)$/s;return ($_,$1,$2)}return}->()){$ell->[1]{'type'}='url';my@text=@{$ell}[2..$url_index-1];push@text,$text_part if defined$text_part;my@url=@{$ell}[$url_index+1..$#$ell];unshift@url,$url_part;unless (@text){$ell->[1]{'content-implicit'}='yes';@text=@url}$ell->[1]{to}=Pod::Simple::LinkSection->new(@url==1 ? $url[0]: ['',{},@url ],);splice @$ell,2,$#$ell,@text;next}if(@{$ell}==3 and!ref$ell->[2]){my$it=$ell->[2];if($it =~ m{^[^/|]+[(][-a-zA-Z0-9]+[)]$}s){DEBUG > 1 and print "Catching \"$it\" as manpage link.\n";$ell->[1]{'type'}='man';$ell->[1]{'content-implicit'}='yes';$ell->[1]{'to' }=Pod::Simple::LinkSection->new($it);next}if($it =~ m/^[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+(\:\:[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+)*$/s){DEBUG > 1 and print "Catching \"$it\" as ho-hum L<Modulename> link.\n";$ell->[1]{'type'}='pod';$ell->[1]{'content-implicit'}='yes';$ell->[1]{'to' }=Pod::Simple::LinkSection->new($it);next}}DEBUG > 1 and print "Running a real parse on this non-trivial L\n";my$link_text;my@ell_content=@$ell;splice@ell_content,0,2;DEBUG > 3 and print " Ell content to start: ",pretty(@ell_content),"\n";DEBUG > 3 and print "  Peering at L content for a '|' ...\n";for(my$j=0;$j < @ell_content;++$j){next if ref$ell_content[$j];DEBUG > 3 and print "    Peering at L-content text bit \"$ell_content[$j]\" for a '|'.\n";if($ell_content[$j]=~ m/^([^\|]*)\|(.*)$/s){my@link_text=($1);$ell_content[$j]=$2;DEBUG > 3 and print "     FOUND a '|' in it.  Splitting into [$1] + [$2]\n";if ($link_text[0]=~ m{[|/]}){$self->whine($start_line,"alternative text '$link_text[0]' contains non-escaped | or /")}unshift@link_text,splice@ell_content,0,$j;@ell_content=grep ref($_)||length($_),@ell_content ;$link_text=[grep ref($_)||length($_),@link_text ];DEBUG > 3 and printf "  So link text is %s\n  and remaining ell content is %s\n",pretty($link_text),pretty(@ell_content);last}}my$section_name;DEBUG > 3 and print "  Peering at L-content for a '/' ...\n";for(my$j=0;$j < @ell_content;++$j){next if ref$ell_content[$j];DEBUG > 3 and print "    Peering at L-content text bit \"$ell_content[$j]\" for a '/'.\n";if($ell_content[$j]=~ m/^([^\/]*)\/(.*)$/s){my@section_name=($2);$ell_content[$j]=$1;DEBUG > 3 and print "     FOUND a '/' in it.","  Splitting to page [...$1] + section [$2...]\n";push@section_name,splice@ell_content,1+$j;@ell_content=grep ref($_)||length($_),@ell_content ;@section_name=grep ref($_)||length($_),@section_name ;if(@section_name and!ref($section_name[0])and!ref($section_name[-1])and $section_name[0]=~ m/^\"/s and $section_name[-1]=~ m/\"$/s and!(@section_name==1 and $section_name[0]eq '"')){$section_name[0]=~ s/^\"//s;$section_name[-1]=~ s/\"$//s;DEBUG > 3 and print "     Quotes removed: ",pretty(@section_name),"\n"}else {DEBUG > 3 and print "     No need to remove quotes in ",pretty(@section_name),"\n"}$section_name=\@section_name;last}}if(!$section_name and @ell_content and!ref($ell_content[0])and!ref($ell_content[-1])and $ell_content[0]=~ m/^\"/s and $ell_content[-1]=~ m/\"$/s and!(@ell_content==1 and $ell_content[0]eq '"')){$section_name=[splice@ell_content];$section_name->[0]=~ s/^\"//s;$section_name->[-1]=~ s/\"$//s}if(!$section_name and!$link_text and @ell_content and grep!ref($_)&& m/ /s,@ell_content){$section_name=[splice@ell_content]}unless($link_text){$ell->[1]{'content-implicit'}='yes';$link_text=[];push @$link_text,'"',@$section_name,'"' if$section_name;if(@ell_content){$link_text->[-1].= ' in ' if$section_name;push @$link_text,@ell_content}}if(@ell_content==1 and!ref($ell_content[0])and $ell_content[0]=~ m{^[^/]+[(][-a-zA-Z0-9]+[)]$}s){$ell->[1]{'type'}='man';DEBUG > 3 and print "Considering this ($ell_content[0]) a man link.\n"}else {$ell->[1]{'type'}='pod';DEBUG > 3 and print "Considering this a pod link (not man or url).\n"}if(defined$section_name){$ell->[1]{'section'}=Pod::Simple::LinkSection->new(['',{},@$section_name]);DEBUG > 3 and print "L-section content: ",pretty($ell->[1]{'section'}),"\n"}if(@ell_content){$ell->[1]{'to'}=Pod::Simple::LinkSection->new(['',{},@ell_content]);DEBUG > 3 and print "L-to content: ",pretty($ell->[1]{'to'}),"\n"}@$ell=(@$ell[0,1],defined($link_text)? splice(@$link_text): '');DEBUG > 2 and print "End of L-parsing for this node $treelet->[$i]\n";unshift@stack,$treelet->[$i]}}return}sub _treat_Es {my($self,@stack)=@_;my($i,$treelet,$content,$replacer,$charnum);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for(my$i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];if($treelet->[$i][0]eq 'L'){my$thing;for my$attrname ('section','to'){if(defined($thing=$treelet->[$i][1]{$attrname})and ref$thing){unshift@stack,$thing;DEBUG > 2 and print "  Enqueuing ",pretty($treelet->[$i][1]{$attrname})," as an attribute value to tweak.\n"}}unshift@stack,$treelet->[$i];next}elsif($treelet->[$i][0]ne 'E'){unshift@stack,$treelet->[$i];next}DEBUG > 1 and print "Ogling E node ",pretty($treelet->[$i]),"\n";if(@{$treelet->[$i]}==2 or (@{$treelet->[$i]}==3 and $treelet->[$i][2]eq '')){$self->whine($start_line,"An empty E<>");$treelet->[$i]='E<>';next}unless(@{$treelet->[$i]}==3 and!ref($content=$treelet->[$i][2])){$self->whine($start_line,"An E<...> surrounding strange content");$replacer=$treelet->[$i];splice(@$treelet,$i,1,'E<',splice(@$replacer,2),'>');next}DEBUG > 1 and print "Ogling E<$content>\n";$charnum=Pod::Escapes::e2charnum($content);DEBUG > 1 and print " Considering E<$content> with char ",defined($charnum)? $charnum : "undef",".\n";if(!defined($charnum)){DEBUG > 1 and print "I don't know how to deal with E<$content>.\n";$self->whine($start_line,"Unknown E content in E<$content>");$replacer="E<$content>"}elsif($charnum >= 255 and!UNICODE){$replacer=ASCII ? "\xA4" : "?";DEBUG > 1 and print "This Perl version can't handle ","E<$content> (chr $charnum), so replacing with $replacer\n"}else {$replacer=Pod::Escapes::e2char($content);DEBUG > 1 and print " Replacing E<$content> with $replacer\n"}splice(@$treelet,$i,1,$replacer)}}return}sub _treat_Ss {my($self,$treelet)=@_;_change_S_to_nbsp($treelet,0)if$self->{'nbsp_for_S'};return}sub _change_S_to_nbsp {my($treelet,$in_s)=@_;my$is_s=('S' eq $treelet->[0]);$in_s ||=$is_s;for(my$i=2;$i < @$treelet;++$i){if(ref$treelet->[$i]){if(_change_S_to_nbsp($treelet->[$i],$in_s)){my$to_pull_up=$treelet->[$i];splice @$to_pull_up,0,2;splice @$treelet,$i,1,@$to_pull_up;$i += @$to_pull_up - 1}}else {$treelet->[$i]=~ s/\s/\xA0/g if ASCII and $in_s}}return$is_s}sub _accessorize {no strict 'refs';for my$attrname (@_){next if$attrname =~ m/::/;*{caller().'::' .$attrname}=sub {use strict;$Carp::CarpLevel=1,Carp::croak("Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)")unless (@_==1 or @_==2)and ref $_[0];(@_==1)? $_[0]->{$attrname}: ($_[0]->{$attrname}=$_[1])}}return}sub filter {my($class,$source)=@_;my$new=$class->new;$new->output_fh(*STDOUT{IO});if(ref($source || '')eq 'SCALAR'){$new->parse_string_document($$source)}elsif(ref($source)){$new->parse_file($source)}else {$new->parse_file($source)}return$new}sub _out {my$class=shift(@_);my$mutor=shift(@_)if @_ and ref($_[0]|| '')eq 'CODE';DEBUG and print "\n\n",'#' x 76,"\nAbout to parse source: {{\n$_[0]\n}}\n\n";my$parser=ref$class && $class->isa(__PACKAGE__)? $class : $class->new;$parser->hide_line_numbers(1);my$out='';$parser->output_string(\$out);DEBUG and print " _out to ",\$out,"\n";$mutor->($parser)if$mutor;$parser->parse_string_document($_[0]);return$out}sub _duo {my$class=shift(@_);Carp::croak "But $class->_duo is useful only in list context!" unless wantarray;my$mutor=shift(@_)if @_ and ref($_[0]|| '')eq 'CODE';Carp::croak "But $class->_duo takes two parameters, not: @_" unless @_==2;my(@out);while(@_){my$parser=$class->new;push@out,'';$parser->output_string(\($out[-1]));DEBUG and print " _duo out to ",$parser->output_string()," = $parser->{'output_string'}\n";$parser->hide_line_numbers(1);$mutor->($parser)if$mutor;$parser->parse_string_document(shift(@_))}return@out}1;
POD_SIMPLE

$fatpacked{"Pod/Simple/BlackBox.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_BLACKBOX';
  package Pod::Simple::BlackBox;use integer;use strict;use Carp ();use vars qw($VERSION);$VERSION='3.28';BEGIN {require Pod::Simple;*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub parse_line {shift->parse_lines(@_)}sub parse_lines {my$self=shift;my$code_handler=$self->{'code_handler'};my$cut_handler=$self->{'cut_handler'};my$wl_handler=$self->{'whiteline_handler'};$self->{'line_count'}||=0;my$scratch;DEBUG > 4 and print "# Parsing starting at line ",$self->{'line_count'},".\n";DEBUG > 5 and print "#  About to parse lines: ",join(' ',map defined($_)? "[$_]" : "EOF",@_),"\n";my$paras=($self->{'paras'}||=[]);$self->{'pod_para_count'}||=0;my$line;for my$source_line (@_){if($self->{'source_dead'}){DEBUG > 4 and print "# Source is dead.\n";last}unless(defined$source_line){DEBUG > 4 and print "# Undef-line seen.\n";push @$paras,['~end',{'start_line'=>$self->{'line_count'}}];push @$paras,$paras->[-1],$paras->[-1];$self->{'source_dead'}=1;$self->_ponder_paragraph_buffer;next}if($self->{'line_count'}++){($line=$source_line)=~ tr/\n\r//d}else {DEBUG > 2 and print "First line: [$source_line]\n";if(($line=$source_line)=~ s/^\xEF\xBB\xBF//s){DEBUG and print "UTF-8 BOM seen.  Faking a '=encoding utf8'.\n";$self->_handle_encoding_line("=encoding utf8");delete$self->{'_processed_encoding'};$line =~ tr/\n\r//d}elsif($line =~ s/^\xFE\xFF//s){DEBUG and print "Big-endian UTF-16 BOM seen.  Aborting parsing.\n";$self->scream($self->{'line_count'},"UTF16-BE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet.");splice @_;push @_,undef;next}elsif($line =~ s/^\xFF\xFE//s){DEBUG and print "Little-endian UTF-16 BOM seen.  Aborting parsing.\n";$self->scream($self->{'line_count'},"UTF16-LE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet.");splice @_;push @_,undef;next}else {DEBUG > 2 and print "First line is BOM-less.\n";($line=$source_line)=~ tr/\n\r//d}}if(!$self->{'parse_characters'}&&!$self->{'encoding'}&& ($self->{'in_pod'}|| $line =~ /^=/s)&& $line =~ /[^\x00-\x7f]/){my$encoding=$line =~ /^[\x00-\x7f]*[\xC0-\xFD][\x80-\xBF]/ ? 'UTF-8' : 'ISO8859-1';$self->_handle_encoding_line("=encoding $encoding");$self->{'_transcoder'}&& $self->{'_transcoder'}->($line);my ($word)=$line =~ /(\S*[^\x00-\x7f]\S*)/;$self->whine($self->{'line_count'},"Non-ASCII character seen before =encoding in '$word'. Assuming $encoding")}DEBUG > 5 and print "# Parsing line: [$line]\n";if(!$self->{'in_pod'}){if($line =~ m/^=([a-zA-Z]+)/s){if($1 eq 'cut'){$self->scream($self->{'line_count'},"=cut found outside a pod block.  Skipping to next block.");next}else {$self->{'in_pod'}=$self->{'start_of_pod_block'}=$self->{'last_was_blank'}=1}}else {DEBUG > 5 and print "# It's a code-line.\n";$code_handler->(map $_,$line,$self->{'line_count'},$self)if$code_handler;if($line =~ m/^#\s*line\s+(\d+)\s*(?:\s"([^"]+)")?\s*$/){DEBUG > 1 and print "# Setting nextline to $1\n";$self->{'line_count'}=$1 - 1}next}}$self->{'_transcoder'}&& $self->{'_transcoder'}->($line);if($line =~ m/^=encoding\s+\S+\s*$/s){next if$self->parse_characters;$line=$self->_handle_encoding_line($line)}if($line =~ m/^=cut/s){DEBUG > 1 and print "Noting =cut at line ${$self}{'line_count'}\n";$self->{'in_pod'}=0;$self->_ponder_paragraph_buffer();$cut_handler->(map $_,$line,$self->{'line_count'},$self)if$cut_handler}elsif($line =~ m/^(\s*)$/s){if (defined $1 and $1 =~ /[^\S\r\n]/){$wl_handler->(map $_,$line,$self->{'line_count'},$self)if$wl_handler}if(!$self->{'start_of_pod_block'}and @$paras and $paras->[-1][0]eq '~Verbatim'){DEBUG > 1 and print "Saving blank line at line ${$self}{'line_count'}\n";push @{$paras->[-1]},$line}if(!$self->{'start_of_pod_block'}and!$self->{'last_was_blank'}){DEBUG > 1 and print "Noting para ends with blank line at ${$self}{'line_count'}\n"}$self->{'last_was_blank'}=1}elsif($self->{'last_was_blank'}){if($line =~ m/^(=[a-zA-Z][a-zA-Z0-9]*)(?:\s+|$)(.*)/s){my$new=[$1,{'start_line'=>$self->{'line_count'}},$2];++$self->{'pod_para_count'};$self->_ponder_paragraph_buffer();push @$paras,$new;DEBUG > 1 and print "Starting new ${$paras}[-1][0] para at line ${$self}{'line_count'}\n"}elsif($line =~ m/^\s/s){if(!$self->{'start_of_pod_block'}and @$paras and $paras->[-1][0]eq '~Verbatim'){DEBUG > 1 and print "Resuming verbatim para at line ${$self}{'line_count'}\n";push @{$paras->[-1]},$line}else {++$self->{'pod_para_count'};$self->_ponder_paragraph_buffer();DEBUG > 1 and print "Starting verbatim para at line ${$self}{'line_count'}\n";push @$paras,['~Verbatim',{'start_line'=>$self->{'line_count'}},$line]}}else {++$self->{'pod_para_count'};$self->_ponder_paragraph_buffer();push @$paras,['~Para',{'start_line'=>$self->{'line_count'}},$line];DEBUG > 1 and print "Starting plain para at line ${$self}{'line_count'}\n"}$self->{'last_was_blank'}=$self->{'start_of_pod_block'}=0}else {if(@$paras){DEBUG > 2 and print "Line ${$self}{'line_count'} continues current paragraph\n";push @{$paras->[-1]},$line}else {die "Continuing a paragraph but \@\$paras is empty?"}$self->{'last_was_blank'}=$self->{'start_of_pod_block'}=0}}DEBUG > 1 and print(pretty(@$paras),"\n");return$self}sub _handle_encoding_line {my($self,$line)=@_;return if$self->parse_characters;return$line unless$line =~ m/^=encoding\s+(\S+)\s*$/s;DEBUG > 1 and print "Found an encoding line \"=encoding $1\"\n";my$e=$1;my$orig=$e;push @{$self->{'encoding_command_reqs'}},"=encoding $orig";my$enc_error;require Pod::Simple::Transcode;if($self->{'encoding'}){my$norm_current=$self->{'encoding'};my$norm_e=$e;for my$that ($norm_current,$norm_e){$that=lc($that);$that =~ s/[-_]//g}if($norm_current eq $norm_e){DEBUG > 1 and print "The '=encoding $orig' line is ","redundant.  ($norm_current eq $norm_e).  Ignoring.\n";$enc_error=''}else {$enc_error="Encoding is already set to " .$self->{'encoding'};DEBUG > 1 and print$enc_error}}elsif (do {DEBUG > 1 and print " Setting encoding to $e\n";$self->{'encoding'}=$e;1}and $e eq 'HACKRAW'){DEBUG and print " Putting in HACKRAW (no-op) encoding mode.\n"}elsif(Pod::Simple::Transcode::->encoding_is_available($e)){die($enc_error="WHAT? _transcoder is already set?!")if$self->{'_transcoder'};require Pod::Simple::Transcode;$self->{'_transcoder'}=Pod::Simple::Transcode::->make_transcoder($e);eval {my@x=('',"abc","123");$self->{'_transcoder'}->(@x)};$@ && die($enc_error="Really unexpected error setting up encoding $e: $@\nAborting");$self->{'detected_encoding'}=$e}else {my@supported=Pod::Simple::Transcode::->all_encodings;DEBUG and print " Encoding [$e] is unsupported.","\nSupporteds: @supported\n";my$suggestion='';my$norm=lc($e);$norm =~ tr[-_][]d;my$n;for my$enc (@supported){$n=lc($enc);$n =~ tr[-_][]d;next unless$n eq $norm;$suggestion="  (Maybe \"$e\" should be \"$enc\"?)";last}my$encmodver=Pod::Simple::Transcode::->encmodver;$enc_error=join ''=>"This document probably does not appear as it should, because its ","\"=encoding $e\" line calls for an unsupported encoding.",$suggestion,"  [$encmodver\'s supported encodings are: @supported]" ;$self->scream($self->{'line_count'},$enc_error)}push @{$self->{'encoding_command_statuses'}},$enc_error;if (defined($self->{'_processed_encoding'})){die "Nested processed encoding."}$self->{'_processed_encoding'}=$orig;return$line}sub _handle_encoding_second_level {my($self,$para)=@_;my@x=@$para;my$content=join ' ',splice@x,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG > 2 and print "Ogling encoding directive: =encoding $content\n";if (defined($self->{'_processed_encoding'})){delete$self->{'_processed_encoding'};if(!$self->{'encoding_command_statuses'}){DEBUG > 2 and print " CRAZY ERROR: It wasn't really handled?!\n"}elsif($self->{'encoding_command_statuses'}[-1]){$self->whine($para->[1]{'start_line'},sprintf "Couldn't do %s: %s",$self->{'encoding_command_reqs' }[-1],$self->{'encoding_command_statuses'}[-1],)}else {DEBUG > 2 and print " (Yup, it was successfully handled already.)\n"}}else {$self->whine($para->[1]{'start_line'},"Invalid =encoding syntax: $content")}return}{my$m=-321;sub _gen_errata {my$self=$_[0];return()unless$self->{'errata'}and keys %{$self->{'errata'}};my@out;for my$line (sort {$a <=> $b}keys %{$self->{'errata'}}){push@out,['=item',{'start_line'=>$m},"Around line $line:"],map(['~Para',{'start_line'=>$m,'~cooked'=>1},$_ ],@{$self->{'errata'}{$line}})}unshift@out,['=head1',{'start_line'=>$m,'errata'=>1},'POD ERRORS'],['~Para',{'start_line'=>$m,'~cooked'=>1,'errata'=>1},"Hey! ",['B',{},'The above document had some coding errors, which are explained below:' ]],['=over',{'start_line'=>$m,'errata'=>1},''],;push@out,['=back',{'start_line'=>$m,'errata'=>1},''],;DEBUG and print "\n<<\n",pretty(\@out),"\n>>\n\n";return@out}}sub _ponder_paragraph_buffer {my$self=$_[0];my$paras;return unless @{$paras=$self->{'paras'}};my$curr_open=($self->{'curr_open'}||=[]);my$scratch;DEBUG > 10 and print "# Paragraph buffer: <<",pretty($paras),">>\n";unless($self->{'doc_has_started'}){$self->{'doc_has_started'}=1;my$starting_contentless;$starting_contentless=(!@$curr_open and @$paras and!grep $_->[0]ne '~end',@$paras);DEBUG and print "# Starting ",$starting_contentless ? 'contentless' : 'contentful'," document\n" ;$self->_handle_element_start(($scratch='Document'),{'start_line'=>$paras->[0][1]{'start_line'},$starting_contentless ? ('contentless'=>1): (),},)}my($para,$para_type);while(@$paras){last if @$paras==1 and ($paras->[0][0]eq '=over' or $paras->[0][0]eq '~Verbatim' or $paras->[0][0]eq '=item');$para=shift @$paras;$para_type=$para->[0];DEBUG > 1 and print "Pondering a $para_type paragraph, given the stack: (",$self->_dump_curr_open(),")\n";if($para_type eq '=for'){next if$self->_ponder_for($para,$curr_open,$paras)}elsif($para_type eq '=begin'){next if$self->_ponder_begin($para,$curr_open,$paras)}elsif($para_type eq '=end'){next if$self->_ponder_end($para,$curr_open,$paras)}elsif($para_type eq '~end'){next if$self->_ponder_doc_end($para,$curr_open,$paras)}if(grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print "Skipping $para_type paragraph because in ignore mode.\n";next}if($para_type eq '=pod'){$self->_ponder_pod($para,$curr_open,$paras)}elsif($para_type eq '=over'){next if$self->_ponder_over($para,$curr_open,$paras)}elsif($para_type eq '=back'){next if$self->_ponder_back($para,$curr_open,$paras)}else {DEBUG > 1 and print "Pondering non-magical $para_type\n";my$i;if($para_type =~ m/^=head\d$/s and!$self->{'accept_heads_anywhere'}and @$curr_open and $curr_open->[-1][0]eq '=over'){DEBUG > 2 and print "'=$para_type' inside an '=over'!\n";$self->whine($para->[1]{'start_line'},"You forgot a '=back' before '$para_type'");unshift @$paras,['=back',{},''],$para;next}if($para_type eq '=item'){my$over;unless(@$curr_open and $over=(grep {$_->[0]eq '=over'}@$curr_open)[-1]){$self->whine($para->[1]{'start_line'},"'=item' outside of any '=over'");unshift @$paras,['=over',{'start_line'=>$para->[1]{'start_line'}},''],$para ;next}my$over_type=$over->[1]{'~type'};if(!$over_type){die "Typeless over in stack, starting at line " .$over->[1]{'start_line'}}elsif($over_type eq 'block'){unless($curr_open->[-1][1]{'~bitched_about'}){$curr_open->[-1][1]{'~bitched_about'}=1;$self->whine($curr_open->[-1][1]{'start_line'},"You can't have =items (as at line " .$para->[1]{'start_line'}.") unless the first thing after the =over is an =item")}$para->[0]='~Para';unshift @$paras,$para;next}elsif($over_type eq 'text'){my$item_type=$self->_get_item_type($para);DEBUG and print " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'text'){}elsif($item_type eq 'number' or $item_type eq 'bullet'){$self->whine($para->[1]{'start_line'},"Expected text after =item, not a $item_type");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}else {die "Unhandled item type $item_type"}}elsif($over_type eq 'number'){my$item_type=$self->_get_item_type($para);DEBUG and print " Item is of type ",$para->[0]," under $over_type\n";my$expected_value=++ $curr_open->[-1][1]{'~counter'};if($item_type eq 'bullet'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'");push @$para,$para->[1]{'~orig_content'}}elsif($item_type eq 'text'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'")}elsif($item_type ne 'number'){die "Unknown item type $item_type"}elsif($expected_value==$para->[1]{'number'}){DEBUG > 1 and print " Numeric item has the expected value of $expected_value\n"}else {DEBUG > 1 and print " Numeric item has ",$para->[1]{'number'}," instead of the expected value of $expected_value\n";$self->whine($para->[1]{'start_line'},"You have '=item " .$para->[1]{'number'}."' instead of the expected '=item $expected_value'");$para->[1]{'number'}=$expected_value}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}elsif($over_type eq 'bullet'){my$item_type=$self->_get_item_type($para);DEBUG and print " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'bullet'){if($para->[1]{'~_freaky_para_hack'}){DEBUG and print "Accomodating '=item * Foo' tolerance hack.\n";push @$para,delete$para->[1]{'~_freaky_para_hack'}}}elsif($item_type eq 'number'){$self->whine($para->[1]{'start_line'},"Expected '=item *'");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}elsif($item_type eq 'text'){$self->whine($para->[1]{'start_line'},"Expected '=item *'")}else {die "Unhandled item type $item_type"}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}else {die "Unhandled =over type \"$over_type\"?"}$para_type='Plain';$para->[0].= '-' .$over_type}elsif($para_type eq '=extend'){$self->_ponder_extend($para);next}elsif($para_type eq '=encoding'){$self->_handle_encoding_second_level($para);next unless$self->keep_encoding_directive;$para_type='Plain'}elsif($para_type eq '~Verbatim'){$para->[0]='Verbatim';$para_type='?Verbatim'}elsif($para_type eq '~Para'){$para->[0]='Para';$para_type='?Plain'}elsif($para_type eq 'Data'){$para->[0]='Data';$para_type='?Data'}elsif($para_type =~ s/^=//s and defined($para_type=$self->{'accept_directives'}{$para_type})){DEBUG > 1 and print " Pondering known directive ${$para}[0] as $para_type\n"}else {DEBUG > 1 and printf "Unhandled directive %s (Handled: %s)\n",$para->[0],join(' ',sort keys %{$self->{'accept_directives'}});$self->whine($para->[1]{'start_line'},"Unknown directive: $para->[0]");next}if($para_type =~ s/^\?//s){if(!@$curr_open){DEBUG and print "Treating $para_type paragraph as such because stack is empty.\n"}else {my@fors=grep $_->[0]eq '=for',@$curr_open;DEBUG > 1 and print "Containing fors: ",join(',',map $_->[1]{'target'},@fors),"\n";if(!@fors){DEBUG and print "Treating $para_type paragraph as such because stack has no =for's\n"}elsif($fors[-1][1]{'~resolve'}){if($para_type eq 'Data'){DEBUG and print "Treating Data paragraph as Plain/Verbatim because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";$para->[0]='Para';$para_type='Plain'}else {DEBUG and print "Treating $para_type paragraph as such because the containing =for ($fors[-1][1]{'target'}) is a resolver\n"}}else {DEBUG and print "Treating $para_type paragraph as Data because the containing =for ($fors[-1][1]{'target'}) is a non-resolver\n";$para->[0]=$para_type='Data'}}}if($para_type eq 'Plain'){$self->_ponder_Plain($para)}elsif($para_type eq 'Verbatim'){$self->_ponder_Verbatim($para)}elsif($para_type eq 'Data'){$self->_ponder_Data($para)}else {die "\$para type is $para_type -- how did that happen?"}$para->[0]=~ s/^[~=]//s;DEBUG and print "\n",pretty($para),"\n";$self->{'content_seen'}||=1;$self->_traverse_treelet_bit(@$para)}}return}sub _ponder_for {my ($self,$para,$curr_open,$paras)=@_;my$target;if(grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print "Ignoring ignorable =for\n";return 1}for(my$i=2;$i < @$para;++$i){if($para->[$i]=~ s/^\s*(\S+)\s*//s){$target=$1;last}}unless(defined$target){$self->whine($para->[1]{'start_line'},"=for without a target?");return 1}DEBUG > 1 and print "Faking out a =for $target as a =begin $target / =end $target\n";$para->[0]='Data';unshift @$paras,['=begin',{'start_line'=>$para->[1]{'start_line'},'~really'=>'=for'},$target,],$para,['=end',{'start_line'=>$para->[1]{'start_line'},'~really'=>'=for'},$target,],;return 1}sub _ponder_begin {my ($self,$para,$curr_open,$paras)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;unless(length($content)){$self->whine($para->[1]{'start_line'},"=begin without a target?");DEBUG and print "Ignoring targetless =begin\n";return 1}my ($target,$title)=$content =~ m/^(\S+)\s*(.*)$/;$para->[1]{'title'}=$title if ($title);$para->[1]{'target'}=$target;$content=$target;$content =~ s/^:!/!:/s;my$neg;$neg=1 if$content =~ s/^!//s;my$to_resolve;$to_resolve=1 if$content =~ s/^://s;my$dont_ignore;for my$target_name (split(',',$content,-1),$neg ? (): '*'){DEBUG > 2 and print " Considering whether =begin $content matches $target_name\n";next unless$self->{'accept_targets'}{$target_name};DEBUG > 2 and print "  It DOES match the acceptable target $target_name!\n";$to_resolve=1 if$self->{'accept_targets'}{$target_name}eq 'force_resolve';$dont_ignore=1;$para->[1]{'target_matching'}=$target_name;last}if($neg){if($dont_ignore){$dont_ignore='';delete$para->[1]{'target_matching'};DEBUG > 2 and print " But the leading ! means that this is a NON-match!\n"}else {$dont_ignore=1;$para->[1]{'target_matching'}='!';DEBUG > 2 and print " But the leading ! means that this IS a match!\n"}}$para->[0]='=for';$para->[1]{'~really'}||='=begin';$para->[1]{'~ignore'}=(!$dont_ignore)|| 0;$para->[1]{'~resolve'}=$to_resolve || 0;DEBUG > 1 and print " Making note to ",$dont_ignore ? 'not ' : '',"ignore contents of this region\n";DEBUG > 1 and $dont_ignore and print " Making note to treat contents as ",($to_resolve ? 'verbatim/plain' : 'data')," paragraphs\n";DEBUG > 1 and print " (Stack now: ",$self->_dump_curr_open(),")\n";push @$curr_open,$para;if(!$dont_ignore or scalar grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print "Ignoring ignorable =begin\n"}else {$self->{'content_seen'}||=1;$self->_handle_element_start((my$scratch='for'),$para->[1])}return 1}sub _ponder_end {my ($self,$para,$curr_open,$paras)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG and print "Ogling '=end $content' directive\n";unless(length($content)){$self->whine($para->[1]{'start_line'},"'=end' without a target?" .((@$curr_open and $curr_open->[-1][0]eq '=for')? (" (Should be \"=end " .$curr_open->[-1][1]{'target'}.'")'): ''));DEBUG and print "Ignoring targetless =end\n";return 1}unless($content =~ m/^\S+$/){$self->whine($para->[1]{'start_line'},"'=end $content' is invalid.  (Stack: " .$self->_dump_curr_open().')');DEBUG and print "Ignoring mistargetted =end $content\n";return 1}unless(@$curr_open and $curr_open->[-1][0]eq '=for'){$self->whine($para->[1]{'start_line'},"=end $content without matching =begin.  (Stack: " .$self->_dump_curr_open().')');DEBUG and print "Ignoring mistargetted =end $content\n";return 1}unless($content eq $curr_open->[-1][1]{'target'}){$self->whine($para->[1]{'start_line'},"=end $content doesn't match =begin " .$curr_open->[-1][1]{'target'}.".  (Stack: " .$self->_dump_curr_open().')');DEBUG and print "Ignoring mistargetted =end $content at line $para->[1]{'start_line'}\n";return 1}if(grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print "Not firing any event for this =end $content because in an ignored region\n"}else {$curr_open->[-1][1]{'start_line'}=$para->[1]{'start_line'};$self->{'content_seen'}||=1;$self->_handle_element_end(my$scratch='for',$para->[1])}DEBUG > 1 and print "Popping $curr_open->[-1][0] $curr_open->[-1][1]{'target'} because of =end $content\n";pop @$curr_open;return 1}sub _ponder_doc_end {my ($self,$para,$curr_open,$paras)=@_;if(@$curr_open){DEBUG and print "Stack is nonempty at end-document: (",$self->_dump_curr_open(),")\n";DEBUG > 9 and print "Stack: ",pretty($curr_open),"\n";unshift @$paras,$self->_closers_for_all_curr_open;@$paras=grep $_->[0]ne '~end',@$paras;push @$paras,$para,$para;return 1}else {DEBUG and print "Okay, stack is empty now.\n"}unless($self->{'~tried_gen_errata'}){$self->{'~tried_gen_errata'}=1;my@extras=$self->_gen_errata();if(@extras){unshift @$paras,@extras;DEBUG and print "Generated errata... relooping...\n";return 1}}splice @$paras;DEBUG and print "Throwing end-document event.\n";$self->_handle_element_end(my$scratch='Document');return 1}sub _ponder_pod {my ($self,$para,$curr_open,$paras)=@_;$self->whine($para->[1]{'start_line'},"=pod directives shouldn't be over one line long!  Ignoring all " .(@$para - 2)." lines of content")if @$para > 3;if (my$pod_handler=$self->{'pod_handler'}){my ($line_num,$line)=map $_,$para->[1]{'start_line'},$para->[2];$line=$line eq '' ? "=pod" : "=pod $line";$pod_handler->($line,$line_num,$self)}return}sub _ponder_over {my ($self,$para,$curr_open,$paras)=@_;return 1 unless @$paras;my$list_type;if($paras->[0][0]eq '=item'){$list_type=$self->_get_initial_item_type($paras->[0])}elsif($paras->[0][0]eq '=back'){if ($self->{'parse_empty_lists'}){$list_type='empty'}else {shift @$paras;return 1}}elsif($paras->[0][0]eq '~end'){$self->whine($para->[1]{'start_line'},"=over is the last thing in the document?!");return 1}else {$list_type='block'}$para->[1]{'~type'}=$list_type;push @$curr_open,$para;my$content=join ' ',splice @$para,2;my$overness;if($content =~ m/^\s*$/s){$para->[1]{'indent'}=4}elsif($content =~ m/^\s*((?:\d*\.)?\d+)\s*$/s){no integer;$para->[1]{'indent'}=$1;if($1==0){$self->whine($para->[1]{'start_line'},"Can't have a 0 in =over $content");$para->[1]{'indent'}=4}}else {$self->whine($para->[1]{'start_line'},"=over should be: '=over' or '=over positive_number'");$para->[1]{'indent'}=4}DEBUG > 1 and print "=over found of type $list_type\n";$self->{'content_seen'}||=1;$self->_handle_element_start((my$scratch='over-' .$list_type),$para->[1]);return}sub _ponder_back {my ($self,$para,$curr_open,$paras)=@_;my$content=join ' ',splice @$para,2;if($content =~ m/\S/){$self->whine($para->[1]{'start_line'},"=back doesn't take any parameters, but you said =back $content")}if(@$curr_open and $curr_open->[-1][0]eq '=over'){DEBUG > 1 and print "=back happily closes matching =over\n";$self->{'content_seen'}||=1;$self->_handle_element_end(my$scratch='over-' .((pop @$curr_open)->[1]{'~type'}),$para->[1])}else {DEBUG > 1 and print "=back found without a matching =over.  Stack: (",join(', ',map $_->[0],@$curr_open),").\n";$self->whine($para->[1]{'start_line'},'=back without =over');return 1}}sub _ponder_item {my ($self,$para,$curr_open,$paras)=@_;my$over;unless(@$curr_open and $over=(grep {$_->[0]eq '=over'}@$curr_open)[-1]){$self->whine($para->[1]{'start_line'},"'=item' outside of any '=over'");unshift @$paras,['=over',{'start_line'=>$para->[1]{'start_line'}},''],$para ;return 1}my$over_type=$over->[1]{'~type'};if(!$over_type){die "Typeless over in stack, starting at line " .$over->[1]{'start_line'}}elsif($over_type eq 'block'){unless($curr_open->[-1][1]{'~bitched_about'}){$curr_open->[-1][1]{'~bitched_about'}=1;$self->whine($curr_open->[-1][1]{'start_line'},"You can't have =items (as at line " .$para->[1]{'start_line'}.") unless the first thing after the =over is an =item")}$para->[0]='~Para';unshift @$paras,$para;return 1}elsif($over_type eq 'text'){my$item_type=$self->_get_item_type($para);DEBUG and print " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'text'){}elsif($item_type eq 'number' or $item_type eq 'bullet'){$self->whine($para->[1]{'start_line'},"Expected text after =item, not a $item_type");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}else {die "Unhandled item type $item_type"}}elsif($over_type eq 'number'){my$item_type=$self->_get_item_type($para);DEBUG and print " Item is of type ",$para->[0]," under $over_type\n";my$expected_value=++ $curr_open->[-1][1]{'~counter'};if($item_type eq 'bullet'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'");push @$para,$para->[1]{'~orig_content'}}elsif($item_type eq 'text'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'")}elsif($item_type ne 'number'){die "Unknown item type $item_type"}elsif($expected_value==$para->[1]{'number'}){DEBUG > 1 and print " Numeric item has the expected value of $expected_value\n"}else {DEBUG > 1 and print " Numeric item has ",$para->[1]{'number'}," instead of the expected value of $expected_value\n";$self->whine($para->[1]{'start_line'},"You have '=item " .$para->[1]{'number'}."' instead of the expected '=item $expected_value'");$para->[1]{'number'}=$expected_value}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}elsif($over_type eq 'bullet'){my$item_type=$self->_get_item_type($para);DEBUG and print " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'bullet'){if($para->[1]{'~_freaky_para_hack'}){DEBUG and print "Accomodating '=item * Foo' tolerance hack.\n";push @$para,delete$para->[1]{'~_freaky_para_hack'}}}elsif($item_type eq 'number'){$self->whine($para->[1]{'start_line'},"Expected '=item *'");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}elsif($item_type eq 'text'){$self->whine($para->[1]{'start_line'},"Expected '=item *'")}else {die "Unhandled item type $item_type"}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}else {die "Unhandled =over type \"$over_type\"?"}$para->[0].= '-' .$over_type;return}sub _ponder_Plain {my ($self,$para)=@_;DEBUG and print " giving plain treatment...\n";unless(@$para==2 or (@$para==3 and $para->[2]eq '')or $para->[1]{'~cooked'}){push @$para,@{$self->_make_treelet(join("\n",splice(@$para,2)),$para->[1]{'start_line'})}}return}sub _ponder_Verbatim {my ($self,$para)=@_;DEBUG and print " giving verbatim treatment...\n";$para->[1]{'xml:space'}='preserve';my$indent=$self->strip_verbatim_indent;if ($indent && ref$indent eq 'CODE'){my@shifted=(shift @{$para},shift @{$para});$indent=$indent->($para);unshift @{$para},@shifted}for(my$i=2;$i < @$para;$i++){for my$line ($para->[$i]){$line =~ s/^\Q$indent// if$indent &&!($self->{accept_codes}&& $self->{accept_codes}{VerbatimFormatted});while($line =~ s/^([^\t]*)(\t+)/$1.(" " x ((length($2)<<3)-(length($1)&7)))/e){}}}if($self->{'accept_codes'}and $self->{'accept_codes'}{'VerbatimFormatted'}){while(@$para > 3 and $para->[-1]!~ m/\S/){pop @$para}$self->_verbatim_format($para)}elsif ($self->{'codes_in_verbatim'}){push @$para,@{$self->_make_treelet(join("\n",splice(@$para,2)),$para->[1]{'start_line'},$para->[1]{'xml:space'})};$para->[-1]=~ s/\n+$//s}else {push @$para,join "\n",splice(@$para,2)if @$para > 3;$para->[-1]=~ s/\n+$//s}return}sub _ponder_Data {my ($self,$para)=@_;DEBUG and print " giving data treatment...\n";$para->[1]{'xml:space'}='preserve';push @$para,join "\n",splice(@$para,2)if @$para > 3;return}sub _traverse_treelet_bit {my($self,$name)=splice @_,0,2;my$scratch;$self->_handle_element_start(($scratch=$name),shift @_);while (@_){my$x=shift;if (ref($x)){&_traverse_treelet_bit($self,@$x)}else {$x .= shift while @_ &&!ref($_[0]);$self->_handle_text($x)}}$self->_handle_element_end($scratch=$name);return}sub _closers_for_all_curr_open {my$self=$_[0];my@closers;for my$still_open (@{$self->{'curr_open'}|| return}){my@copy=@$still_open;$copy[1]={%{$copy[1]}};if($copy[0]eq '=for'){$copy[0]='=end'}elsif($copy[0]eq '=over'){$self->whine($still_open->[1]{start_line},"=over without closing =back");$copy[0]='=back'}else {die "I don't know how to auto-close an open $copy[0] region"}unless(@copy > 2){push@copy,$copy[1]{'target'};$copy[-1]='' unless defined$copy[-1]}$copy[1]{'fake-closer'}=1;DEBUG and print "Queuing up fake-o event: ",pretty(\@copy),"\n";unshift@closers,\@copy}return@closers}sub _verbatim_format {my($it,$p)=@_;my$formatting;for(my$i=2;$i < @$p;$i++){DEBUG and print "_verbatim_format appends a newline to $i: $p->[$i]\n";$p->[$i].= "\n"}if(DEBUG > 4){print "<<\n";for(my$i=$#$p;$i >= 2;$i--){print "_verbatim_format $i: $p->[$i]"}print ">>\n"}for(my$i=$#$p;$i > 2;$i--){DEBUG > 5 and print "Scrutinizing line $i: $$p[$i]\n";if($p->[$i]=~ m{^#:([ \^\/\%]*)\n?$}s){DEBUG > 5 and print "  It's a formatty line.  ","Peeking at previous line ",$i-1,": $$p[$i-1]: \n";if($p->[$i-1]=~ m{^#:[ \^\/\%]*\n?$}s){DEBUG > 5 and print "  Previous line is formatty!  Skipping this one.\n";next}else {DEBUG > 5 and print "  Previous line is non-formatty!  Yay!\n"}}else {DEBUG > 5 and print "  It's not a formatty line.  Ignoring\n";next}DEBUG > 4 and print "_verbatim_format considers:\n<$p->[$i-1]>\n<$p->[$i]>\n";$formatting='  ' .$1;$formatting =~ s/\s+$//s;unless(length$formatting and $p->[$i-1]=~ m/\S/){splice @$p,$i,1;$i--;next}if(length($formatting)>= length($p->[$i-1])){$formatting=substr($formatting,0,length($p->[$i-1])- 1).' '}else {$formatting .= ' ' x (length($p->[$i-1])- length($formatting))}DEBUG > 4 and print "Formatting <$formatting>    on <",$p->[$i-1],">\n";my@new_line;while($formatting =~ m{\G(( +)|(\^+)|(\/+)|(\%+))}g){if($2){push@new_line,substr($p->[$i-1],pos($formatting)-length($1),length($1))}else {push@new_line,[($3 ? 'VerbatimB' : $4 ? 'VerbatimI' : $5 ? 'VerbatimBI' : die("Should never get called")),{},substr($p->[$i-1],pos($formatting)-length($1),length($1))]}}my@nixed=splice @$p,$i-1,2,@new_line;DEBUG > 10 and print "Nixed count: ",scalar(@nixed),"\n";DEBUG > 6 and print "New version of the above line is these tokens (",scalar(@new_line),"):",map(ref($_)?"<@$_> ":"<$_>",@new_line),"\n";$i--}$p->[0]='VerbatimFormatted';for(my$i=2;$i > $#$p;$i++ ){if(!ref($p->[$i])and!ref($p->[$i + 1])){DEBUG > 5 and print "_verbatim_format merges {$p->[$i]} and {$p->[$i+1]}\n";$p->[$i].= splice @$p,$i+1,1;--$i}}for(my$i=$#$p;$i >= 2;$i-- ){if(!ref($p->[$i])){if($p->[$i]=~ s/\n$//s){DEBUG > 5 and print "_verbatim_format killed the terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]}\n"}else {DEBUG > 5 and print "No terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]} !?\n"}last}}return}sub _treelet_from_formatting_codes {my($self,$para,$start_line,$preserve_space)=@_;my$treelet=['~Top',{'start_line'=>$start_line},];unless ($preserve_space || $self->{'preserve_whitespace'}){$para =~ s/\s+/ /g;$para =~ s/ $//;$para =~ s/^ //}my@stack;my@lineage=($treelet);my$raw='';my$inL=0;DEBUG > 4 and print "Paragraph:\n$para\n\n";while($para =~ m/\G
        (?:
          # Match starting codes, including the whitespace following a
          # multiple-delimiter start code.  $1 gets the whole start code and
          # $2 gets all but one of the <s in the multiple-bracket case.
          ([A-Z]<(?:(<+)\s+)?)
          |
          # Match multiple-bracket end codes.  $3 gets the whitespace that
          # should be discarded before an end bracket but kept in other cases
          # and $4 gets the end brackets themselves.
          (\s+|(?<=\s\s))(>{2,})
          |
          (\s?>)          # $5: simple end-codes
          |
          (               # $6: stuff containing no start-codes or end-codes
            (?:
              [^A-Z\s>]
              |
              (?:
                [A-Z](?!<)
              )
              |
              # whitespace is ok, but we don't want to eat the whitespace before
              # a multiple-bracket end code.
              # NOTE: we may still have problems with e.g. S<<    >>
              (?:
                \s(?!\s*>{2,})
              )
            )+
          )
        )
      /xgo){DEBUG > 4 and print "\nParagraphic tokenstack = (@stack)\n";if(defined $1){if(defined $2){DEBUG > 3 and print "Found complex start-text code \"$1\"\n";push@stack,length($2)+ 1}else {DEBUG > 3 and print "Found simple start-text code \"$1\"\n";push@stack,0}push@lineage,[substr($1,0,1),{},];push @{$lineage[-2]},$lineage[-1];if ('L' eq substr($1,0,1)){$raw=$inL ? $raw.$1 : '';$inL=1}else {$raw .= $1 if$inL}}elsif(defined $4){DEBUG > 3 and print "Found apparent complex end-text code \"$3$4\"\n";if(!@stack){DEBUG > 4 and print " But it's really just stuff.\n";push @{$lineage[-1]},$3,$4;next}elsif(!$stack[-1]){DEBUG > 4 and print " And that's more than we needed to close simple.\n";push @{$lineage[-1]},$3;pos($para)=pos($para)- length($4)+ 1}elsif($stack[-1]==length($4)){DEBUG > 4 and print " And that's exactly what we needed to close complex.\n"}elsif($stack[-1]< length($4)){DEBUG > 4 and print " And that's more than we needed to close complex.\n";pos($para)=pos($para)- length($4)+ $stack[-1]}else {DEBUG > 4 and print " But it's really just stuff, because we needed more.\n";push @{$lineage[-1]},$3,$4;next}push @{$lineage[-1]},'' if 2==@{$lineage[-1]};pop@stack;pop@lineage;unless (@stack){$inL=0;if (ref$lineage[-1][-1]&& $lineage[-1][-1][0]eq 'L'){$lineage[-1][-1][1]{'raw'}=$raw}}$raw .= $3.$4 if$inL}elsif(defined $5){DEBUG > 3 and print "Found apparent simple end-text code \"$5\"\n";if(@stack and!$stack[-1]){DEBUG > 4 and print " It's indeed an end-code.\n";if(length($5)==2){push @{$lineage[-1]},' '}elsif(2==@{$lineage[-1]}){push @{$lineage[-1]},''}pop@stack;pop@lineage}else {DEBUG > 4 and print " It's just stuff.\n";push @{$lineage[-1]},$5}unless (@stack){$inL=0;if (ref$lineage[-1][-1]&& $lineage[-1][-1][0]eq 'L'){$lineage[-1][-1][1]{'raw'}=$raw}}$raw .= $5 if$inL}elsif(defined $6){DEBUG > 3 and print "Found stuff \"$6\"\n";push @{$lineage[-1]},$6;$raw .= $6 if$inL}else {DEBUG and print "AYYAYAAAAA at line ",__LINE__,"\n";die "SPORK 512512!"}}if(@stack){my$x="...";while(@stack){push @{$lineage[-1]},'' if 2==@{$lineage[-1]};my$code=(pop@lineage)->[0];my$ender_length=pop@stack;if($ender_length){--$ender_length;$x=$code .("<" x $ender_length)." $x " .(">" x $ender_length)}else {$x=$code ."<$x>"}}DEBUG > 1 and print "Unterminated $x sequence\n";$self->whine($start_line,"Unterminated $x sequence",)}return$treelet}sub text_content_of_treelet {return stringify_lol($_[1])}sub stringify_lol {my$string_form='';_stringify_lol($_[0]=>\$string_form);return$string_form}sub _stringify_lol {my($lol,$to)=@_;for(my$i=2;$i < @$lol;++$i){if(ref($lol->[$i]|| '')and UNIVERSAL::isa($lol->[$i],'ARRAY')){_stringify_lol($lol->[$i],$to)}else {$$to .= $lol->[$i]}}return}sub _dump_curr_open {my$curr_open=$_[0]{'curr_open'};return '[empty]' unless @$curr_open;return join '; ',map {;($_->[0]eq '=for')? (($_->[1]{'~really'}|| '=over').' ' .$_->[1]{'target'}): $_->[0]}@$curr_open }my%pretty_form=("\a"=>'\a',"\b"=>'\b',"\e"=>'\e',"\f"=>'\f',"\t"=>'\t',"\cm"=>'\cm',"\cj"=>'\cj',"\n"=>'\n','"'=>'\"','\\'=>'\\\\','$'=>'\\$','@'=>'\\@','%'=>'\\%','#'=>'\\#',);sub pretty {my@stuff=@_;my$x;my$out=join ", ",map {;if(!defined($_)){"undef"}elsif(ref($_)eq 'ARRAY' or ref($_)eq 'Pod::Simple::LinkSection'){$x="[ " .pretty(@$_)." ]" ;$x}elsif(ref($_)eq 'SCALAR'){$x="\\" .pretty($$_);$x}elsif(ref($_)eq 'HASH'){my$hr=$_;$x="{" .join(", ",map(pretty($_).'=>' .pretty($hr->{$_}),sort keys %$hr))."}" ;$x}elsif(!length($_)){q{''}}elsif($_ eq '0' or(m/^-?(?:[123456789]\d*|0)(?:\.\d+)?$/s and $_ ne '-0')){$_}else {if(chr(65)eq 'A'){s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
           #<$pretty_form{$1} || '\\x'.(unpack("H2",$1))>eg;
           <$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg}else {s<([^abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])>
           #<$pretty_form{$1} || '\\x'.(unpack("H2",$1))>eg;
           <$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg}qq{"$_"}}}@stuff;return$out}sub reinit {my$self=shift;for (qw(source_dead source_filename doc_has_started start_of_pod_block content_seen last_was_blank paras curr_open line_count pod_para_count in_pod ~tried_gen_errata errata errors_seen Title)){delete$self->{$_}}}1;
POD_SIMPLE_BLACKBOX

$fatpacked{"Pod/Simple/Checker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_CHECKER';
  require 5;package Pod::Simple::Checker;use strict;use Carp ();use Pod::Simple::Methody ();use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.28';@ISA=('Pod::Simple::Methody');BEGIN {*DEBUG=defined(&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : sub() {0}}use Text::Wrap 98.112902 ();$Text::Wrap::wrap='overflow';sub any_errata_seen {return $_[1]->{'Errata_seen'}}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||=*STDOUT{IO};$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->{'Thispara'}='';$new->{'Indent'}=0;$new->{'Indentstring'}='   ';$new->{'Errata_seen'}=0;return$new}sub handle_text {$_[0]{'Errata_seen'}and $_[0]{'Thispara'}.= $_[1]}sub start_Para {$_[0]{'Thispara'}=''}sub start_head1 {if($_[0]{'Errata_seen'}){$_[0]{'Thispara'}=''}else {if($_[1]{'errata'}){$_[0]{'Errata_seen'}=1;$_[0]{'Thispara'}=$_[0]{'source_filename'}? "$_[0]{'source_filename'} -- " : ''}}}sub start_head2 {$_[0]{'Thispara'}=''}sub start_head3 {$_[0]{'Thispara'}=''}sub start_head4 {$_[0]{'Thispara'}=''}sub start_Verbatim {$_[0]{'Thispara'}=''}sub start_item_bullet {$_[0]{'Thispara'}='* '}sub start_item_number {$_[0]{'Thispara'}="$_[1]{'number'}. "}sub start_item_text {$_[0]{'Thispara'}=''}sub start_over_bullet {++$_[0]{'Indent'}}sub start_over_number {++$_[0]{'Indent'}}sub start_over_text {++$_[0]{'Indent'}}sub start_over_block {++$_[0]{'Indent'}}sub end_over_bullet {--$_[0]{'Indent'}}sub end_over_number {--$_[0]{'Indent'}}sub end_over_text {--$_[0]{'Indent'}}sub end_over_block {--$_[0]{'Indent'}}sub end_head1 {$_[0]->emit_par(-4)}sub end_head2 {$_[0]->emit_par(-3)}sub end_head3 {$_[0]->emit_par(-2)}sub end_head4 {$_[0]->emit_par(-1)}sub end_Para {$_[0]->emit_par(0)}sub end_item_bullet {$_[0]->emit_par(0)}sub end_item_number {$_[0]->emit_par(0)}sub end_item_text {$_[0]->emit_par(-2)}sub emit_par {return unless $_[0]{'Errata_seen'};my($self,$tweak_indent)=splice(@_,0,2);my$indent=' ' x (2 * $self->{'Indent'}+ ($tweak_indent||0));$self->{'Thispara'}=~ tr{\xAD}{}d if Pod::Simple::ASCII;my$out=Text::Wrap::wrap($indent,$indent,$self->{'Thispara'}.= "\n");$out =~ tr{\xA0}{ } if Pod::Simple::ASCII;print {$self->{'output_fh'}}$out,;$self->{'Thispara'}='';return}sub end_Verbatim {return unless $_[0]{'Errata_seen'};my$self=shift;if(Pod::Simple::ASCII){$self->{'Thispara'}=~ tr{\xA0}{ };$self->{'Thispara'}=~ tr{\xAD}{}d}my$i=' ' x (2 * $self->{'Indent'}+ 4);$self->{'Thispara'}=~ s/^/$i/mg;print {$self->{'output_fh'}}'',$self->{'Thispara'},"\n\n" ;$self->{'Thispara'}='';return}1;
POD_SIMPLE_CHECKER

$fatpacked{"Pod/Simple/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DEBUG';
  require 5;package Pod::Simple::Debug;use strict;use vars qw($VERSION);$VERSION='3.28';sub import {my($value,$variable);if(@_==2){$value=$_[1]}elsif(@_==3){($variable,$value)=@_[1,2];($variable,$value)=($value,$variable)if defined$value and ref($value)eq 'SCALAR' and not(defined$variable and ref($variable)eq 'SCALAR');unless(defined$variable and ref($variable)eq 'SCALAR'){require Carp;Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}}else {require Carp;Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}if(defined&Pod::Simple::DEBUG){require Carp;Carp::croak("It's too late to call Pod::Simple::Debug -- " ."Pod::Simple has already loaded\nAborting")}$value=0 unless defined$value;unless($value =~ m/^-?\d+$/){require Carp;Carp::croak("$value isn't a numeric value." ."\nUsage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}if(defined$variable){*Pod::Simple::DEBUG=sub () {$$variable};$$variable=$value;print "# Starting Pod::Simple::DEBUG = non-constant $variable with val $value\n"}else {*Pod::Simple::DEBUG=eval " sub () { $value } ";print "# Starting Pod::Simple::DEBUG = $value\n"}require Pod::Simple;return}1;
POD_SIMPLE_DEBUG

$fatpacked{"Pod/Simple/DumpAsText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASTEXT';
  require 5;package Pod::Simple::DumpAsText;$VERSION='3.28';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||=*STDOUT{IO};$new->accept_codes('VerbatimFormatted');$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print "++ $_[1]\n";print$fh '  ' x ($_[0]{'indent'}|| 0),"++",$_[1],"\n";$_[0]{'indent'}++;while(($key,$value)=each %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_perly_escape($key);_perly_escape($value);printf$fh qq{%s \\ "%s" => "%s"\n},'  ' x ($_[0]{'indent'}|| 0),$key,$value}}return}sub _handle_text {DEBUG and print "== \"$_[1]\"\n";if(length $_[1]){my$indent='  ' x $_[0]{'indent'};my$text=$_[1];_perly_escape($text);$text =~ s/(
           [^\n]{55}         # Snare some characters from a line
           [^\n\ ]{0,50}     #  and finish any current word
          )
          \x20{1,10}(?!\n)   # capture some spaces not at line-end
         /$1"\n$indent . "/gx ;print {$_[0]{'output_fh'}}$indent,'* "',$text,"\"\n"}return}sub _handle_element_end {DEBUG and print "-- $_[1]\n";print {$_[0]{'output_fh'}}'  ' x --$_[0]{'indent'},"--",$_[1],"\n";return}sub _perly_escape {for my$x (@_){$x =~ s/([^\x00-\xFF])/sprintf'\x{%X}',ord($1)/eg;$x =~ s/([^-\n\t \&\<\>\'!\#\%\(\)\*\+,\.\/\:\;=\?\~\[\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf'\x%02X',ord($1)/eg}return}1;
POD_SIMPLE_DUMPASTEXT

$fatpacked{"Pod/Simple/DumpAsXML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASXML';
  require 5;package Pod::Simple::DumpAsXML;$VERSION='3.28';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();use Text::Wrap qw(wrap);BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||=*STDOUT{IO};$new->accept_codes('VerbatimFormatted');$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print "++ $_[1]\n";print$fh '  ' x ($_[0]{'indent'}|| 0),"<",$_[1];for my$key (sort keys %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value=$_[2]{$key});print$fh ' ',$key,'="',$value,'"'}}print$fh ">\n";$_[0]{'indent'}++;return}sub _handle_text {DEBUG and print "== \"$_[1]\"\n";if(length $_[1]){my$indent='  ' x $_[0]{'indent'};my$text=$_[1];_xml_escape($text);local$Text::Wrap::huge='overflow';$text=wrap('',$indent,$text);print {$_[0]{'output_fh'}}$indent,$text,"\n"}return}sub _handle_element_end {DEBUG and print "-- $_[1]\n";print {$_[0]{'output_fh'}}'  ' x --$_[0]{'indent'},"</",$_[1],">\n";return}sub _xml_escape {for my$x (@_){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}return}1;
POD_SIMPLE_DUMPASXML

$fatpacked{"Pod/Simple/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTML';
  require 5;package Pod::Simple::HTML;use strict;use Pod::Simple::PullParser ();use vars qw(@ISA %Tagmap $Computerese $LamePad $Linearization_Limit $VERSION $Perldoc_URL_Prefix $Perldoc_URL_Postfix $Man_URL_Prefix $Man_URL_Postfix $Title_Prefix $Title_Postfix $HTML_EXTENSION %ToIndex $Doctype_decl $Content_decl);@ISA=('Pod::Simple::PullParser');$VERSION='3.28';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}$Doctype_decl ||='';$Content_decl ||=q{<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >};$HTML_EXTENSION='.html' unless defined$HTML_EXTENSION;$Computerese="" unless defined$Computerese;$LamePad='' unless defined$LamePad;$Linearization_Limit=120 unless defined$Linearization_Limit;$Perldoc_URL_Prefix='http://search.cpan.org/perldoc?' unless defined$Perldoc_URL_Prefix;$Perldoc_URL_Postfix='' unless defined$Perldoc_URL_Postfix;$Man_URL_Prefix='http://man.he.net/man';$Man_URL_Postfix='';$Title_Prefix='' unless defined$Title_Prefix;$Title_Postfix='' unless defined$Title_Postfix;%ToIndex=map {;$_=>1}qw(head1 head2 head3 head4);__PACKAGE__->_accessorize('perldoc_url_prefix','perldoc_url_postfix','man_url_prefix','man_url_postfix','batch_mode','batch_mode_current_level','title_prefix','title_postfix','html_h_level','html_header_before_title','html_header_after_title','html_footer','index','html_css','html_javascript','force_title','default_title',);my@_to_accept;%Tagmap=('Verbatim'=>"\n<pre$Computerese>",'/Verbatim'=>"</pre>\n",'VerbatimFormatted'=>"\n<pre$Computerese>",'/VerbatimFormatted'=>"</pre>\n",'VerbatimB'=>"<b>",'/VerbatimB'=>"</b>",'VerbatimI'=>"<i>",'/VerbatimI'=>"</i>",'VerbatimBI'=>"<b><i>",'/VerbatimBI'=>"</i></b>",'Data'=>"\n",'/Data'=>"\n",'head1'=>"\n<h1>",'head2'=>"\n<h2>",'head3'=>"\n<h3>",'head4'=>"\n<h4>",'/head1'=>"</a></h1>\n",'/head2'=>"</a></h2>\n",'/head3'=>"</a></h3>\n",'/head4'=>"</a></h4>\n",'X'=>"<!--\n\tINDEX: ",'/X'=>"\n-->",changes(qw(Para=p B=b I=i over-bullet=ul over-number=ol over-text=dl over-block=blockquote item-bullet=li item-number=li item-text=dt)),changes2(map {;m/^([-a-z]+)/s && push@_to_accept,$1;$_}qw[sample=samp definition=dfn keyboard=kbd variable=var citation=cite abbreviation=abbr acronym=acronym subscript=sub superscript=sup big=big small=small underline=u strikethrough=s preformat=pre teletype=tt]),'/item-bullet'=>"</li>$LamePad\n",'/item-number'=>"</li>$LamePad\n",'/item-text'=>"</a></dt>$LamePad\n",'item-body'=>"\n<dd>",'/item-body'=>"</dd>\n",'B'=>"<b>",'/B'=>"</b>",'I'=>"<i>",'/I'=>"</i>",'F'=>"<em$Computerese>",'/F'=>"</em>",'C'=>"<code$Computerese>",'/C'=>"</code>",'L'=>"<a href='YOU_SHOULD_NEVER_SEE_THIS'>",'/L'=>"</a>",);sub changes {return map {;m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s ? ($1,=>"\n<$2>","/$1",=>"</$2>\n"): die "Funky $_"}@_}sub changes2 {return map {;m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s ? ($1,=>"<$2>","/$1",=>"</$2>"): die "Funky $_"}@_}sub go {Pod::Simple::HTML->parse_from_file(@ARGV);exit 0}sub new {my$new=shift->SUPER::new(@_);$new->nbsp_for_S(1);$new->accept_targets('html','HTML');$new->accept_codes('VerbatimFormatted');$new->accept_codes(@_to_accept);DEBUG > 2 and print "To accept: ",join(' ',@_to_accept),"\n";$new->perldoc_url_prefix($Perldoc_URL_Prefix);$new->perldoc_url_postfix($Perldoc_URL_Postfix);$new->man_url_prefix($Man_URL_Prefix);$new->man_url_postfix($Man_URL_Postfix);$new->title_prefix($Title_Prefix);$new->title_postfix($Title_Postfix);$new->html_header_before_title(qq[$Doctype_decl<html><head><title>]);$new->html_header_after_title(join "\n"=>"</title>",$Content_decl,"</head>\n<body class='pod'>",$new->version_tag_comment,"<!-- start doc -->\n",);$new->html_footer(qq[\n<!-- end doc -->\n\n</body></html>\n]);$new->{'Tagmap'}={%Tagmap};return$new}sub __adjust_html_h_levels {my ($self)=@_;my$Tagmap=$self->{'Tagmap'};my$add=$self->html_h_level;return unless defined$add;return if ($self->{'Adjusted_html_h_levels'}||0)==$add;$add -= 1;for (1 .. 4){$Tagmap->{"head$_"}=~ s/$_/$_ + $add/e;$Tagmap->{"/head$_"}=~ s/$_/$_ + $add/e}}sub batch_mode_page_object_init {my($self,$batchconvobj,$module,$infile,$outfile,$depth)=@_;DEBUG and print "Initting $self\n  for $module\n","  in $infile\n  out $outfile\n  depth $depth\n";$self->batch_mode(1);$self->batch_mode_current_level($depth);return$self}sub run {my$self=$_[0];return$self->do_middle if$self->bare_output;return $self->do_beginning && $self->do_middle && $self->do_end}sub do_beginning {my$self=$_[0];my$title;if(defined$self->force_title){$title=$self->force_title;DEBUG and print "Forcing title to be $title\n"}else {$title=$self->get_short_title();unless($self->content_seen){DEBUG and print "No content seen in search for title.\n";return}$self->{'Title'}=$title;if(defined$title and $title =~ m/\S/){$title=$self->title_prefix .esc($title).$self->title_postfix}else {$title=$self->default_title;$title='' unless defined$title;DEBUG and print "Title defaults to $title\n"}}my$after=$self->html_header_after_title || '';if($self->html_css){my$link=$self->html_css =~ m/</ ? $self->html_css : sprintf(qq[<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="%s">\n],$self->html_css,);$after =~ s{(</head>)}{$link\n$1}i}$self->_add_top_anchor(\$after);if($self->html_javascript){my$link=$self->html_javascript =~ m/</ ? $self->html_javascript : sprintf(qq[<script type="text/javascript" src="%s"></script>\n],$self->html_javascript,);$after =~ s{(</head>)}{$link\n$1}i}print {$self->{'output_fh'}}$self->html_header_before_title || '',$title,$after,;DEBUG and print "Returning from do_beginning...\n";return 1}sub _add_top_anchor {my($self,$text_r)=@_;unless($$text_r and $$text_r =~ m/name=['"]___top['"]/){$$text_r .= "<a name='___top' class='dummyTopAnchor' ></a>\n"}return}sub version_tag_comment {my$self=shift;return sprintf "<!--\n  generated by %s v%s,\n  using %s v%s,\n  under Perl v%s at %s GMT.\n\n %s\n\n-->\n",esc(ref($self),$self->VERSION(),$ISA[0],$ISA[0]->VERSION(),$],scalar(gmtime),),$self->_modnote(),}sub _modnote {my$class=ref($_[0])|| $_[0];return join "\n   "=>grep m/\S/,split "\n",qq{
  If you want to change this HTML document, you probably shouldn't do that
  by changing it directly.  Instead, see about changing the calling options
  to $class, and/or subclassing $class,
  then reconverting this document from the Pod source.
  When in doubt, email the author of $class for advice.
  See 'perldoc $class' for more info.
  }}sub do_end {my$self=$_[0];print {$self->{'output_fh'}}$self->html_footer || '';return 1}sub do_middle {my$self=$_[0];return$self->_do_middle_main_loop unless$self->index;if($self->output_string){my$out=$self->output_string;my$sneakytag="\f\f\e\e\b\bIndex Here\e\e\b\b\f\f\n";$$out .= $sneakytag;$self->_do_middle_main_loop;$sneakytag=quotemeta($sneakytag);my$index=$self->index_as_html();if($$out =~ s/$sneakytag/$index/s){DEBUG and print "Inserted ",length($index)," bytes of index HTML into $out.\n"}else {DEBUG and print "Odd, couldn't find where to insert the index in the output!\n"}return 1}unless($self->output_fh){require Carp;Carp::confess("Parser object \$p doesn't seem to have any output object!  I don't know how to deal with that.")}my$fh=$self->output_fh;my$content='';{$self->output_string(\$content);$self->_do_middle_main_loop;$self->abandon_output_string();$self->output_fh($fh)}print$fh $self->index_as_html();print$fh $content;return 1}sub index_as_html {my$self=$_[0];my$points=$self->{'PSHTML_index_points'}|| [];@$points > 1 or return qq[<div class='indexgroupEmpty'></div>\n];my(@out)=qq{\n<div class='indexgroup'>};my$level=0;my($target_level,$previous_tagname,$tagname,$text,$anchorname,$indent);for my$p (@$points,['head0','(end)']){($tagname,$text)=@$p;$anchorname=$self->section_escape($text);if($tagname =~ m{^head(\d+)$}){$target_level=0 + $1}else {if($previous_tagname =~ m{^head\d+$}){$target_level=$level + 1}else {$target_level=$level}}while($level > $target_level){--$level;push@out,("  " x $level)."</ul>"}while($level < $target_level){++$level;push@out,("  " x ($level-1))."<ul   class='indexList indexList$level'>"}$previous_tagname=$tagname;next unless$level;$indent='  ' x $level;push@out,sprintf "%s<li class='indexItem indexItem%s'><a href='#%s'>%s</a>",$indent,$level,esc($anchorname),esc($text)}push@out,"</div>\n";return join "\n",@out}sub _do_middle_main_loop {my$self=$_[0];my$fh=$self->{'output_fh'};my$tagmap=$self->{'Tagmap'};$self->__adjust_html_h_levels;my($token,$type,$tagname,$linkto,$linktype);my@stack;my$dont_wrap=0;while($token=$self->get_token){if(($type=$token->type)eq 'start'){if(($tagname=$token->tagname)eq 'L'){$linktype=$token->attr('type')|| 'insane';$linkto=$self->do_link($token);if(defined$linkto and length$linkto){esc($linkto);print$fh qq{<a href="$linkto" class="podlink$linktype"\n>}}else {print$fh "<a>"}}elsif ($tagname eq 'item-text' or $tagname =~ m/^head\d$/s){print$fh $tagmap->{$tagname}|| next;my@to_unget;while(1){push@to_unget,$self->get_token;last if$to_unget[-1]->is_end and $to_unget[-1]->tagname eq $tagname}my$name=$self->linearize_tokens(@to_unget);$name=$self->do_section($name,$token)if defined$name;print$fh "<a ";if ($tagname =~ m/^head\d$/s){print$fh "class='u'",$self->index ? " href='#___top' title='click to go to top of document'\n" : "\n"}if(defined$name){my$esc=esc($self->section_name_tidy($name));print$fh qq[name="$esc"];DEBUG and print "Linearized ",scalar(@to_unget)," tokens as \"$name\".\n";push @{$self->{'PSHTML_index_points'}},[$tagname,$name]if$ToIndex{$tagname }}else {DEBUG and print "Linearized ",scalar(@to_unget)," tokens, but it was too long, so nevermind.\n"}print$fh "\n>";$self->unget_token(@to_unget)}elsif ($tagname eq 'Data'){my$next=$self->get_token;next unless defined$next;unless($next->type eq 'text'){$self->unget_token($next);next}DEBUG and print "    raw text ",$next->text,"\n";print$fh "\n" .$next->text ."\n";next}else {if($tagname =~ m/^over-/s){push@stack,''}elsif($tagname =~ m/^item-/s and @stack and $stack[-1]){print$fh $stack[-1];$stack[-1]=''}print$fh $tagmap->{$tagname}|| next;++$dont_wrap if$tagname eq 'Verbatim' or $tagname eq "VerbatimFormatted" or $tagname eq 'X'}}elsif($type eq 'end'){if(($tagname=$token->tagname)=~ m/^over-/s){if(my$end=pop@stack){print$fh $end}}elsif($tagname =~ m/^item-/s and @stack){$stack[-1]=$tagmap->{"/$tagname"};if($tagname eq 'item-text' and defined(my$next=$self->get_token)){$self->unget_token($next);if($next->type eq 'start'){print$fh $tagmap->{"/item-text"},$tagmap->{"item-body"};$stack[-1]=$tagmap->{"/item-body"}}}next}print$fh $tagmap->{"/$tagname"}|| next;--$dont_wrap if$tagname eq 'Verbatim' or $tagname eq 'X'}elsif($type eq 'text'){esc($type=$token->text);$type =~ s/([\?\!\"\'\.\,]) /$1\n/g unless$dont_wrap;print$fh $type}}return 1}sub do_section {my($self,$name,$token)=@_;return$name}sub do_link {my($self,$token)=@_;my$type=$token->attr('type');if(!defined$type){$self->whine("Typeless L!?",$token->attr('start_line'))}elsif($type eq 'pod'){return$self->do_pod_link($token)}elsif($type eq 'url'){return$self->do_url_link($token)}elsif($type eq 'man'){return$self->do_man_link($token)}else {$self->whine("L of unknown type $type!?",$token->attr('start_line'))}return 'FNORG'}sub do_url_link {return $_[1]->attr('to')}sub do_man_link {my ($self,$link)=@_;my$to=$link->attr('to');my$frag=$link->attr('section');return undef unless defined$to and length$to;$frag=$self->section_escape($frag)if defined$frag and length($frag .= '');DEBUG and print "Resolving \"$to/$frag\"\n\n";return$self->resolve_man_page_link($to,$frag)}sub do_pod_link {my($self,$link)=@_;my$to=$link->attr('to');my$section=$link->attr('section');return undef unless((defined$to and length$to)or (defined$section and length$section));$section=$self->section_escape($section)if defined$section and length($section .= '');DEBUG and printf "Resolving \"%s\" \"%s\"...\n",$to || "(nil)",$section || "(nil)";{my$complete_url=$self->resolve_pod_link_by_table($to,$section);if($complete_url){DEBUG > 1 and print "resolve_pod_link_by_table(T,S) gives ",$complete_url,"\n  (Returning that.)\n";return$complete_url}else {DEBUG > 4 and print " resolve_pod_link_by_table(T,S)"," didn't return anything interesting.\n"}}if(defined$to and length$to){my$there=$self->resolve_pod_link_by_table($to);if(defined$there and length$there){DEBUG > 1 and print "resolve_pod_link_by_table(T) gives $there\n"}else {$there=$self->resolve_pod_page_link($to,$section);DEBUG > 1 and print "resolve_pod_page_link gives ",$to || "(nil)","\n";unless(defined$there and length$there){DEBUG and print "Can't resolve $to\n";return undef}}$to=$there}my$out=(defined$to and length$to)? $to : '';$out .= "#" .$section if defined$section and length$section;unless(length$out){DEBUG and printf "Oddly, couldn't resolve \"%s\" \"%s\"...\n",$to || "(nil)",$section || "(nil)";return undef}DEBUG and print "Resolved to $out\n";return$out}sub section_escape {my($self,$section)=@_;return$self->section_url_escape($self->section_name_tidy($section))}sub section_name_tidy {my($self,$section)=@_;$section =~ s/^\s+//;$section =~ s/\s+$//;$section =~ tr/ /_/;$section =~ tr/\x00-\x1F\x80-\x9F//d if 'A' eq chr(65);$section=$self->unicode_escape_url($section);$section='_' unless length$section;return$section}sub section_url_escape {shift->general_url_escape(@_)}sub pagepath_url_escape {shift->general_url_escape(@_)}sub manpage_url_escape {shift->general_url_escape(@_)}sub general_url_escape {my($self,$string)=@_;$string =~ s/([^\x00-\xFF])/join '', map sprintf('%%%02X',$_), unpack 'C*', $1/eg;$string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',ord($1))/eg;return$string}sub resolve_pod_page_link {my$self=shift;return$self->batch_mode()? $self->resolve_pod_page_link_batch_mode(@_): $self->resolve_pod_page_link_singleton_mode(@_)}sub resolve_pod_page_link_singleton_mode {my($self,$it)=@_;return undef unless defined$it and length$it;my$url=$self->pagepath_url_escape($it);$url =~ s{::$}{}s;$url =~ s{::}{/}g unless$self->perldoc_url_prefix =~ m/\?/s;return undef unless length$url;return$self->perldoc_url_prefix .$url .$self->perldoc_url_postfix}sub resolve_pod_page_link_batch_mode {my($self,$to)=@_;DEBUG > 1 and print " During batch mode, resolving $to ...\n";my@path=grep length($_),split m/::/s,$to,-1;unless(@path){DEBUG and print "Very odd!  Splitting $to gives (nil)!\n";return undef}$self->batch_mode_rectify_path(\@path);my$out=join('/',map$self->pagepath_url_escape($_),@path).$HTML_EXTENSION;DEBUG > 1 and print " => $out\n";return$out}sub batch_mode_rectify_path {my($self,$pathbits)=@_;my$level=$self->batch_mode_current_level;$level--;if($level < 1){unshift @$pathbits,'.'}else {unshift @$pathbits,('..')x $level}return}sub resolve_man_page_link {my ($self,$to,$frag)=@_;my ($page,$section)=$to =~ /^([^(]+)(?:[(](\d+)[)])?$/;return undef unless defined$page and length$page;$section ||=1;return$self->man_url_prefix ."$section/" .$self->manpage_url_escape($page).$self->man_url_postfix}sub resolve_pod_link_by_table {return unless $_[0]->{'podhtml_LOT'};my($self,$to,$section)=@_;if(defined$section){$to='' unless defined$to and length$to;return$self->{'podhtml_LOT'}{"$to#$section"}}else {return$self->{'podhtml_LOT'}{$to}}return}sub linearize_tokens {my$self=shift;my$out='';my$t;while($t=shift @_){if(!ref$t or!UNIVERSAL::can($t,'is_text')){$out .= $t}elsif($t->is_text){$out .= $t->text}elsif($t->is_start and $t->tag eq 'X'){my$x_open=1;while($x_open){next if(($t=shift @_)->is_text);if($t->is_start and $t->tag eq 'X'){++$x_open}elsif($t->is_end and $t->tag eq 'X'){--$x_open}}}}return undef if length$out > $Linearization_Limit;return$out}sub unicode_escape_url {my($self,$string)=@_;$string =~ s/([^\x00-\xFF])/'('.ord($1).')'/eg;return$string}sub esc {if(defined wantarray){if(wantarray){@_=splice @_}else {my$x=shift;$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;return$x}}for my$x (@_){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg if defined$x}return @_}1;
POD_SIMPLE_HTML

$fatpacked{"Pod/Simple/HTMLBatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLBATCH';
  require 5;package Pod::Simple::HTMLBatch;use strict;use vars qw($VERSION $HTML_RENDER_CLASS $HTML_EXTENSION $CSS $JAVASCRIPT $SLEEPY $SEARCH_CLASS @ISA);$VERSION='3.28';@ISA=();use Pod::Simple::HTML ();BEGIN {*esc=\&Pod::Simple::HTML::esc}use File::Spec ();use Pod::Simple::Search;$SEARCH_CLASS ||='Pod::Simple::Search';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}$SLEEPY=1 if!defined$SLEEPY and $^O =~ /mswin|mac/i;$HTML_RENDER_CLASS ||="Pod::Simple::HTML";Pod::Simple::_accessorize(__PACKAGE__,'verbose','html_render_class','search_class','contents_file','index','progress','contents_page_start','contents_page_end','css_flurry','_css_wad','javascript_flurry','_javascript_wad','no_contents_links','_contents',);sub go {@ARGV==2 or die sprintf("Usage: perl -M%s -e %s:go indirs outdir\n  (or use \"\@INC\" for indirs)\n",__PACKAGE__,__PACKAGE__,);if(defined($ARGV[1])and length($ARGV[1])){my$d=$ARGV[1];-e $d or die "I see no output directory named \"$d\"\nAborting";-d $d or die "But \"$d\" isn't a directory!\nAborting";-w $d or die "Directory \"$d\" isn't writeable!\nAborting"}__PACKAGE__->batch_convert(@ARGV)}sub new {my$new=bless {},ref($_[0])|| $_[0];$new->html_render_class($HTML_RENDER_CLASS);$new->search_class($SEARCH_CLASS);$new->verbose(1 + DEBUG);$new->_contents([]);$new->index(1);$new-> _css_wad([]);$new->css_flurry(1);$new->_javascript_wad([]);$new->javascript_flurry(1);$new->contents_file('index' .($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION));$new->contents_page_start(join "\n",grep $_,$Pod::Simple::HTML::Doctype_decl,"<html><head>","<title>Perl Documentation</title>",$Pod::Simple::HTML::Content_decl,"</head>","\n<body class='contentspage'>\n<h1>Perl Documentation</h1>\n");$new->contents_page_end(sprintf("\n\n<p class='contentsfooty'>Generated by %s v%s under Perl v%s\n<br >At %s GMT, which is %s local time.</p>\n\n</body></html>\n",esc(ref($new),eval {$new->VERSION}|| $VERSION,$],scalar(gmtime),scalar(localtime),)));return$new}sub muse {my$self=shift;if($self->verbose){print 'T+',int(time()- $self->{'_batch_start_time'}),"s: ",@_,"\n"}return 1}sub batch_convert {my($self,$dirs,$outdir)=@_;$self ||=__PACKAGE__;$self=$self->new unless ref$self;if(!defined($dirs)or $dirs eq '' or $dirs eq '@INC'){$dirs=''}elsif(ref$dirs){}else {require Config;my$ps=quotemeta($Config::Config{'path_sep'}|| ":");$dirs=[grep length($_),split qr/$ps/,$dirs ]}$outdir=$self->filespecsys->curdir unless defined$outdir and length$outdir;$self->_batch_convert_main($dirs,$outdir)}sub _batch_convert_main {my($self,$dirs,$outdir)=@_;$self->{'_batch_start_time'}||=time();$self->muse("= ",scalar(localtime));$self->muse("Starting batch conversion to \"$outdir\"");my$progress=$self->progress;if(!$progress and $self->verbose > 0 and $self->verbose()<= 5){require Pod::Simple::Progress;$progress=Pod::Simple::Progress->new(($self->verbose < 2)? (): ($self->verbose==2)? 1 : 0);$self->progress($progress)}if($dirs){$self->muse(scalar(@$dirs)," dirs to scan: @$dirs")}else {$self->muse("Scanning \@INC.  This could take a minute or two.")}my$mod2path=$self->find_all_pods($dirs ? $dirs : ());$self->muse("Done scanning.");my$total=keys %$mod2path;unless($total){$self->muse("No pod found.  Aborting batch conversion.\n");return$self}$progress and $progress->goal($total);$self->muse("Now converting pod files to HTML.",($total > 25)? "  This will take a while more." : ());$self->_spray_css($outdir);$self->_spray_javascript($outdir);$self->_do_all_batch_conversions($mod2path,$outdir);$progress and $progress->done(sprintf ("Done converting %d files.",$self->{"__batch_conv_page_count"}));return$self->_batch_convert_finish($outdir);return$self}sub _do_all_batch_conversions {my($self,$mod2path,$outdir)=@_;$self->{"__batch_conv_page_count"}=0;for my$module (sort {lc($a)cmp lc($b)}keys %$mod2path){$self->_do_one_batch_conversion($module,$mod2path,$outdir);sleep($SLEEPY - 1)if$SLEEPY}return}sub _batch_convert_finish {my($self,$outdir)=@_;$self->write_contents_file($outdir);$self->muse("Done with batch conversion.  $$self{'__batch_conv_page_count'} files done.");$self->muse("= ",scalar(localtime));$self->progress and $self->progress->done("All done!");return}sub _do_one_batch_conversion {my($self,$module,$mod2path,$outdir,$outfile)=@_;my$retval;my$total=scalar keys %$mod2path;my$infile=$mod2path->{$module};my@namelets=grep m/\S/,split "::",$module;my$depth=scalar@namelets;die "Contentless thingie?! $module $infile" unless@namelets;$outfile ||=do {my@n=@namelets;$n[-1].= $HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION;$self->filespecsys->catfile($outdir,@n)};my$progress=$self->progress;my$page=$self->html_render_class->new;if(DEBUG > 5){$self->muse($self->{"__batch_conv_page_count"}+ 1,"/$total: ",ref($page)," render ($depth) $module => $outfile")}elsif(DEBUG > 2){$self->muse($self->{"__batch_conv_page_count"}+ 1,"/$total: $module => $outfile")}$page->batch_mode_page_object_init($self,$module,$infile,$outfile,$depth)if$page->can('batch_mode_page_object_init');$self->batch_mode_page_object_init($page,$module,$infile,$outfile,$depth)if$self->can('batch_mode_page_object_init');$self->makepath($outdir=>\@namelets);$progress and $progress->reach($self->{"__batch_conv_page_count"},"Rendering $module");if($retval=$page->parse_from_file($infile,$outfile)){++ $self->{"__batch_conv_page_count"};$self->note_for_contents_file(\@namelets,$infile,$outfile)}else {$self->muse("Odd, parse_from_file(\"$infile\", \"$outfile\") returned false.")}$page->batch_mode_page_object_kill($self,$module,$infile,$outfile,$depth)if$page->can('batch_mode_page_object_kill');$self->batch_mode_page_object_kill($page,$module,$infile,$outfile,$depth)if$self->can('batch_mode_page_object_kill');DEBUG > 4 and printf "%s %sb < $infile %s %sb\n",$outfile,-s $outfile,$infile,-s $infile ;undef($page);return$retval}sub filespecsys {$_[0]{'_filespecsys'}|| 'File::Spec'}sub note_for_contents_file {my($self,$namelets,$infile,$outfile)=@_;if($self->contents_file){my$c=$self->_contents();push @$c,[join("::",@$namelets),$infile,$outfile,$namelets ];DEBUG > 3 and print "Noting @$c[-1]\n"}return}sub write_contents_file {my($self,$outdir)=@_;my$outfile=$self->_contents_filespec($outdir)|| return;$self->muse("Preparing list of modules for ToC");my($toplevel,$toplevel_form_freq,)=$self->_prep_contents_breakdown;my$Contents=eval {$self->_wopen($outfile)};if($Contents){$self->muse("Writing contents file $outfile")}else {warn "Couldn't write-open contents file $outfile: $!\nAbort writing to $outfile at all";return}$self->_write_contents_start($Contents,$outfile,);$self->_write_contents_middle($Contents,$outfile,$toplevel,$toplevel_form_freq);$self->_write_contents_end($Contents,$outfile,);return$outfile}sub _write_contents_start {my($self,$Contents,$outfile)=@_;my$starter=$self->contents_page_start || '';{my$css_wad=$self->_css_wad_to_markup(1);if($css_wad){$starter =~ s{(</head>)}{\n$css_wad\n$1}i}my$javascript_wad=$self->_javascript_wad_to_markup(1);if($javascript_wad){$starter =~ s{(</head>)}{\n$javascript_wad\n$1}i}}unless(print$Contents $starter,"<dl class='superindex'>\n"){warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Contents);return 0}return 1}sub _write_contents_middle {my($self,$Contents,$outfile,$toplevel2submodules,$toplevel_form_freq)=@_;for my$t (sort keys %$toplevel2submodules){my@downlines=sort {$a->[-1]cmp $b->[-1]}@{$toplevel2submodules->{$t}};printf$Contents qq[<dt><a name="%s">%s</a></dt>\n<dd>\n],esc($t,$toplevel_form_freq->{$t});my($path,$name);for my$e (@downlines){$name=$e->[0];$path=join("/",'.',esc(@{$e->[3]})).($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION);print$Contents qq{  <a href="$path">},esc($name),"</a>&nbsp;&nbsp;\n"}print$Contents "</dd>\n\n"}return 1}sub _write_contents_end {my($self,$Contents,$outfile)=@_;unless(print$Contents "</dl>\n",$self->contents_page_end || '',){warn "Couldn't write to $outfile: $!"}close($Contents)or warn "Couldn't close $outfile: $!";return 1}sub _prep_contents_breakdown {my($self)=@_;my$contents=$self->_contents;my%toplevel;my%toplevel_form_freq;for my$entry (@$contents){my$toplevel=$entry->[0]=~ m/^perl\w*$/ ? 'perl_core_docs' : $entry->[3][0];++$toplevel_form_freq{lc$toplevel }{$toplevel };push @{$toplevel{lc$toplevel }},$entry;push @$entry,lc($entry->[0])}for my$toplevel (sort keys%toplevel){my$fgroup=$toplevel_form_freq{$toplevel};$toplevel_form_freq{$toplevel}=(sort {$fgroup->{$b}<=> $fgroup->{$a}or $a cmp $b}keys %$fgroup)[0]}return(\%toplevel,\%toplevel_form_freq)if wantarray;return \%toplevel}sub _contents_filespec {my($self,$outdir)=@_;my$outfile=$self->contents_file;return unless$outfile;return$self->filespecsys->catfile($outdir,$outfile)}sub makepath {my($self,$outdir,$namelets)=@_;return unless @$namelets > 1;for my$i (0 .. ($#$namelets - 1)){my$dir=$self->filespecsys->catdir($outdir,@$namelets[0 .. $i]);if(-e $dir){die "$dir exists but not as a directory!?" unless -d $dir;next}DEBUG > 3 and print "  Making $dir\n";mkdir$dir,0777 or die "Can't mkdir $dir: $!\nAborting" }return}sub batch_mode_page_object_init {my$self=shift;my($page,$module,$infile,$outfile,$depth)=@_;$page->default_title($module);$page->index($self->index);$page->html_css($self-> _css_wad_to_markup($depth));$page->html_javascript($self->_javascript_wad_to_markup($depth));$self->add_header_backlink($page,$module,$infile,$outfile,$depth);$self->add_footer_backlink($page,$module,$infile,$outfile,$depth);return$self}sub add_header_backlink {my$self=shift;return if$self->no_contents_links;my($page,$module,$infile,$outfile,$depth)=@_;$page->html_header_after_title(join '',$page->html_header_after_title || '',qq[<p class="backlinktop"><b><a name="___top" href="],$self->url_up_to_contents($depth),qq[" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>\n],)if$self->contents_file ;return}sub add_footer_backlink {my$self=shift;return if$self->no_contents_links;my($page,$module,$infile,$outfile,$depth)=@_;$page->html_footer(join '',qq[<p class="backlinkbottom"><b><a name="___bottom" href="],$self->url_up_to_contents($depth),qq[" title="All Documents">&lt;&lt;</a></b></p>\n],$page->html_footer || '',)if$self->contents_file ;return}sub url_up_to_contents {my($self,$depth)=@_;--$depth;return join '/',('..')x $depth,esc($self->contents_file)}sub find_all_pods {my($self,$dirs)=@_;return$self->modnames2paths($dirs)}sub modnames2paths {my($self,$dirs)=@_;my$m2p;{my$search=$self->search_class->new;DEBUG and print "Searching via $search\n";$search->verbose(1)if DEBUG > 10;$search->progress($self->progress->copy->goal(0))if$self->progress;$search->shadows(0);$search->inc($dirs ? 0 : 1);$search->survey($dirs ? @$dirs : ());$m2p=$search->name2path;die "What, no name2path?!" unless$m2p}$self->muse("That's odd... no modules found!")unless keys %$m2p;if(DEBUG > 4){print "Modules found (name => path):\n";for my$m (sort {lc($a)cmp lc($b)}keys %$m2p){print "  $m  $$m2p{$m}\n"}print "(total ",scalar(keys %$m2p),")\n\n"}elsif(DEBUG){print "Found ",scalar(keys %$m2p)," modules.\n"}$self->muse("Found ",scalar(keys %$m2p)," modules.");return$m2p}sub _wopen {my($self,$outpath)=@_;require Symbol;my$out_fh=Symbol::gensym();DEBUG > 5 and print "Write-opening to $outpath\n";return$out_fh if open($out_fh,"> $outpath");require Carp;Carp::croak("Can't write-open $outpath: $!")}sub add_css {my($self,$url,$is_default,$name,$content_type,$media,$_code)=@_;return unless$url;unless($name){$name=$url;if($name !~ m/\?/ and $name =~ m{([^/]+)$}s){$name=$1;$name =~ s/\.css//i}}$media ||='all';$content_type ||='text/css';my$bunch=[$url,$name,$content_type,$media,$_code];if($is_default){unshift @{$self->_css_wad},$bunch}else {push @{$self->_css_wad},$bunch}return}sub _spray_css {my($self,$outdir)=@_;return unless$self->css_flurry();$self->_gen_css_wad();my$lol=$self->_css_wad;for my$chunk (@$lol){my$url=$chunk->[0];my$outfile;if(ref($chunk->[-1])and $url =~ m{^(_[-a-z0-9_]+\.css$)}){$outfile=$self->filespecsys->catfile($outdir,"$1");DEBUG > 5 and print "Noting $$chunk[0] as a file I'll create.\n"}else {DEBUG > 5 and print "OK, noting $$chunk[0] as an external CSS.\n";next}my$Cssout=$self->_wopen($outfile);print$Cssout ${$chunk->[-1]}or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Cssout);DEBUG > 5 and print "Wrote $outfile\n"}return}sub _css_wad_to_markup {my($self,$depth)=@_;my@css=@{$self->_css_wad || return ''};return '' unless@css;my$rel='stylesheet';my$out='';--$depth;my$uplink=$depth ? ('../' x $depth): '';for my$chunk (@css){next unless$chunk and @$chunk;my($url1,$url2,$title,$type,$media)=($self->_maybe_uplink($chunk->[0],$uplink),esc(grep!ref($_),@$chunk));$out .= qq{<link rel="$rel" title="$title" type="$type" href="$url1$url2" media="$media" >\n};$rel='alternate stylesheet'}return$out}sub _maybe_uplink {my($self,$url,$uplink)=@_;($url =~ m{^\./} or $url !~ m{[/\:]})? $uplink : ''}sub _gen_css_wad {my$self=$_[0];my$css_template=$self->_css_template;for my$variation ('110n=blkbluw','010n=blkmagw','100n=blkcynw','101=whtprpk','001=whtnavk','010a=grygrnk','010b=whtgrng','101an=blkgrng','101bn=grygrnw',){my$outname=$variation;my($flipmode,@swap)=(($4 || ''),$1,$2,$3)if$outname =~ s/^([012])([012])([[012])([a-z]*)=?//s;@swap=()if '010' eq join '',@swap;my$this_css="/* This file is autogenerated.  Do not edit.  $variation */\n\n" .$css_template;if($flipmode =~ m/n/){$this_css =~ s/(#[0-9a-fA-F]{3})\b/_color_negate($1)/eg;$this_css =~ s/\bthin\b/medium/g}$this_css =~ s<#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])\b>
                    < join '', '#', ($1,$2,$3)[@swap] >eg if@swap;if($flipmode =~ m/a/){$this_css =~ s/#fff\b/#999/gi}elsif($flipmode =~ m/b/){$this_css =~ s/#000\b/#666/gi}my$name=$outname;$name =~ tr/-_/  /;$self->add_css("_$outname.css",0,$name,0,0,\$this_css)}for my$variation ('blkbluw','whtpurk','whtgrng','grygrnw',){my$outname=$variation;my$this_css=join "\n","/* This file is autogenerated.  Do not edit.  $outname */\n","\@import url(\"./_$variation.css\");",".indexgroup { display: none; }","\n",;my$name=$outname;$name =~ tr/-_/  /;$self->add_css("_$outname.css",0,$name,0,0,\$this_css)}return}sub _color_negate {my$x=lc $_[0];$x =~ tr[0123456789abcdef]
            [fedcba9876543210];return$x}sub add_javascript {my($self,$url,$content_type,$_code)=@_;return unless$url;push @{$self->_javascript_wad},[$url,$content_type || 'text/javascript',$_code ];return}sub _spray_javascript {my($self,$outdir)=@_;return unless$self->javascript_flurry();$self->_gen_javascript_wad();my$lol=$self->_javascript_wad;for my$script (@$lol){my$url=$script->[0];my$outfile;if(ref($script->[-1])and $url =~ m{^(_[-a-z0-9_]+\.js$)}){$outfile=$self->filespecsys->catfile($outdir,"$1");DEBUG > 5 and print "Noting $$script[0] as a file I'll create.\n"}else {DEBUG > 5 and print "OK, noting $$script[0] as an external JavaScript.\n";next}my$Jsout=$self->_wopen($outfile);print$Jsout ${$script->[-1]}or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Jsout);DEBUG > 5 and print "Wrote $outfile\n"}return}sub _gen_javascript_wad {my$self=$_[0];my$js_code=$self->_javascript || return;$self->add_javascript("_podly.js",0,\$js_code);return}sub _javascript_wad_to_markup {my($self,$depth)=@_;my@scripts=@{$self->_javascript_wad || return ''};return '' unless@scripts;my$out='';--$depth;my$uplink=$depth ? ('../' x $depth): '';for my$s (@scripts){next unless$s and @$s;my($url1,$url2,$type,$media)=($self->_maybe_uplink($s->[0],$uplink),esc(grep!ref($_),@$s));$out .= qq{<script type="$type" src="$url1$url2"></script>\n}}return$out}sub _css_template {return$CSS}sub _javascript {return$JAVASCRIPT}$CSS=<<'EOCSS';$JAVASCRIPT=<<'EOJAVASCRIPT';1;
  /* For accessibility reasons, never specify text sizes in px/pt/pc/in/cm/mm */
  
  @media all { .hide { display: none; } }
  
  @media print {
    .noprint, div.indexgroup, .backlinktop, .backlinkbottom { display: none }
  
    * {
      border-color: black !important;
      color: black !important;
      background-color: transparent !important;
      background-image: none !important;
    }
  
    dl.superindex > dd  {
      word-spacing: .6em;
    }
  }
  
  @media aural, braille, embossed {
    div.indexgroup  { display: none; }  /* Too noisy, don't you think? */
    dl.superindex > dt:before { content: "Group ";  }
    dl.superindex > dt:after  { content: " contains:"; }
    .backlinktop    a:before  { content: "Back to contents"; }
    .backlinkbottom a:before  { content: "Back to contents"; }
  }
  
  @media aural {
    dl.superindex > dt  { pause-before: 600ms; }
  }
  
  @media screen, tty, tv, projection {
    .noscreen { display: none; }
  
    a:link    { color: #7070ff; text-decoration: underline; }
    a:visited { color: #e030ff; text-decoration: underline; }
    a:active  { color: #800000; text-decoration: underline; }
    body.contentspage a            { text-decoration: none; }
    a.u { color: #fff !important; text-decoration: none; }
  
    body.pod {
      margin: 0 5px;
      color:            #fff;
      background-color: #000;
    }
  
    body.pod h1, body.pod h2, body.pod h3, body.pod h4  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      margin-top: 1.2em;
      margin-bottom: .1em;
      border-top: thin solid transparent;
      /* margin-left: -5px;  border-left: 2px #7070ff solid;  padding-left: 3px; */
    }
    
    body.pod h1  { border-top-color: #0a0; }
    body.pod h2  { border-top-color: #080; }
    body.pod h3  { border-top-color: #040; }
    body.pod h4  { border-top-color: #010; }
  
    p.backlinktop + h1 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h2 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h3 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h4 { border-top: none; margin-top: 0em;  }
  
    body.pod dt {
      font-size: 105%; /* just a wee bit more than normal */
    }
  
    .indexgroup { font-size: 80%; }
  
    .backlinktop,   .backlinkbottom    {
      margin-left:  -5px;
      margin-right: -5px;
      background-color:         #040;
      border-top:    thin solid #050;
      border-bottom: thin solid #050;
    }
    
    .backlinktop a, .backlinkbottom a  {
      text-decoration: none;
      color: #080;
      background-color:  #000;
      border: thin solid #0d0;
    }
    .backlinkbottom { margin-bottom: 0; padding-bottom: 0; }
    .backlinktop    { margin-top:    0; padding-top:    0; }
  
    body.contentspage {
      color:            #fff;
      background-color: #000;
    }
    
    body.contentspage h1  {
      color:            #0d0;
      margin-left: 1em;
      margin-right: 1em;
      text-indent: -.9em;
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      border-top:    thin solid #fff;
      border-bottom: thin solid #fff;
      text-align: center;
    }
  
    dl.superindex > dt  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      font-size: 90%;
      margin-top: .45em;
      /* margin-bottom: -.15em; */
    }
    dl.superindex > dd  {
      word-spacing: .6em;    /* most important rule here! */
    }
    dl.superindex > a:link  {
      text-decoration: none;
      color: #fff;
    }
  
    .contentsfooty {
      border-top: thin solid #999;
      font-size: 90%;
    }
    
  }
  
  /* The End */
  
  EOCSS
  
  // From http://www.alistapart.com/articles/alternate/
  
  function setActiveStyleSheet(title) {
    var i, a, main;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")) {
        a.disabled = true;
        if(a.getAttribute("title") == title) a.disabled = false;
      }
    }
  }
  
  function getActiveStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("title")
         && !a.disabled
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function getPreferredStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("rel").indexOf("alt") == -1
         && a.getAttribute("title")
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function createCookie(name,value,days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      var expires = "; expires="+date.toGMTString();
    }
    else expires = "";
    document.cookie = name+"="+value+expires+"; path=/";
  }
  
  function readCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0  ;  i < ca.length  ;  i++) {
      var c = ca[i];
      while (c.charAt(0)==' ') c = c.substring(1,c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
  }
  
  window.onload = function(e) {
    var cookie = readCookie("style");
    var title = cookie ? cookie : getPreferredStyleSheet();
    setActiveStyleSheet(title);
  }
  
  window.onunload = function(e) {
    var title = getActiveStyleSheet();
    createCookie("style", title, 365);
  }
  
  var cookie = readCookie("style");
  var title = cookie ? cookie : getPreferredStyleSheet();
  setActiveStyleSheet(title);
  
  // The End
  
  EOJAVASCRIPT
POD_SIMPLE_HTMLBATCH

$fatpacked{"Pod/Simple/HTMLLegacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLLEGACY';
  require 5;package Pod::Simple::HTMLLegacy;use strict;use vars qw($VERSION);use Getopt::Long;$VERSION="5.01";sub pod2html {my@args=(@_);my($verbose,$infile,$outfile,$title);my$index=1;{my($help);my($netscape);local@ARGV=@args;GetOptions("help"=>\$help,"verbose!"=>\$verbose,"infile=s"=>\$infile,"outfile=s"=>\$outfile,"title=s"=>\$title,"index!"=>\$index,"netscape!"=>\$netscape,)or return bad_opts(@args);bad_opts(@args)if@ARGV;return help_message()if$help}for($infile,$outfile){$_=undef unless defined and length}if($verbose){warn sprintf "%s version %s\n",__PACKAGE__,$VERSION;warn "OK, processed args [@args] ...\n";warn sprintf " Verbose: %s\n Index: %s\n Infile: %s\n Outfile: %s\n Title: %s\n",map defined($_)? $_ : "(nil)",$verbose,$index,$infile,$outfile,$title,;*Pod::Simple::HTML::DEBUG=sub(){1}}require Pod::Simple::HTML;Pod::Simple::HTML->VERSION(3);die "No such input file as $infile\n" if defined$infile and!-e $infile;my$pod=Pod::Simple::HTML->new;$pod->force_title($title)if defined$title;$pod->index($index);return$pod->parse_from_file($infile,$outfile)}sub bad_opts {die _help_message()}sub help_message {print STDOUT _help_message()}sub _help_message {join '',"[",__PACKAGE__," version ",$VERSION,qq~]
  Usage:  pod2html --help --infile=<name> --outfile=<name>
     --verbose --index --noindex
  
  Options:
    --help         - prints this message.
    --[no]index    - generate an index at the top of the resulting html
                     (default behavior).
    --infile       - filename for the pod to convert (input taken from stdin
                     by default).
    --outfile      - filename for the resulting html file (output sent to
                     stdout by default).
    --title        - title that will appear in resulting html file.
    --[no]verbose  - self-explanatory (off by default).
  
  Note that pod2html is DEPRECATED, and this version implements only
   some of the options known to older versions.
  For more information, see 'perldoc pod2html'.
  ~}1;
POD_SIMPLE_HTMLLEGACY

$fatpacked{"Pod/Simple/LinkSection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_LINKSECTION';
  require 5;package Pod::Simple::LinkSection;use vars qw($VERSION);$VERSION='3.28';use strict;use Pod::Simple::BlackBox;use vars qw($VERSION);$VERSION='3.28';use overload('""'=>\&Pod::Simple::BlackBox::stringify_lol,'bool'=>\&Pod::Simple::BlackBox::stringify_lol,'fallback'=>1,);sub tack_on {$_[0]=['',{},"$_[0]" ];return $_[0][2].= $_[1]}sub as_string {goto&Pod::Simple::BlackBox::stringify_lol}sub stringify {goto&Pod::Simple::BlackBox::stringify_lol}sub new {my$class=shift;$class=ref($class)|| $class;my$new;if(@_==1){if (!ref($_[0]|| '')){return bless ['',{},$_[0]],$class}elsif(ref($_[0]|| '')eq 'ARRAY'){$new=[@{$_[0]}]}else {Carp::croak("$class new() doesn't know to clone $new")}}else {$new=['',{},@_ ]}for my$x (@$new){if(ref($x || '')eq 'ARRAY'){$x=$class->new($x)}elsif(ref($x || '')eq 'HASH'){$x={%$x }}}return bless$new,$class}1;
POD_SIMPLE_LINKSECTION

$fatpacked{"Pod/Simple/Methody.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_METHODY';
  require 5;package Pod::Simple::Methody;use strict;use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.28';@ISA=('Pod::Simple');sub _handle_element_start {$_[1]=~ tr/-:./__/;($_[0]->can('start_' .$_[1])|| return)->($_[0],$_[2])}sub _handle_text {($_[0]->can('handle_text')|| return)->(@_)}sub _handle_element_end {$_[1]=~ tr/-:./__/;($_[0]->can('end_' .$_[1])|| return)->($_[0],$_[2])}1;
POD_SIMPLE_METHODY

$fatpacked{"Pod/Simple/Progress.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PROGRESS';
  require 5;package Pod::Simple::Progress;$VERSION='3.28';use strict;sub new {my($class,$delay)=@_;my$self=bless {'quiet_until'=>1},ref($class)|| $class;$self->to(*STDOUT{IO});$self->delay(defined($delay)? $delay : 5);return$self}sub copy {my$orig=shift;bless {%$orig,'quiet_until'=>1},ref($orig)}sub reach {my($self,$point,$note)=@_;if((my$now=time)>= $self->{'quiet_until'}){my$goal;my$to=$self->{'to'};print$to join('',($self->{'quiet_until'}==1)? (): '... ',(defined$point)? ('#',($goal=$self->{'goal'})? (' ' x (length($goal)- length($point)),$point,'/',$goal,): $point,$note ? ': ' : (),): (),$note || '',"\n");$self->{'quiet_until'}=$now + $self->{'delay'}}return$self}sub done {my($self,$note)=@_;$self->{'quiet_until'}=1;return$self->reach(undef,$note)}sub delay {return $_[0]{'delay'}if @_==1;$_[0]{'delay'}=$_[1];return $_[0]}sub goal {return $_[0]{'goal' }if @_==1;$_[0]{'goal' }=$_[1];return $_[0]}sub to {return $_[0]{'to' }if @_==1;$_[0]{'to' }=$_[1];return $_[0]}unless(caller){my$p=__PACKAGE__->new->goal(5);$p->reach(1,"Primus!");sleep 1;$p->reach(2,"Secundus!");sleep 3;$p->reach(3,"Tertius!");sleep 5;$p->reach(4);$p->reach(5,"Quintus!");sleep 1;$p->done("All done")}1;
POD_SIMPLE_PROGRESS

$fatpacked{"Pod/Simple/PullParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSER';
  require 5;package Pod::Simple::PullParser;$VERSION='3.28';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();use Pod::Simple::PullParserStartToken;use Pod::Simple::PullParserEndToken;use Pod::Simple::PullParserTextToken;BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}__PACKAGE__->_accessorize('source_fh','source_scalar_ref','source_arrayref',);sub filter {my($self,$source)=@_;$self=$self->new unless ref$self;$source=*STDIN{IO}unless defined$source;$self->set_source($source);$self->output_fh(*STDOUT{IO});$self->run;return$self}sub parse_string_document {my$this=shift;$this->set_source(\ $_[0]);$this->run}sub parse_file {my($this,$filename)=@_;$this->set_source($filename);$this->run}sub run {use Carp ();if(__PACKAGE__ eq ref($_[0])|| $_[0]){Carp::croak "You can call run() only on subclasses of " .__PACKAGE__}else {Carp::croak join '',"You can't call run() because ",ref($_[0])|| $_[0]," didn't define a run() method"}}sub parse_lines {use Carp ();Carp::croak "Use set_source with ",__PACKAGE__," and subclasses, not parse_lines"}sub parse_line {use Carp ();Carp::croak "Use set_source with ",__PACKAGE__," and subclasses, not parse_line"}sub new {my$class=shift;my$self=$class->SUPER::new(@_);die "Couldn't construct for $class" unless$self;$self->{'token_buffer'}||=[];$self->{'start_token_class'}||='Pod::Simple::PullParserStartToken';$self->{'text_token_class'}||='Pod::Simple::PullParserTextToken';$self->{'end_token_class'}||='Pod::Simple::PullParserEndToken';DEBUG > 1 and print "New pullparser object: $self\n";return$self}sub get_token {my$self=shift;DEBUG > 1 and print "\nget_token starting up on $self.\n";DEBUG > 2 and print " Items in token-buffer (",scalar(@{$self->{'token_buffer'}}),") :\n",map("    " .$_->dump ."\n",@{$self->{'token_buffer'}}),@{$self->{'token_buffer'}}? '' : '       (no tokens)',"\n" ;until(@{$self->{'token_buffer'}}){DEBUG > 3 and print "I need to get something into my empty token buffer...\n";if($self->{'source_dead'}){DEBUG and print "$self 's source is dead.\n";push @{$self->{'token_buffer'}},undef}elsif(exists$self->{'source_fh'}){my@lines;my$fh=$self->{'source_fh'}|| Carp::croak('You have to call set_source before you can call get_token');DEBUG and print "$self 's source is filehandle $fh.\n";for(my$i=Pod::Simple::MANY_LINES;$i--;){DEBUG > 3 and print " Fetching a line from source filehandle $fh...\n";local $/=$Pod::Simple::NL;push@lines,scalar(<$fh>);DEBUG > 3 and print "  Line is: ",defined($lines[-1])? $lines[-1]: "<undef>\n";unless(defined$lines[-1]){DEBUG and print "That's it for that source fh!  Killing.\n";delete$self->{'source_fh'};last}}if(DEBUG > 8){print "* I've gotten ",scalar(@lines)," lines:\n";for my$l (@lines){if(defined$l){print "  line {$l}\n"}else {print "  line undef\n"}}print "* end of ",scalar(@lines)," lines\n"}$self->SUPER::parse_lines(@lines)}elsif(exists$self->{'source_arrayref'}){DEBUG and print "$self 's source is arrayref $self->{'source_arrayref'}, with ",scalar(@{$self->{'source_arrayref'}})," items left in it.\n";DEBUG > 3 and print "  Fetching ",Pod::Simple::MANY_LINES," lines.\n";$self->SUPER::parse_lines(splice @{$self->{'source_arrayref'}},0,Pod::Simple::MANY_LINES);unless(@{$self->{'source_arrayref'}}){DEBUG and print "That's it for that source arrayref!  Killing.\n";$self->SUPER::parse_lines(undef);delete$self->{'source_arrayref'}}}elsif(exists$self->{'source_scalar_ref'}){DEBUG and print "$self 's source is scalarref $self->{'source_scalar_ref'}, with ",length(${$self->{'source_scalar_ref'}})- (pos(${$self->{'source_scalar_ref'}})|| 0)," characters left to parse.\n";DEBUG > 3 and print " Fetching a line from source-string...\n";if(${$self->{'source_scalar_ref'}}=~ m/([^\n\r]*)((?:\r?\n)?)/g){$self->SUPER::parse_lines($1)if length($1)or length($2)or pos(${$self->{'source_scalar_ref'}})!=length(${$self->{'source_scalar_ref'}})}else {$self->SUPER::parse_lines(undef);delete$self->{'source_scalar_ref'};DEBUG and print "That's it for that source scalarref!  Killing.\n"}}else {die "What source??"}}DEBUG and print "get_token about to return ",Pod::Simple::pretty(@{$self->{'token_buffer'}}? $self->{'token_buffer'}[-1]: undef),"\n";return shift @{$self->{'token_buffer'}}}sub unget_token {my$self=shift;DEBUG and print "Ungetting ",scalar(@_)," tokens: ",@_ ? "@_\n" : "().\n";for my$t (@_){Carp::croak "Can't unget that, because it's not a token -- it's undef!" unless defined$t;Carp::croak "Can't unget $t, because it's not a token -- it's a string!" unless ref$t;Carp::croak "Can't unget $t, because it's not a token object!" unless UNIVERSAL::can($t,'type')}unshift @{$self->{'token_buffer'}},@_;DEBUG > 1 and print "Token buffer now has ",scalar(@{$self->{'token_buffer'}})," items in it.\n";return}sub set_source {my$self=shift @_;return$self->{'source_fh'}unless @_;Carp::croak("Cannot assign new source to pull parser; create a new instance, instead")if$self->{'source_fh'}|| $self->{'source_scalar_ref'}|| $self->{'source_arrayref'};my$handle;if(!defined $_[0]){Carp::croak("Can't use empty-string as a source for set_source")}elsif(ref(\($_[0]))eq 'GLOB'){$self->{'source_filename'}='' .($handle=$_[0]);DEBUG and print "$self 's source is glob $_[0]\n"}elsif(ref($_[0])eq 'SCALAR'){$self->{'source_scalar_ref'}=$_[0];DEBUG and print "$self 's source is scalar ref $_[0]\n";return}elsif(ref($_[0])eq 'ARRAY'){$self->{'source_arrayref'}=$_[0];DEBUG and print "$self 's source is array ref $_[0]\n";return}elsif(ref $_[0]){$self->{'source_filename'}='' .($handle=$_[0]);DEBUG and print "$self 's source is fh-obj $_[0]\n"}elsif(!length $_[0]){Carp::croak("Can't use empty-string as a source for set_source")}else {DEBUG and print "$self 's source is filename $_[0]\n";{local*PODSOURCE;open(PODSOURCE,"<$_[0]")|| Carp::croak "Can't open $_[0]: $!";$handle=*PODSOURCE{IO}}$self->{'source_filename'}=$_[0];DEBUG and print "  Its name is $_[0].\n"}$self->{'source_fh'}=$handle;DEBUG and print "  Its handle is $handle\n";return 1}sub get_title_short {shift->get_short_title(@_)}sub get_short_title {my$title=shift->get_title(@_);$title=$1 if$title =~ m/^(\S{1,60})\s+--?\s+./s;return$title}sub get_title {shift->_get_titled_section('NAME',max_token=>50,desperate=>1,@_)}sub get_version {shift->_get_titled_section('VERSION',max_token=>400,accept_verbatim=>1,max_content_length=>3_000,@_,)}sub get_description {shift->_get_titled_section('DESCRIPTION',max_token=>400,max_content_length=>3_000,@_,)}sub get_authors {shift->get_author(@_)}sub get_author {my$this=shift;$this->_get_titled_section('AUTHOR',max_token=>10_000,@_)|| $this->_get_titled_section('AUTHORS',max_token=>10_000,@_)}sub _get_titled_section {my($self,$titlename,%options)=(@_);my$max_token=delete$options{'max_token'};my$desperate_for_title=delete$options{'desperate'};my$accept_verbatim=delete$options{'accept_verbatim'};my$max_content_length=delete$options{'max_content_length'};my$nocase=delete$options{'nocase'};$max_content_length=120 unless defined$max_content_length;Carp::croak("Unknown " .((1==keys%options)? "option: " : "options: ").join " ",map "[$_]",sort keys%options)if keys%options;my%content_containers;$content_containers{'Para'}=1;if($accept_verbatim){$content_containers{'Verbatim'}=1;$content_containers{'VerbatimFormatted'}=1}my$token_count=0;my$title;my@to_unget;my$state=0;my$depth=0;Carp::croak "What kind of titlename is \"$titlename\"?!" unless defined$titlename and $titlename =~ m/^[A-Z ]{1,60}$/s;my$titlename_re=quotemeta($titlename);my$head1_text_content;my$para_text_content;my$skipX;while(++$token_count <= ($max_token || 1_000_000)and defined(my$token=$self->get_token)){push@to_unget,$token;if ($state==0){if($token->is_start and $token->tagname eq 'head1'){DEBUG and print "  Found head1.  Seeking content...\n";++$state;$head1_text_content=''}}elsif($state==1){if($token->is_text){unless ($skipX){DEBUG and print "   Adding \"",$token->text,"\" to head1-content.\n";$head1_text_content .= $token->text}}elsif($token->is_tagname('X')){$skipX=$token->is_start;DEBUG and print +($skipX ? 'Start' : 'End'),'ing ignoring of X<> tag'}elsif($token->is_end and $token->tagname eq 'head1'){DEBUG and print "  Found end of head1.  Considering content...\n";$head1_text_content=uc$head1_text_content if$nocase;if($head1_text_content eq $titlename or $head1_text_content =~ m/\($titlename_re\)/s){DEBUG and print "  Yup, it was $titlename.  Seeking next para-content...\n";++$state}elsif($desperate_for_title and $head1_text_content =~ m/\S/ and $head1_text_content !~ m/^[ A-Z]+$/s and $head1_text_content !~ m/\((?:
               NAME | TITLE | VERSION | AUTHORS? | DESCRIPTION | SYNOPSIS
               | COPYRIGHT | LICENSE | NOTES? | FUNCTIONS? | METHODS?
               | CAVEATS? | BUGS? | SEE\ ALSO | SWITCHES | ENVIRONMENT
              )\)/sx and ($max_content_length ? (length($head1_text_content)<= $max_content_length): 1)){($title=$head1_text_content)=~ s/\s+$//;DEBUG and print "  It looks titular: \"$title\".\n\n  Using that.\n";last}else {--$state;DEBUG and print "  Didn't look titular ($head1_text_content).\n","\n  Dropping back to seeking-head1-content mode...\n"}}}elsif($state==2){if($token->is_start and $content_containers{$token->tagname }){DEBUG and print "  Found start of Para.  Accumulating content...\n";$para_text_content='';++$state}else {DEBUG and print "  Didn't see an immediately subsequent start-Para.  Reseeking H1\n";$state=0}}elsif($state==3){if($token->is_text){DEBUG and print "   Adding \"",$token->text,"\" to para-content.\n";$para_text_content .= $token->text}elsif($token->is_end and $content_containers{$token->tagname }){DEBUG and print "  Found end of Para.  Considering content: ",$para_text_content,"\n";if($para_text_content =~ m/\S/ and ($max_content_length ? (length($para_text_content)<= $max_content_length): 1)){DEBUG and print "  It looks contentworthy, I guess.  Using it.\n";$title=$para_text_content;last}else {DEBUG and print "  Doesn't look at all contentworthy!\n  Giving up.\n";undef$title;last}}}else {die "IMPOSSIBLE STATE $state!\n"}}$self->unget_token(@to_unget);if(DEBUG){if(defined$title){print "  Returning title <$title>\n"}else {print "Returning title <>\n"}}return '' unless defined$title;$title =~ s/^\s+//;return$title}sub _handle_element_start {my$self=shift;DEBUG > 2 and print "++ $_[0] (",map("<$_> ",%{$_[1]}),")\n";push @{$self->{'token_buffer'}},$self->{'start_token_class'}->new(@_);return}sub _handle_text {my$self=shift;DEBUG > 2 and print "== $_[0]\n";push @{$self->{'token_buffer'}},$self->{'text_token_class'}->new(@_);return}sub _handle_element_end {my$self=shift;DEBUG > 2 and print "-- $_[0]\n";push @{$self->{'token_buffer'}},$self->{'end_token_class'}->new(@_);return}1;
POD_SIMPLE_PULLPARSER

$fatpacked{"Pod/Simple/PullParserEndToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERENDTOKEN';
  require 5;package Pod::Simple::PullParserEndToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.28';sub new {my$class=shift;return bless ['end',@_],ref($class)|| $class}sub tagname {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub tag {shift->tagname(@_)}sub is_tagname {$_[0][1]eq $_[1]}sub is_tag {shift->is_tagname(@_)}1;
POD_SIMPLE_PULLPARSERENDTOKEN

$fatpacked{"Pod/Simple/PullParserStartToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERSTARTTOKEN';
  require 5;package Pod::Simple::PullParserStartToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.28';sub new {my$class=shift;return bless ['start',@_],ref($class)|| $class}sub tagname {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub tag {shift->tagname(@_)}sub is_tagname {$_[0][1]eq $_[1]}sub is_tag {shift->is_tagname(@_)}sub attr_hash {$_[0][2]||={}}sub attr {if(@_==2){${$_[0][2]|| return undef}{$_[1]}}elsif(@_ > 2){${$_[0][2]||={}}{$_[1]}=$_[2]}else {require Carp;Carp::croak('usage: $object->attr("val") or $object->attr("key", "newval")');return undef}}1;
POD_SIMPLE_PULLPARSERSTARTTOKEN

$fatpacked{"Pod/Simple/PullParserTextToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTEXTTOKEN';
  require 5;package Pod::Simple::PullParserTextToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.28';sub new {my$class=shift;return bless ['text',@_],ref($class)|| $class}sub text {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub text_r {\ $_[0][1]}1;
POD_SIMPLE_PULLPARSERTEXTTOKEN

$fatpacked{"Pod/Simple/PullParserToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTOKEN';
  require 5;package Pod::Simple::PullParserToken;@ISA=();$VERSION='3.28';use strict;sub new {my$class=shift;return bless [@_],ref($class)|| $class}sub type {$_[0][0]}sub dump {Pod::Simple::pretty([@{$_[0]}])}sub is_start {$_[0][0]eq 'start'}sub is_end {$_[0][0]eq 'end'}sub is_text {$_[0][0]eq 'text'}1;
POD_SIMPLE_PULLPARSERTOKEN

$fatpacked{"Pod/Simple/RTF.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_RTF';
  require 5;package Pod::Simple::RTF;use strict;use vars qw($VERSION @ISA %Escape $WRAP %Tagmap);$VERSION='3.28';use Pod::Simple::PullParser ();BEGIN {@ISA=('Pod::Simple::PullParser')}use Carp ();BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}$WRAP=1 unless defined$WRAP;sub _openclose {return map {;m/^([-A-Za-z]+)=(\w[^\=]*)$/s or die "what's <$_>?";($1,"{\\$2\n","/$1","}")}@_}my@_to_accept;%Tagmap=(_openclose('B=cs18\b','I=cs16\i','C=cs19\f1\lang1024\noproof','F=cs17\i\lang1024\noproof','VerbatimI=cs26\i','VerbatimB=cs27\b','VerbatimBI=cs28\b\i',map {;m/^([-a-z]+)/s && push@_to_accept,$1;$_}qw[underline=ul smallcaps=scaps shadow=shad superscript=super subscript=sub strikethrough=strike outline=outl emboss=embo engrave=impr dotted-underline=uld dash-underline=uldash dot-dash-underline=uldashd dot-dot-dash-underline=uldashdd double-underline=uldb thick-underline=ulth word-underline=ulw wave-underline=ulwave]),'L=pod'=>'{\cs22\i'."\n",'L=url'=>'{\cs23\i'."\n",'L=man'=>'{\cs24\i'."\n",'/L'=>'}','Data'=>"\n",'/Data'=>"\n",'Verbatim'=>"\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",'/Verbatim'=>"\n\\par}\n",'VerbatimFormatted'=>"\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",'/VerbatimFormatted'=>"\n\\par}\n",'Para'=>"\n{\\pard\\li#rtfindent#\\sa180\n",'/Para'=>"\n\\par}\n",'head1'=>"\n{\\pard\\li#rtfindent#\\s31\\keepn\\sb90\\sa180\\f2\\fs#head1_halfpoint_size#\\ul{\n",'/head1'=>"\n}\\par}\n",'head2'=>"\n{\\pard\\li#rtfindent#\\s32\\keepn\\sb90\\sa180\\f2\\fs#head2_halfpoint_size#\\ul{\n",'/head2'=>"\n}\\par}\n",'head3'=>"\n{\\pard\\li#rtfindent#\\s33\\keepn\\sb90\\sa180\\f2\\fs#head3_halfpoint_size#\\ul{\n",'/head3'=>"\n}\\par}\n",'head4'=>"\n{\\pard\\li#rtfindent#\\s34\\keepn\\sb90\\sa180\\f2\\fs#head4_halfpoint_size#\\ul{\n",'/head4'=>"\n}\\par}\n",'item-bullet'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-bullet'=>"\n\\par}\n",'item-number'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-number'=>"\n\\par}\n",'item-text'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-text'=>"\n\\par}\n",);sub new {my$new=shift->SUPER::new(@_);$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->accept_targets('rtf','RTF');$new->{'Tagmap'}={%Tagmap};$new->accept_codes(@_to_accept);$new->accept_codes('VerbatimFormatted');DEBUG > 2 and print "To accept: ",join(' ',@_to_accept),"\n";$new->doc_lang(($ENV{'RTFDEFLANG'}|| '')=~ m/^(\d{1,10})$/s ? $1 : ($ENV{'RTFDEFLANG'}|| '')=~ m/^0?x([a-fA-F0-9]{1,10})$/s ? hex($1): ($ENV{'RTFDEFLANG'}|| '')=~ m/^([a-fA-F0-9]{4})$/s ? hex($1): '1033');$new->head1_halfpoint_size(32);$new->head2_halfpoint_size(28);$new->head3_halfpoint_size(25);$new->head4_halfpoint_size(22);$new->codeblock_halfpoint_size(18);$new->header_halfpoint_size(17);$new->normal_halfpoint_size(25);return$new}__PACKAGE__->_accessorize('doc_lang','head1_halfpoint_size','head2_halfpoint_size','head3_halfpoint_size','head4_halfpoint_size','codeblock_halfpoint_size','header_halfpoint_size','normal_halfpoint_size','no_proofing_exemptions',);sub run {my$self=$_[0];return$self->do_middle if$self->bare_output;return $self->do_beginning && $self->do_middle && $self->do_end}sub do_middle {my$self=$_[0];my$fh=$self->{'output_fh'};my($token,$type,$tagname,$scratch);my@stack;my@indent_stack;$self->{'rtfindent'}=0 unless defined$self->{'rtfindent'};while($token=$self->get_token){if(($type=$token->type)eq 'text'){if($self->{'rtfverbatim'}){DEBUG > 1 and print "  $type ",$token->text," in verbatim!\n";rtf_esc_codely($scratch=$token->text);print$fh $scratch;next}DEBUG > 1 and print "  $type ",$token->text,"\n";$scratch=$token->text;$scratch =~ tr/\t\cb\cc/ /d;$self->{'no_proofing_exemptions'}or $scratch =~ s/(?:
             ^
             |
             (?<=[\cm\cj\t "\[\<\(])
           )   # start on whitespace, sequence-start, or quote
           ( # something looking like a Perl token:
            (?:
             [\$\@\:\<\*\\_]\S+  # either starting with a sigil, etc.
            )
            |
            # or starting alpha, but containing anything strange:
            (?:
             [a-zA-Z'\x80-\xFF]+[\$\@\:_<>\(\\\*]\S+
            )
           )
          /\cb$1\cc/xsg ;rtf_esc($scratch);$scratch =~ s/(
              [^\cm\cj\n]{65}        # Snare 65 characters from a line
              [^\cm\cj\n\x20]{0,50}  #  and finish any current word
             )
             (\x20{1,10})(?![\cm\cj\n]) # capture some spaces not at line-end
            /$1$2\n/gx if$WRAP;print$fh $scratch}elsif($type eq 'start'){DEBUG > 1 and print "  +$type ",$token->tagname," (",map("<$_> ",%{$token->attr_hash}),")\n";if(($tagname=$token->tagname)eq 'Verbatim' or $tagname eq 'VerbatimFormatted'){++$self->{'rtfverbatim'};my$next=$self->get_token;next unless defined$next;my$line_count=1;if($next->type eq 'text'){my$t=$next->text_r;while($$t =~ m/$/mg){last if ++$line_count > 15}DEBUG > 3 and print "    verbatim line count: $line_count\n"}$self->unget_token($next);$self->{'rtfkeep'}=($line_count > 15)? '' : '\keepn' }elsif($tagname =~ m/^item-/s){my@to_unget;my$text_count_here=0;$self->{'rtfitemkeepn'}='';while(1){push@to_unget,$self->get_token;pop(@to_unget),last unless defined$to_unget[-1];if($to_unget[-1]->type eq 'text'){if(($text_count_here += length ${$to_unget[-1]->text_r})> 150){DEBUG > 1 and print "    item-* is too long to be keepn'd.\n";last}}elsif (@to_unget > 1 and $to_unget[-2]->type eq 'end' and $to_unget[-2]->tagname =~ m/^item-/s){$self->{'rtfitemkeepn'}='\keepn' if $to_unget[-1]->type eq 'start' and $to_unget[-1]->tagname eq 'Para';DEBUG > 1 and printf "    item-* before %s(%s) %s keepn'd.\n",$to_unget[-1]->type,$to_unget[-1]->can('tagname')? $to_unget[-1]->tagname : '',$self->{'rtfitemkeepn'}? "gets" : "doesn't get";last}elsif (@to_unget > 40){DEBUG > 1 and print "    item-* now has too many tokens (",scalar(@to_unget),(DEBUG > 4)? (q<: >,map($_->dump,@to_unget)): (),") to be keepn'd.\n";last}}$self->unget_token(@to_unget)}elsif($tagname =~ m/^over-/s){push@stack,$1;push@indent_stack,int($token->attr('indent')* 4 * $self->normal_halfpoint_size);DEBUG and print "Indenting over $indent_stack[-1] twips.\n";$self->{'rtfindent'}+= $indent_stack[-1]}elsif ($tagname eq 'L'){$tagname .= '=' .($token->attr('type')|| 'pod')}elsif ($tagname eq 'Data'){my$next=$self->get_token;next unless defined$next;unless($next->type eq 'text'){$self->unget_token($next);next}DEBUG and print "    raw text ",$next->text,"\n";printf$fh "\n" .$next->text ."\n";next}defined($scratch=$self->{'Tagmap'}{$tagname})or next;$scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g;print$fh $scratch;if ($tagname eq 'item-number'){print$fh $token->attr('number'),". \n"}elsif ($tagname eq 'item-bullet'){print$fh "\\'95 \n"}}elsif($type eq 'end'){DEBUG > 1 and print "  -$type ",$token->tagname,"\n";if(($tagname=$token->tagname)=~ m/^over-/s){DEBUG and print "Indenting back $indent_stack[-1] twips.\n";$self->{'rtfindent'}-= pop@indent_stack;pop@stack}elsif($tagname eq 'Verbatim' or $tagname eq 'VerbatimFormatted'){--$self->{'rtfverbatim'}}defined($scratch=$self->{'Tagmap'}{"/$tagname"})or next;$scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g;print$fh $scratch}}return 1}sub do_beginning {my$self=$_[0];my$fh=$self->{'output_fh'};return print$fh join '',$self->doc_init,$self->font_table,$self->stylesheet,$self->color_table,$self->doc_info,$self->doc_start,"\n" }sub do_end {my$self=$_[0];my$fh=$self->{'output_fh'};return print$fh '}'}sub stylesheet {return sprintf <<'END',$_[0]->codeblock_halfpoint_size(),$_[0]->head1_halfpoint_size(),$_[0]->head2_halfpoint_size(),$_[0]->head3_halfpoint_size(),$_[0]->head4_halfpoint_size(),}sub font_table {return <<'END'}sub doc_init {return <<'END'}sub color_table {return <<'END'}sub doc_info {my$self=$_[0];my$class=ref($self)|| $self;my$tag=__PACKAGE__ .' ' .$VERSION;unless($class eq __PACKAGE__){$tag=" ($tag)";$tag=" v" .$self->VERSION .$tag if defined$self->VERSION;$tag=$class .$tag}return sprintf <<'END',$tag,$ISA[0],$ISA[0]->VERSION(),$],scalar(gmtime),}sub doc_start {my$self=$_[0];my$title=$self->get_short_title();DEBUG and print "Short Title: <$title>\n";$title .= ' ' if length$title;$title =~ s/ *$/ /s;$title =~ s/^ //s;$title =~ s/ $/, /s;my$is_obviously_module_name;$is_obviously_module_name=1 if$title =~ m/^\S+$/s and $title =~ m/::/s;DEBUG and print "Title0: <$title>\n";$title=rtf_esc($title);DEBUG and print "Title1: <$title>\n";$title='\lang1024\noproof ' .$title if$is_obviously_module_name;return sprintf <<'END',($self->doc_lang)x 2,$self->header_halfpoint_size,$title,$self->normal_halfpoint_size,}use integer;sub rtf_esc {my$x;if(!defined wantarray){for(@_){s/([F\x00-\x1F\-\\\{\}\x7F-\xFF])/$Escape{$1}/g;s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg}return}elsif(wantarray){return map {;($x=$_)=~ s/([F\x00-\x1F\-\\\{\}\x7F-\xFF])/$Escape{$1}/g;$x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;$x}@_}else {($x=((@_==1)? $_[0]: join '',@_))=~ s/([F\x00-\x1F\-\\\{\}\x7F-\xFF])/$Escape{$1}/g;$x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;return$x}}sub rtf_esc_codely {my$x;if(!defined wantarray){for(@_){s/([F\x00-\x1F\\\{\}\x7F-\xFF])/$Escape{$1}/g;s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg}return}elsif(wantarray){return map {;($x=$_)=~ s/([F\x00-\x1F\\\{\}\x7F-\xFF])/$Escape{$1}/g;$x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;$x}@_}else {($x=((@_==1)? $_[0]: join '',@_))=~ s/([F\x00-\x1F\\\{\}\x7F-\xFF])/$Escape{$1}/g;$x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;return$x}}%Escape=(map((chr($_),chr($_)),0x20 .. 0x7E),map((chr($_),sprintf("\\'%02x",$_)),0x00 .. 0x1F,0x5c,0x7b,0x7d,0x7f .. 0xFF,0x46),"\cm"=>"\n","\cj"=>"\n","\n"=>"\n\\line ","\t"=>"\\tab ","\f"=>"\n\\page\n","-"=>"\\_","\xA0"=>"\\~","\xAD"=>"\\-","\n"=>"\\line\n","\r"=>"\n","\cb"=>"{\n\\cs21\\lang1024\\noproof ","\cc"=>"}",);1;
  {\stylesheet
  {\snext0 Normal;}
  {\*\cs10 \additive Default Paragraph Font;}
  {\*\cs16 \additive \i \sbasedon10 pod-I;}
  {\*\cs17 \additive \i\lang1024\noproof \sbasedon10 pod-F;}
  {\*\cs18 \additive \b \sbasedon10 pod-B;}
  {\*\cs19 \additive \f1\lang1024\noproof\sbasedon10 pod-C;}
  {\s20\ql \li0\ri0\sa180\widctlpar\f1\fs%s\lang1024\noproof\sbasedon0 \snext0 pod-codeblock;}
  {\*\cs21 \additive \lang1024\noproof \sbasedon10 pod-computerese;}
  {\*\cs22 \additive \i\lang1024\noproof\sbasedon10 pod-L-pod;}
  {\*\cs23 \additive \i\lang1024\noproof\sbasedon10 pod-L-url;}
  {\*\cs24 \additive \i\lang1024\noproof\sbasedon10 pod-L-man;}
  
  {\*\cs25 \additive \f1\lang1024\noproof\sbasedon0 pod-codelbock-plain;}
  {\*\cs26 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-ital;}
  {\*\cs27 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold;}
  {\*\cs28 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold-ital;}
  
  {\s31\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head1;}
  {\s32\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head2;}
  {\s33\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head3;}
  {\s34\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head4;}
  }
  
  END
  {\fonttbl
  {\f0\froman Times New Roman;}
  {\f1\fmodern Courier New;}
  {\f2\fswiss Arial;}
  }
  
  END
  {\rtf1\ansi\deff0
  
  END
  {\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
  END
  {\info{\doccomm
  %s
   using %s v%s
   under Perl v%s at %s GMT}
  {\author [see doc]}{\company [see doc]}{\operator [see doc]}
  }
  
  END
  \deflang%s\plain\lang%s\widowctrl
  {\header\pard\qr\plain\f2\fs%s
  %s
  p.\chpgn\par}
  \fs%s
  
  END
POD_SIMPLE_RTF

$fatpacked{"Pod/Simple/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SEARCH';
  require 5.005;package Pod::Simple::Search;use strict;use vars qw($VERSION $MAX_VERSION_WITHIN $SLEEPY);$VERSION='3.28';BEGIN {*DEBUG=sub () {0}unless defined&DEBUG}use Carp ();$SLEEPY=1 if!defined$SLEEPY and $^O =~ /mswin|mac/i;$MAX_VERSION_WITHIN ||=60;use File::Spec ();use File::Basename qw(basename);use Config ();use Cwd qw(cwd);__PACKAGE__->_accessorize('callback','progress','dir_prefix','inc','laborious','limit_glob','limit_re','shadows','verbose','name2path','path2name','recurse',);sub new {my$class=shift;my$self=bless {},ref($class)|| $class;$self->init;return$self}sub init {my$self=shift;$self->inc(1);$self->recurse(1);$self->verbose(DEBUG);return$self}sub survey {my($self,@search_dirs)=@_;$self=$self->new unless ref$self;$self->_expand_inc(\@search_dirs);$self->{'_scan_count'}=0;$self->{'_dirs_visited'}={};$self->path2name({});$self->name2path({});$self->limit_re($self->_limit_glob_to_limit_re)if$self->{'limit_glob'};my$cwd=cwd();my$verbose=$self->verbose;local $_;for my$try (@search_dirs){unless(File::Spec->file_name_is_absolute($try)){$try=File::Spec->catfile($cwd,$try)}$try=File::Spec->canonpath($try);my$start_in;my$modname_prefix;if($self->{'dir_prefix'}){$start_in=File::Spec->catdir($try,grep length($_),split '[\\/:]+',$self->{'dir_prefix'});$modname_prefix=[grep length($_),split m{[:/\\]},$self->{'dir_prefix'}];$verbose and print "Appending \"$self->{'dir_prefix'}\" to $try, ","giving $start_in (= @$modname_prefix)\n"}else {$start_in=$try}if($self->{'_dirs_visited'}{$start_in}){$verbose and print "Directory '$start_in' already seen, skipping.\n";next}else {$self->{'_dirs_visited'}{$start_in}=1}unless(-e $start_in){$verbose and print "Skipping non-existent $start_in\n";next}my$closure=$self->_make_search_callback;if(-d $start_in){$verbose and print "Beginning excursion under $start_in\n";$self->_recurse_dir($start_in,$closure,$modname_prefix);$verbose and print "Back from excursion under $start_in\n\n"}elsif(-f _){$_=basename($start_in);$verbose and print "Pondering $start_in ($_)\n";$closure->($start_in,$_,0,[])}else {$verbose and print "Skipping mysterious $start_in\n"}}$self->progress and $self->progress->done("Noted $$self{'_scan_count'} Pod files total");return unless defined wantarray;return$self->name2path unless wantarray;return$self->name2path,$self->path2name}sub _make_search_callback {my$self=$_[0];my($laborious,$verbose,$shadows,$limit_re,$callback,$progress,$path2name,$name2path,$recurse)=map scalar($self->$_()),qw(laborious verbose shadows limit_re callback progress path2name name2path recurse);my($file,$shortname,$isdir,$modname_bits);return sub {($file,$shortname,$isdir,$modname_bits)=@_;if($isdir){unless($recurse){$verbose and print "Not recursing into '$file' as per requested.\n";return 'PRUNE'}if($self->{'_dirs_visited'}{$file}){$verbose and print "Directory '$file' already seen, skipping.\n";return 'PRUNE'}print "Looking in dir $file\n" if$verbose;unless ($laborious){if(m/^(\d+\.[\d_]{3,})\z/s and do {my$x=$1;$x =~ tr/_//d;$x!=$]}){$verbose and print "Perl $] version mismatch on $_, skipping.\n";return 'PRUNE'}if(m/^([A-Za-z][a-zA-Z0-9_]*)\z/s){$verbose and print "$_ is a well-named module subdir.  Looking....\n"}else {$verbose and print "$_ is a fishy directory name.  Skipping.\n";return 'PRUNE'}}$self->{'_dirs_visited'}{$file}=1;return}if($laborious){unless(m/\.(pod|pm|plx?)\z/i || -x _ and -T _){$verbose > 1 and print " Brushing off uninteresting $file\n";return}}else {unless(m/^[-_a-zA-Z0-9]+\.(?:pod|pm|plx?)\z/is){$verbose > 1 and print " Brushing off oddly-named $file\n";return}}$verbose and print "Considering item $file\n";my$name=$self->_path2modname($file,$shortname,$modname_bits);$verbose > 0.01 and print " Nominating $file as $name\n";if($limit_re and $name !~ m/$limit_re/i){$verbose and print "Shunning $name as not matching $limit_re\n";return}if(!$shadows and $name2path->{$name}){$verbose and print "Not worth considering $file ","-- already saw $name as ",join(' ',grep($path2name->{$_}eq $name,keys %$path2name)),"\n";return}if(m/\.pod\z/is){}else {$progress and $progress->reach($self->{'_scan_count'},"Scanning $file");return unless$self->contains_pod($file)}++ $self->{'_scan_count'};if($name2path->{$name}){$verbose and print "Duplicate POD found (shadowing?): $name ($file)\n","    Already seen in ",join(' ',grep($path2name->{$_}eq $name,keys %$path2name)),"\n"}else {$name2path->{$name}=$file}$verbose and print "  Noting $name = $file\n";if($callback){local $_=$_;$callback->($file,$name)}$path2name->{$file}=$name;return}}sub _path2modname {my($self,$file,$shortname,$modname_bits)=@_;my@m=@$modname_bits;my$x;my$verbose=$self->verbose;while(@m and defined($x=lc($m[0]))and($x eq 'site_perl' or($x eq 'pod' and @m==1 and $shortname =~ m{^perl.*\.pod$}s)or $x =~ m{\\d+\\.z\\d+([_.]?\\d+)?} or $x eq lc($Config::Config{'archname'}))){shift@m}my$name=join '::',@m,$shortname;$self->_simplify_base($name);if ($^O eq 'VMS' && ($name eq lc($name)|| $name eq uc($name))){open PODFILE,"<$file" or die "_path2modname: Can't open $file: $!";my$in_pod=0;my$in_name=0;my$line;while ($line=<PODFILE>){chomp$line;$in_pod=1 if ($line =~ m/^=\w/);$in_pod=0 if ($line =~ m/^=cut/);next unless$in_pod;next if ($line =~ m/^\s*\z/);next if ($in_pod && ($line =~ m/^X</));if ($in_name){if ($line =~ m/(\w+::)?(\w+)/){my$podname=$2;my$prefix=$1 || '';$verbose and print "Attempting case restore of '$name' from '$prefix$podname'\n";unless ($name =~ s/$prefix$podname/$prefix$podname/i){$verbose and print "Attempting case restore of '$name' from '$podname'\n";$name =~ s/$podname/$podname/i}last}}$in_name=1 if ($line =~ m/^=head1 NAME/)}close PODFILE}return$name}sub _recurse_dir {my($self,$startdir,$callback,$modname_bits)=@_;my$maxdepth=$self->{'fs_recursion_maxdepth'}|| 10;my$verbose=$self->verbose;my$here_string=File::Spec->curdir;my$up_string=File::Spec->updir;$modname_bits ||=[];my$recursor;$recursor=sub {my($dir_long,$dir_bare)=@_;if(@$modname_bits >= 10){$verbose and print "Too deep! [@$modname_bits]\n";return}unless(-d $dir_long){$verbose > 2 and print "But it's not a dir! $dir_long\n";return}unless(opendir(INDIR,$dir_long)){$verbose > 2 and print "Can't opendir $dir_long : $!\n";closedir(INDIR);return}my@items=sort readdir(INDIR);closedir(INDIR);push @$modname_bits,$dir_bare unless$dir_bare eq '';my$i_full;for my$i (@items){next if$i eq $here_string or $i eq $up_string or $i eq '';$i_full=File::Spec->catfile($dir_long,$i);if(!-r $i_full){$verbose and print "Skipping unreadable $i_full\n"}elsif(-f $i_full){$_=$i;$callback->($i_full,$i,0,$modname_bits)}elsif(-d _){$i =~ s/\.DIR\z//i if $^O eq 'VMS';$_=$i;my$rv=$callback->($i_full,$i,1,$modname_bits)|| '';if($rv eq 'PRUNE'){$verbose > 1 and print "OK, pruning"}else {$recursor->(File::Spec->catdir($dir_long,$i),$i)}}else {$verbose > 1 and print "Skipping oddity $i_full\n"}}pop @$modname_bits;return};;local $_;$recursor->($startdir,'');undef$recursor;return}sub run {my$self=__PACKAGE__->new;$self->limit_glob($ARGV[0])if@ARGV;$self->callback(sub {my($file,$name)=@_;my$version='';if($file =~ m/\.pod$/i){DEBUG and print "Not looking for \$VERSION in .pod $file\n"}elsif(!open(INPOD,$file)){DEBUG and print "Couldn't open $file: $!\n";close(INPOD)}else {my$lines=0;while(<INPOD>){last if$lines++ > $MAX_VERSION_WITHIN;if(s/^\s*\$VERSION\s*=\s*//s and m/\d/){DEBUG and print "Found version line (#$lines): $_";s/\s*\#.*//s;s/\;\s*$//s;s/\s+$//s;s/\t+/ /s;$_="v$1" if m{^v?["']?([0-9_]+(\.[0-9_]+)*)["']?$}s or m{\$Revision:\s*([0-9_]+(?:\.[0-9_]+)*)\s*\$}s ;$_=sprintf("v%d.%s",map {s/_//g;$_}$1 =~ m/-(\d+)_([\d_]+)/)if m{\$Name:\s*([^\$]+)\$}s ;$version=$_;DEBUG and print "Noting $version as version\n";last}}close(INPOD)}print "$name\t$version\t$file\n";return});$self->survey}sub simplify_name {my($self,$str)=@_;if ($^O eq 'MacOS'){$str =~ s{^.*:+}{}s}else {$str =~ s{^.*/+}{}s}$self->_simplify_base($str);return$str}sub _simplify_base {$_[1]=~ s/\.(pod|pm|plx?)\z//i;$_[1]=~ s/\.(bat|exe|cmd)\z//i if $^O =~ /mswin|os2/i;$_[1]=~ s/\.(com)\z//i if $^O eq 'VMS';return}sub _expand_inc {my($self,$search_dirs)=@_;return unless$self->{'inc'};if ($^O eq 'MacOS'){push @$search_dirs,grep $_ ne File::Spec->curdir,$self->_mac_whammy(@INC)}else {push @$search_dirs,grep $_ ne File::Spec->curdir,@INC}$self->{'laborious'}=0;return}sub _mac_whammy {my@them;(undef,@them)=@_;for $_ (@them){if ($_ eq '.'){$_=':'}elsif ($_ =~ s|^((?:\.\./)+)|':' x (length($1)/3)|e){$_=':'.$_}else {$_ =~ s|^\./|:|}}return@them}sub _limit_glob_to_limit_re {my$self=$_[0];my$limit_glob=$self->{'limit_glob'}|| return;my$limit_re='^' .quotemeta($limit_glob).'$';$limit_re =~ s/\\\?/./g;$limit_re =~ s/\\\*/.*?/g;$limit_re =~ s/\.\*\?\$$//s;$self->{'verbose'}and print "Turning limit_glob $limit_glob into re $limit_re\n";if(!exists($self->{'dir_prefix'})and $limit_glob =~ m/^(?:\w+\:\:)+/s){$self->{'dir_prefix'}=join "::",$limit_glob =~ m/^(?:\w+::)+/sg;$self->{'verbose'}and print " and setting dir_prefix to $self->{'dir_prefix'}\n"}return$limit_re}sub find {my($self,$pod,@search_dirs)=@_;$self=$self->new unless ref$self;Carp::carp 'Usage: \$self->find($podname, ...)' unless defined$pod and length$pod;my$verbose=$self->verbose;my@parts=split /::/,$pod;$verbose and print "Chomping {$pod} => {@parts}\n";if($self->inc){if($^O eq 'MacOS'){push@search_dirs,$self->_mac_whammy(@INC)}else {push@search_dirs,@INC}push@search_dirs,$Config::Config{'scriptdir'}}my%seen_dir;Dir: foreach my$dir (@search_dirs){next unless defined$dir and length$dir;next if$seen_dir{$dir};$seen_dir{$dir}=1;unless(-d $dir){print "Directory $dir does not exist\n" if$verbose;next Dir}print "Looking in directory $dir\n" if$verbose;my$fullname=File::Spec->catfile($dir,@parts);print "Filename is now $fullname\n" if$verbose;for my$ext ('','.pod','.pm','.pl'){my$fullext=$fullname .$ext;if(-f $fullext and $self->contains_pod($fullext)){print "FOUND: $fullext\n" if$verbose;return$fullext}}my$subdir=File::Spec->catdir($dir,'pod');if(-d $subdir){$verbose and print "Noticing $subdir and stopping there...\n";$dir=$subdir;redo Dir}}return undef}sub contains_pod {my($self,$file)=@_;my$verbose=$self->{'verbose'};$verbose > 1 and print " Scanning $file for pod...\n";unless(open(MAYBEPOD,"<$file")){print "Error: $file is unreadable: $!\n";return undef}sleep($SLEEPY - 1)if$SLEEPY;local $_;while(<MAYBEPOD>){if(m/^=(head\d|pod|over|item)\b/s){close(MAYBEPOD)|| die "Bizarre error closing $file: $!\nAborting";chomp;$verbose > 1 and print "  Found some pod ($_) in $file\n";return 1}}close(MAYBEPOD)|| die "Bizarre error closing $file: $!\nAborting";$verbose > 1 and print "  No POD in $file, skipping.\n";return 0}sub _accessorize {shift;no strict 'refs';for my$attrname (@_){*{caller().'::' .$attrname}=sub {use strict;$Carp::CarpLevel=1,Carp::croak("Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)")unless (@_==1 or @_==2)and ref $_[0];return $_[0]->{$attrname}if @_==1;$_[0]->{$attrname}=$_[1];return $_[0]}}return}sub _state_as_string {my$self=$_[0];return '' unless ref$self;my@out="{\n  # State of $self ...\n";for my$k (sort keys %$self){push@out,"  ",_esc($k)," => ",_esc($self->{$k}),",\n"}push@out,"}\n";my$x=join '',@out;$x =~ s/^/#/mg;return$x}sub _esc {my$in=$_[0];return 'undef' unless defined$in;$in =~ s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
       <'\\x'.(unpack("H2",$1))>eg;return qq{"$in"}}run()unless caller;1;
POD_SIMPLE_SEARCH

$fatpacked{"Pod/Simple/SimpleTree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SIMPLETREE';
  require 5;package Pod::Simple::SimpleTree;use strict;use Carp ();use Pod::Simple ();use vars qw($ATTR_PAD @ISA $VERSION $SORT_ATTRS);$VERSION='3.28';BEGIN {@ISA=('Pod::Simple');*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}__PACKAGE__->_accessorize('root',);sub _handle_element_start {DEBUG > 2 and print "Handling $_[1] start-event\n";my$x=[$_[1],$_[2]];if($_[0]{'_currpos'}){push @{$_[0]{'_currpos'}[0]},$x;unshift @{$_[0]{'_currpos'}},$x}else {DEBUG and print " And oo, it gets to be root!\n";$_[0]{'_currpos'}=[$_[0]{'root'}=$x ]}DEBUG > 3 and print "Stack is now: ",join(">",map $_->[0],@{$_[0]{'_currpos'}}),"\n";return}sub _handle_element_end {DEBUG > 2 and print "Handling $_[1] end-event\n";shift @{$_[0]{'_currpos'}};DEBUG > 3 and print "Stack is now: ",join(">",map $_->[0],@{$_[0]{'_currpos'}}),"\n";return}sub _handle_text {DEBUG > 2 and print "Handling $_[1] text-event\n";push @{$_[0]{'_currpos'}[0]},$_[1];return}sub _traverse_treelet_bit {DEBUG > 2 and print "Handling $_[1] paragraph event\n";my$self=shift;push @{$self->{'_currpos'}[0]},[@_];return}1;
POD_SIMPLE_SIMPLETREE

$fatpacked{"Pod/Simple/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXT';
  require 5;package Pod::Simple::Text;use strict;use Carp ();use Pod::Simple::Methody ();use Pod::Simple ();use vars qw(@ISA $VERSION $FREAKYMODE);$VERSION='3.28';@ISA=('Pod::Simple::Methody');BEGIN {*DEBUG=defined(&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : sub() {0}}use Text::Wrap 98.112902 ();$Text::Wrap::wrap='overflow';sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||=*STDOUT{IO};$new->accept_target_as_text(qw(text plaintext plain));$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->{'Thispara'}='';$new->{'Indent'}=0;$new->{'Indentstring'}='   ';return$new}sub handle_text {$_[0]{'Thispara'}.= $_[1]}sub start_Para {$_[0]{'Thispara'}=''}sub start_head1 {$_[0]{'Thispara'}=''}sub start_head2 {$_[0]{'Thispara'}=''}sub start_head3 {$_[0]{'Thispara'}=''}sub start_head4 {$_[0]{'Thispara'}=''}sub start_Verbatim {$_[0]{'Thispara'}=''}sub start_item_bullet {$_[0]{'Thispara'}=$FREAKYMODE ? '' : '* '}sub start_item_number {$_[0]{'Thispara'}=$FREAKYMODE ? '' : "$_[1]{'number'}. "}sub start_item_text {$_[0]{'Thispara'}=''}sub start_over_bullet {++$_[0]{'Indent'}}sub start_over_number {++$_[0]{'Indent'}}sub start_over_text {++$_[0]{'Indent'}}sub start_over_block {++$_[0]{'Indent'}}sub end_over_bullet {--$_[0]{'Indent'}}sub end_over_number {--$_[0]{'Indent'}}sub end_over_text {--$_[0]{'Indent'}}sub end_over_block {--$_[0]{'Indent'}}sub end_head1 {$_[0]->emit_par(-4)}sub end_head2 {$_[0]->emit_par(-3)}sub end_head3 {$_[0]->emit_par(-2)}sub end_head4 {$_[0]->emit_par(-1)}sub end_Para {$_[0]->emit_par(0)}sub end_item_bullet {$_[0]->emit_par(0)}sub end_item_number {$_[0]->emit_par(0)}sub end_item_text {$_[0]->emit_par(-2)}sub start_L {$_[0]{'Link'}=$_[1]if $_[1]->{type}eq 'url'}sub end_L {if (my$link=delete $_[0]{'Link'}){$_[0]{'Thispara'}.= " <$link->{to}>" unless $_[0]{'Thispara'}=~ /\b\Q$link->{to}/}}sub emit_par {my($self,$tweak_indent)=splice(@_,0,2);my$indent=' ' x (2 * $self->{'Indent'}+ 4 + ($tweak_indent||0));$self->{'Thispara'}=~ tr{\xAD}{}d if Pod::Simple::ASCII;my$out=Text::Wrap::wrap($indent,$indent,$self->{'Thispara'}.= "\n");$out =~ tr{\xA0}{ } if Pod::Simple::ASCII;print {$self->{'output_fh'}}$out,"\n";$self->{'Thispara'}='';return}sub end_Verbatim {my$self=shift;if(Pod::Simple::ASCII){$self->{'Thispara'}=~ tr{\xA0}{ };$self->{'Thispara'}=~ tr{\xAD}{}d}my$i=' ' x (2 * $self->{'Indent'}+ 4);$self->{'Thispara'}=~ s/^/$i/mg;print {$self->{'output_fh'}}'',$self->{'Thispara'},"\n\n" ;$self->{'Thispara'}='';return}1;
POD_SIMPLE_TEXT

$fatpacked{"Pod/Simple/TextContent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXTCONTENT';
  require 5;package Pod::Simple::TextContent;use strict;use Carp ();use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.28';@ISA=('Pod::Simple');sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||=*STDOUT{IO};$new->nix_X_codes(1);return$new}sub _handle_element_start {print {$_[0]{'output_fh'}}"\n" unless $_[1]=~ m/^[A-Z]$/s;return}sub _handle_text {if(chr(65)eq 'A'){$_[1]=~ tr/\xAD//d;$_[1]=~ tr/\xA0/ /}print {$_[0]{'output_fh'}}$_[1];return}sub _handle_element_end {print {$_[0]{'output_fh'}}"\n" unless $_[1]=~ m/^[A-Z]$/s;return}1;
POD_SIMPLE_TEXTCONTENT

$fatpacked{"Pod/Simple/TiedOutFH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TIEDOUTFH';
  use strict;package Pod::Simple::TiedOutFH;use Symbol ('gensym');use Carp ();use vars qw($VERSION);$VERSION='3.28';sub handle_on {my$class=shift;$class=ref($class)|| $class;Carp::croak "Usage: ${class}->handle_on(\$somescalar)" unless @_;my$x=(defined($_[0])and ref($_[0]))? $_[0]: (\($_[0]))[0];$$x='' unless defined $$x;my$new=gensym();tie *$new,$class,$x;return$new}sub TIEHANDLE {my($class,$scalar_ref)=@_;$$scalar_ref='' unless defined $$scalar_ref;return bless \$scalar_ref,ref($class)|| $class}sub PRINT {my$it=shift;for my$x (@_){$$$it .= $x}return 1}sub FETCH {return ${$_[0]}}sub PRINTF {my$it=shift;my$format=shift;$$$it .= sprintf$format,@_;return 1}sub FILENO {${$_[0]}+ 100}sub CLOSE {1}1;
POD_SIMPLE_TIEDOUTFH

$fatpacked{"Pod/Simple/Transcode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODE';
  require 5;package Pod::Simple::Transcode;use vars qw($VERSION);$VERSION='3.28';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}for my$class ('Pod::Simple::TranscodeSmart','Pod::Simple::TranscodeDumb','',){$class or die "Couldn't load any encoding classes";DEBUG and print "About to try loading $class...\n";eval "require $class;";if($@){DEBUG and print "Couldn't load $class: $@\n"}else {DEBUG and print "OK, loaded $class.\n";@ISA=($class);last}}sub _blorp {return}1;
POD_SIMPLE_TRANSCODE

$fatpacked{"Pod/Simple/TranscodeDumb.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODEDUMB';
  require 5;package Pod::Simple::TranscodeDumb;use strict;use vars qw($VERSION %Supported);$VERSION='3.28';%Supported=('ascii'=>1,'ascii-ctrl'=>1,'iso-8859-1'=>1,'null'=>1,'latin1'=>1,'latin-1'=>1,%Supported,);sub is_dumb {1}sub is_smart {0}sub all_encodings {return sort keys%Supported}sub encoding_is_available {return exists$Supported{lc $_[1]}}sub encmodver {return __PACKAGE__ ." v" .($VERSION || '?')}sub make_transcoder {my($e)=$_[1];die "WHAT ENCODING!?!?" unless$e;my$x;return sub {}}1;
POD_SIMPLE_TRANSCODEDUMB

$fatpacked{"Pod/Simple/TranscodeSmart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODESMART';
  require 5;use 5.008;package Pod::Simple::TranscodeSmart;use strict;use Pod::Simple;require Encode;use vars qw($VERSION);$VERSION='3.28';sub is_dumb {0}sub is_smart {1}sub all_encodings {return Encode::->encodings(':all')}sub encoding_is_available {return Encode::resolve_alias($_[1])}sub encmodver {return "Encode.pm v" .($Encode::VERSION || '?')}sub make_transcoder {my$e=Encode::find_encoding($_[1]);die "WHAT ENCODING!?!?" unless$e;my$x;return sub {for$x (@_){$x=$e->decode($x)unless Encode::is_utf8($x)}return}}1;
POD_SIMPLE_TRANSCODESMART

$fatpacked{"Pod/Simple/XHTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XHTML';
  package Pod::Simple::XHTML;use strict;use vars qw($VERSION @ISA $HAS_HTML_ENTITIES);$VERSION='3.28';use Pod::Simple::Methody ();@ISA=('Pod::Simple::Methody');BEGIN {$HAS_HTML_ENTITIES=eval "require HTML::Entities; 1"}my%entities=(q{>}=>'gt',q{<}=>'lt',q{'}=>'#39',q{"}=>'quot',q{&}=>'amp',);sub encode_entities {my$self=shift;my$ents=$self->html_encode_chars;return HTML::Entities::encode_entities($_[0],$ents)if$HAS_HTML_ENTITIES;if (defined$ents){$ents =~ s,(?<!\\)([]/]),\\$1,g;$ents =~ s,(?<!\\)\\\z,\\\\,}else {$ents=join '',keys%entities}my$str=$_[0];$str =~ s/([$ents])/'&' . ($entities{$1} || sprintf '#x%X', ord $1) . ';'/ge;return$str}__PACKAGE__->_accessorize('perldoc_url_prefix','perldoc_url_postfix','man_url_prefix','man_url_postfix','title_prefix','title_postfix','html_css','html_javascript','html_doctype','html_charset','html_encode_chars','html_h_level','title','default_title','force_title','html_header','html_footer','index','anchor_items','backlink','batch_mode','batch_mode_current_level',);sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||=*STDOUT{IO};$new->perldoc_url_prefix('http://search.cpan.org/perldoc?');$new->man_url_prefix('http://man.he.net/man');$new->html_charset('ISO-8859-1');$new->nix_X_codes(1);$new->{'scratch'}='';$new->{'to_index'}=[];$new->{'output'}=[];$new->{'saved'}=[];$new->{'ids'}={'_podtop_'=>1 };$new->{'in_li'}=[];$new->{'__region_targets'}=[];$new->{'__literal_targets'}={};$new->accept_targets_as_html('html','HTML');return$new}sub html_header_tags {my$self=shift;return$self->{html_header_tags}=shift if @_;return$self->{html_header_tags}||='<meta http-equiv="Content-Type" content="text/html; charset=' .$self->html_charset .'" />'}sub __in_literal_xhtml_region {return unless @{$_[0]{__region_targets}};my$target=$_[0]{__region_targets}[-1];return $_[0]{__literal_targets}{$target }}sub accept_targets_as_html {my ($self,@targets)=@_;$self->accept_targets(@targets);$self->{__literal_targets}{$_}=1 for@targets}sub handle_text {my$text=$_[0]->__in_literal_xhtml_region ? $_[1]: $_[0]->encode_entities($_[1]);if ($_[0]{'in_code'}&& @{$_[0]{'in_code'}}){$_[0]->handle_code($_[1],$_[0]{'in_code'}[-1])}else {$_[0]{'scratch'}.= $text}$_[0]{htext}.= $text if $_[0]{'in_head'}}sub start_code {$_[0]{'scratch'}.= '<code>'}sub end_code {$_[0]{'scratch'}.= '</code>'}sub handle_code {$_[0]{'scratch'}.= $_[0]->encode_entities($_[1])}sub start_Para {$_[0]{'scratch'}='<p>'}sub start_Verbatim {$_[0]{'scratch'}='<pre>';push(@{$_[0]{'in_code'}},'Verbatim');$_[0]->start_code($_[0]{'in_code'}[-1])}sub start_head1 {$_[0]{'in_head'}=1;$_[0]{htext}=''}sub start_head2 {$_[0]{'in_head'}=2;$_[0]{htext}=''}sub start_head3 {$_[0]{'in_head'}=3;$_[0]{htext}=''}sub start_head4 {$_[0]{'in_head'}=4;$_[0]{htext}=''}sub start_item_number {$_[0]{'scratch'}="</li>\n" if ($_[0]{'in_li'}->[-1]&& pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '<li><p>';push @{$_[0]{'in_li'}},1}sub start_item_bullet {$_[0]{'scratch'}="</li>\n" if ($_[0]{'in_li'}->[-1]&& pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '<li><p>';push @{$_[0]{'in_li'}},1}sub start_item_text {}sub start_over_bullet {$_[0]{'scratch'}='<ul>';push @{$_[0]{'in_li'}},0;$_[0]->emit}sub start_over_block {$_[0]{'scratch'}='<ul>';$_[0]->emit}sub start_over_number {$_[0]{'scratch'}='<ol>';push @{$_[0]{'in_li'}},0;$_[0]->emit}sub start_over_text {$_[0]{'scratch'}='<dl>';$_[0]{'dl_level'}++;$_[0]{'in_dd'}||=[];$_[0]->emit}sub end_over_block {$_[0]{'scratch'}.= '</ul>';$_[0]->emit}sub end_over_number {$_[0]{'scratch'}="</li>\n" if (pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '</ol>';pop @{$_[0]{'in_li'}};$_[0]->emit}sub end_over_bullet {$_[0]{'scratch'}="</li>\n" if (pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '</ul>';pop @{$_[0]{'in_li'}};$_[0]->emit}sub end_over_text {if ($_[0]{'in_dd'}[$_[0]{'dl_level'}]){$_[0]{'scratch'}="</dd>\n";$_[0]{'in_dd'}[$_[0]{'dl_level'}]=0}$_[0]{'scratch'}.= '</dl>';$_[0]{'dl_level'}--;$_[0]->emit}sub end_Para {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_Verbatim {$_[0]->end_code(pop(@{$_[0]->{'in_code'}}));$_[0]{'scratch'}.= '</pre>';$_[0]->emit}sub _end_head {my$h=delete $_[0]{in_head};my$add=$_[0]->html_h_level;$add=1 unless defined$add;$h += $add - 1;my$id=$_[0]->idify($_[0]{htext});my$text=$_[0]{scratch};$_[0]{'scratch'}=$_[0]->backlink && ($h - $add==0)? qq{<a href="#_podtop_"><h$h id="$id">$text</h$h></a>} : qq{<h$h id="$id">$text</h$h>};$_[0]->emit;push @{$_[0]{'to_index'}},[$h,$id,delete $_[0]{'htext'}]}sub end_head1 {shift->_end_head(@_)}sub end_head2 {shift->_end_head(@_)}sub end_head3 {shift->_end_head(@_)}sub end_head4 {shift->_end_head(@_)}sub end_item_bullet {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_item_number {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_item_text {my$dt_id=$_[0]{'anchor_items'}? ' id="'.$_[0]->idify($_[0]{'scratch'}).'"' : '';my$text=$_[0]{scratch};$_[0]{'scratch'}='';if ($_[0]{'in_dd'}[$_[0]{'dl_level'}]){$_[0]{'scratch'}="</dd>\n";$_[0]{'in_dd'}[$_[0]{'dl_level'}]=0}$_[0]{'scratch'}.= qq{<dt$dt_id>$text</dt>\n<dd>};$_[0]{'in_dd'}[$_[0]{'dl_level'}]=1;$_[0]->emit}sub start_for {my ($self,$flags)=@_;push @{$self->{__region_targets}},$flags->{target_matching};unless ($self->__in_literal_xhtml_region){$self->{scratch}.= '<div';$self->{scratch}.= qq( class="$flags->{target}") if$flags->{target};$self->{scratch}.= '>'}$self->emit}sub end_for {my ($self)=@_;$self->{'scratch'}.= '</div>' unless$self->__in_literal_xhtml_region;pop @{$self->{__region_targets}};$self->emit}sub start_Document {my ($self)=@_;if (defined$self->html_header){$self->{'scratch'}.= $self->html_header;$self->emit unless$self->html_header eq ""}else {my ($doctype,$title,$metatags,$bodyid);$doctype=$self->html_doctype || '';$title=$self->force_title || $self->title || $self->default_title || '';$metatags=$self->html_header_tags || '';if (my$css=$self->html_css){$metatags .= $css;if ($css !~ /<link/){$metatags .= '<link rel="stylesheet" href="' .$self->encode_entities($css).'" type="text/css" />'}}if ($self->html_javascript){$metatags .= qq{\n<script type="text/javascript" src="} .$self->html_javascript ."'></script>"}$bodyid=$self->backlink ? ' id="_podtop_"' : '';$self->{'scratch'}.= <<"HTML";$self->emit}}sub end_Document {my ($self)=@_;my$to_index=$self->{'to_index'};if ($self->index && @{$to_index}){my@out;my$level=0;my$indent=-1;my$space='';my$id=' id="index"';for my$h (@{$to_index},[0]){my$target_level=$h->[0];if ($level==$target_level){$out[-1].= '</li>'}elsif ($level > $target_level){$out[-1].= '</li>' if$out[-1]=~ /^\s+<li>/;while ($level > $target_level){--$level;push@out,('  ' x --$indent).'</li>' if@out && $out[-1]=~ m{^\s+<\/ul};push@out,('  ' x --$indent).'</ul>'}push@out,('  ' x --$indent).'</li>' if$level}else {while ($level < $target_level){++$level;push@out,('  ' x ++$indent).'<li>' if@out && $out[-1]=~ /^\s*<ul/;push@out,('  ' x ++$indent)."<ul$id>";$id=''}++$indent}next unless$level;$space='  ' x $indent;push@out,sprintf '%s<li><a href="#%s">%s</a>',$space,$h->[1],$h->[2]}my$offset=defined$self->html_header ? $self->html_header eq '' ? 0 : 1 : 1;splice @{$self->{'output'}},$offset,0,join "\n",@out}if (defined$self->html_footer){$self->{'scratch'}.= $self->html_footer;$self->emit unless$self->html_footer eq ""}else {$self->{'scratch'}.= "</body>\n</html>";$self->emit}if ($self->index){print {$self->{'output_fh'}}join ("\n\n",@{$self->{'output'}}),"\n\n";@{$self->{'output'}}=()}}sub start_B {$_[0]{'scratch'}.= '<b>'}sub end_B {$_[0]{'scratch'}.= '</b>'}sub start_C {push(@{$_[0]{'in_code'}},'C');$_[0]->start_code($_[0]{'in_code'}[-1])}sub end_C {$_[0]->end_code(pop(@{$_[0]{'in_code'}}))}sub start_F {$_[0]{'scratch'}.= '<i>'}sub end_F {$_[0]{'scratch'}.= '</i>'}sub start_I {$_[0]{'scratch'}.= '<i>'}sub end_I {$_[0]{'scratch'}.= '</i>'}sub start_L {my ($self,$flags)=@_;my ($type,$to,$section)=@{$flags}{'type','to','section'};my$url=$self->encode_entities($type eq 'url' ? $to : $type eq 'pod' ? $self->resolve_pod_page_link($to,$section): $type eq 'man' ? $self->resolve_man_page_link($to,$section): undef);$self->{'scratch'}.= '<a' .($url ? ' href="'.$url .'">' : '>')}sub end_L {$_[0]{'scratch'}.= '</a>'}sub start_S {$_[0]{'scratch'}.= '<span style="white-space: nowrap;">'}sub end_S {$_[0]{'scratch'}.= '</span>'}sub emit {my($self)=@_;if ($self->index){push @{$self->{'output'}},$self->{'scratch'}}else {print {$self->{'output_fh'}}$self->{'scratch'},"\n\n"}$self->{'scratch'}='';return}sub resolve_pod_page_link {my ($self,$to,$section)=@_;return undef unless defined$to || defined$section;if (defined$section){$section='#' .$self->idify($self->encode_entities($section),1);return$section unless defined$to}else {$section=''}return ($self->perldoc_url_prefix || '').$self->encode_entities($to).$section .($self->perldoc_url_postfix || '')}sub resolve_man_page_link {my ($self,$to,$section)=@_;return undef unless defined$to;my ($page,$part)=$to =~ /^([^(]+)(?:[(](\d+)[)])?$/;return undef unless$page;return ($self->man_url_prefix || '').($part || 1)."/" .$self->encode_entities($page).($self->man_url_postfix || '')}sub idify {my ($self,$t,$not_unique)=@_;for ($t){s/<[^>]+>//g;s/&[^;]+;//g;s/^\s+//;s/\s+$//;s/^([^a-zA-Z]+)$/pod$1/;s/^[^a-zA-Z]+//;s/[^-a-zA-Z0-9_:.]+/-/g;s/[-:.]+$//}return$t if$not_unique;my$i='';$i++ while$self->{ids}{"$t$i"}++;return "$t$i"}sub batch_mode_page_object_init {my ($self,$batchconvobj,$module,$infile,$outfile,$depth)=@_;$self->batch_mode(1);$self->batch_mode_current_level($depth);return$self}sub html_header_after_title {}1;
  $doctype
  <html>
  <head>
  <title>$title</title>
  $metatags
  </head>
  <body$bodyid>
  HTML
POD_SIMPLE_XHTML

$fatpacked{"Pod/Simple/XMLOutStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XMLOUTSTREAM';
  require 5;package Pod::Simple::XMLOutStream;use strict;use Carp ();use Pod::Simple ();use vars qw($ATTR_PAD @ISA $VERSION $SORT_ATTRS);$VERSION='3.28';BEGIN {@ISA=('Pod::Simple');*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}$ATTR_PAD="\n" unless defined$ATTR_PAD;$SORT_ATTRS=0 unless defined$SORT_ATTRS;sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||=*STDOUT{IO};$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print "++ $_[1]\n";print$fh "<",$_[1];if($SORT_ATTRS){for my$key (sort keys %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value=$_[2]{$key});print$fh $ATTR_PAD,$key,'="',$value,'"'}}}else {while(($key,$value)=each %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value);print$fh $ATTR_PAD,$key,'="',$value,'"'}}}print$fh ">";return}sub _handle_text {DEBUG and print "== \"$_[1]\"\n";if(length $_[1]){my$text=$_[1];_xml_escape($text);print {$_[0]{'output_fh'}}$text}return}sub _handle_element_end {DEBUG and print "-- $_[1]\n";print {$_[0]{'output_fh'}}"</",$_[1],">";return}sub _xml_escape {for my$x (@_){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}return}1;
POD_SIMPLE_XMLOUTSTREAM

$fatpacked{"Pod/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT';
  package Pod::Text;require 5.004;use strict;use vars qw(@ISA @EXPORT %ESCAPES $VERSION);use Carp qw(carp croak);use Encode qw(encode);use Exporter ();use Pod::Simple ();@ISA=qw(Pod::Simple Exporter);@EXPORT=qw(pod2text);$VERSION='3.18';sub handle_code {my ($line,$number,$parser)=@_;$parser->output_code ($line ."\n")}sub new {my$class=shift;my$self=$class->SUPER::new;$self->nbsp_for_S (1);if ($self->can ('preserve_whitespace')){$self->preserve_whitespace (1)}else {$self->fullstop_space_harden (1)}$self->accept_targets (qw/text TEXT/);$self->merge_text (1);my%opts=@_;my@opts=map {("opt_$_",$opts{$_})}keys%opts;%$self=(%$self,@opts);if ($$self{opt_stderr}and not $$self{opt_errors}){$$self{opt_errors}='stderr'}delete $$self{opt_stderr};if (not defined $$self{opt_errors}){$$self{opt_errors}='pod'}if ($$self{opt_errors}eq 'stderr' || $$self{opt_errors}eq 'die'){$self->no_errata_section (1);$self->complain_stderr (1);if ($$self{opt_errors}eq 'die'){$$self{complain_die}=1}}elsif ($$self{opt_errors}eq 'pod'){$self->no_errata_section (0);$self->complain_stderr (0)}elsif ($$self{opt_errors}eq 'none'){$self->no_whining (1)}else {croak (qq(Invalid errors setting: "$$self{errors}"))}delete $$self{errors};$$self{opt_alt}=0 unless defined $$self{opt_alt};$$self{opt_indent}=4 unless defined $$self{opt_indent};$$self{opt_margin}=0 unless defined $$self{opt_margin};$$self{opt_loose}=0 unless defined $$self{opt_loose};$$self{opt_sentence}=0 unless defined $$self{opt_sentence};$$self{opt_width}=76 unless defined $$self{opt_width};$$self{opt_quotes}||='"';if ($$self{opt_quotes}eq 'none'){$$self{LQUOTE}=$$self{RQUOTE}=''}elsif (length ($$self{opt_quotes})==1){$$self{LQUOTE}=$$self{RQUOTE}=$$self{opt_quotes}}elsif ($$self{opt_quotes}=~ /^(.)(.)$/ || $$self{opt_quotes}=~ /^(..)(..)$/){$$self{LQUOTE}=$1;$$self{RQUOTE}=$2}else {croak qq(Invalid quote specification "$$self{opt_quotes}")}$self->code_handler (\&handle_code)if $$self{opt_code};return$self}sub _handle_text {my ($self,$text)=@_;my$tag=$$self{PENDING}[-1];$$tag[1].= $text}sub method_for_element {my ($self,$element)=@_;$element =~ tr/-/_/;$element =~ tr/A-Z/a-z/;$element =~ tr/_a-z0-9//cd;return$element}sub _handle_element_start {my ($self,$element,$attrs)=@_;my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){push (@{$$self{PENDING}},[$attrs,'' ])}elsif ($self->can ("start_$method")){my$method='start_' .$method;$self->$method ($attrs,'')}}sub _handle_element_end {my ($self,$element)=@_;my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){my$tag=pop @{$$self{PENDING}};my$method='cmd_' .$method;my$text=$self->$method (@$tag);if (defined$text){if (@{$$self{PENDING}}> 1){$$self{PENDING}[-1][1].= $text}else {$self->output ($text)}}}elsif ($self->can ("end_$method")){my$method='end_' .$method;$self->$method ()}}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};while (length > $width){if (s/^([^\n]{0,$width})\s+// || s/^([^\n]{$width})//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}sub reformat {my$self=shift;local $_=shift;if ($$self{opt_sentence}){s/ +$//mg;s/\.\n/. \n/g;s/\n/ /g;s/   +/  /g}else {s/\s+/ /g}return$self->wrap ($_)}sub output {my ($self,@text)=@_;my$text=join ('',@text);$text =~ tr/\240\255/ /d;unless ($$self{opt_utf8}|| $$self{CHECKED_ENCODING}){my$encoding=$$self{encoding}|| '';if ($encoding){eval {binmode ($$self{output_fh},":encoding($encoding)")}}$$self{CHECKED_ENCODING}=1}if ($$self{ENCODE}){print {$$self{output_fh}}encode ('UTF-8',$text)}else {print {$$self{output_fh}}$text}}sub output_code {$_[0]->output ($_[1])}sub start_document {my ($self,$attrs)=@_;if ($$attrs{contentless}&&!$$self{ALWAYS_EMIT_SOMETHING}){$$self{CONTENTLESS}=1}else {delete $$self{CONTENTLESS}}my$margin=$$self{opt_indent}+ $$self{opt_margin};$$self{INDENTS}=[];$$self{MARGIN}=$margin;$$self{PENDING}=[[]];delete $$self{CHECKED_ENCODING};$$self{ENCODE}=0;if ($$self{opt_utf8}){$$self{ENCODE}=1;eval {my@options=(output=>1,details=>1);my$flag=(PerlIO::get_layers ($$self{output_fh},@options))[-1];if ($flag & PerlIO::F_UTF8 ()){$$self{ENCODE}=0}}}return ''}sub end_document {my ($self)=@_;if ($$self{complain_die}&& $self->errors_seen){croak ("POD document had syntax errors")}}sub strip_format {my ($self,$string)=@_;return$string}sub item {my ($self,$text)=@_;my$tag=$$self{ITEM};unless (defined$tag){carp "Item called without tag";return}undef $$self{ITEM};my$indent=$$self{INDENTS}[-1];$indent=$$self{opt_indent}unless defined$indent;my$margin=' ' x $$self{opt_margin};my$tag_length=length ($self->strip_format ($tag));my$fits=($$self{MARGIN}- $indent >= $tag_length + 1);if (!$text || $text =~ /^\s+$/ ||!$fits){my$realindent=$$self{MARGIN};$$self{MARGIN}=$indent;my$output=$self->reformat ($tag);$output =~ s/^$margin /$margin:/ if ($$self{opt_alt}&& $indent > 0);$output =~ s/\n*$/\n/;$output .= "\n" if$text && $text =~ /^\s*$/;$self->output ($output);$$self{MARGIN}=$realindent;$self->output ($self->reformat ($text))if ($text && $text =~ /\S/)}else {my$space=' ' x $indent;$space =~ s/^$margin /$margin:/ if $$self{opt_alt};$text=$self->reformat ($text);$text =~ s/^$margin /$margin:/ if ($$self{opt_alt}&& $indent > 0);my$tagspace=' ' x $tag_length;$text =~ s/^($space)$tagspace/$1$tag/ or warn "Bizarre space in item";$self->output ($text)}}sub cmd_para {my ($self,$attrs,$text)=@_;$text =~ s/\s+$/\n/;if (defined $$self{ITEM}){$self->item ($text ."\n")}else {$self->output ($self->reformat ($text ."\n"))}return ''}sub cmd_verbatim {my ($self,$attrs,$text)=@_;$self->item if defined $$self{ITEM};return if$text =~ /^\s*$/;$text =~ s/^(\n*)([ \t]*\S+)/$1 . (' ' x $$self{MARGIN}) . $2/gme;$text =~ s/\s*$/\n\n/;$self->output ($text);return ''}sub cmd_data {my ($self,$attrs,$text)=@_;$text =~ s/^\n+//;$text =~ s/\n{0,2}$/\n/;$self->output ($text);return ''}sub heading {my ($self,$text,$indent,$marker)=@_;$self->item ("\n\n")if defined $$self{ITEM};$text =~ s/\s+$//;if ($$self{opt_alt}){my$closemark=reverse (split (//,$marker));my$margin=' ' x $$self{opt_margin};$self->output ("\n" ."$margin$marker $text $closemark" ."\n\n")}else {$text .= "\n" if $$self{opt_loose};my$margin=' ' x ($$self{opt_margin}+ $indent);$self->output ($margin .$text ."\n")}return ''}sub cmd_head1 {my ($self,$attrs,$text)=@_;$self->heading ($text,0,'====')}sub cmd_head2 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}/ 2,'==  ')}sub cmd_head3 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}* 2 / 3 + 0.5,'=   ')}sub cmd_head4 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}* 3 / 4 + 0.5,'-   ')}sub over_common_start {my ($self,$attrs)=@_;$self->item ("\n\n")if defined $$self{ITEM};my$indent=$$attrs{indent};unless (defined ($indent)&& $indent =~ /^\s*[-+]?\d{1,4}\s*$/){$indent=$$self{opt_indent}}push (@{$$self{INDENTS}},$$self{MARGIN});$$self{MARGIN}+= ($indent + 0);return ''}sub over_common_end {my ($self)=@_;$self->item ("\n\n")if defined $$self{ITEM};$$self{MARGIN}=pop @{$$self{INDENTS}};return ''}sub start_over_bullet {$_[0]->over_common_start ($_[1])}sub start_over_number {$_[0]->over_common_start ($_[1])}sub start_over_text {$_[0]->over_common_start ($_[1])}sub start_over_block {$_[0]->over_common_start ($_[1])}sub end_over_bullet {$_[0]->over_common_end}sub end_over_number {$_[0]->over_common_end}sub end_over_text {$_[0]->over_common_end}sub end_over_block {$_[0]->over_common_end}sub item_common {my ($self,$type,$attrs,$text)=@_;$self->item if defined $$self{ITEM};$text =~ s/\s+$//;my ($item,$index);if ($type eq 'bullet'){$item='*'}elsif ($type eq 'number'){$item=$$attrs{'~orig_content'}}else {$item=$text;$item =~ s/\s*\n\s*/ /g;$text=''}$$self{ITEM}=$item;if ($text){$text =~ s/\s*$/\n/;$self->item ($text)}return ''}sub cmd_item_bullet {my$self=shift;$self->item_common ('bullet',@_)}sub cmd_item_number {my$self=shift;$self->item_common ('number',@_)}sub cmd_item_text {my$self=shift;$self->item_common ('text',@_)}sub cmd_item_block {my$self=shift;$self->item_common ('block',@_)}sub cmd_b {return $_[0]{alt}? "``$_[2]''" : $_[2]}sub cmd_f {return $_[0]{alt}? "\"$_[2]\"" : $_[2]}sub cmd_i {return '*' .$_[2].'*'}sub cmd_x {return ''}sub cmd_c {my ($self,$attrs,$text)=@_;my$index='(?: \[.*\] | \{.*\} )?';$text =~ m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \` .* \'                                       # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [+-]? ( \d[\d.]* | \.\d+ ) (?: [eE][+-]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xo && return$text;return $$self{opt_alt}? "``$text''" : "$$self{LQUOTE}$text$$self{RQUOTE}"}sub cmd_l {my ($self,$attrs,$text)=@_;if ($$attrs{type}eq 'url'){if (not defined($$attrs{to})or $$attrs{to}eq $text){return "<$text>"}elsif ($$self{opt_nourls}){return$text}else {return "$text <$$attrs{to}>"}}else {return$text}}sub pod2text {my@args;while ($_[0]=~ /^-/){my$flag=shift;if ($flag eq '-a'){push (@args,alt=>1)}elsif ($flag =~ /^-(\d+)$/){push (@args,width=>$1)}else {unshift (@_,$flag);last}}my$parser=Pod::Text->new (@args);if (defined $_[1]){my@fhs=@_;local*IN;unless (open (IN,$fhs[0])){croak ("Can't open $fhs[0] for reading: $!\n");return}$fhs[0]=\*IN;$parser->output_fh ($fhs[1]);my$retval=$parser->parse_file ($fhs[0]);my$fh=$parser->output_fh ();close$fh;return$retval}else {$parser->output_fh (\*STDOUT);return$parser->parse_file (@_)}}sub parse_from_file {my$self=shift;$self->reinit;if (ref ($_[0])eq 'HASH'){my$opts=shift @_;if (defined ($$opts{-cutting})&&!$$opts{-cutting}){$$self{in_pod}=1;$$self{last_was_blank}=1}}my$retval=$self->Pod::Simple::parse_from_file (@_);my$fh=$self->output_fh ();my$oldfh=select$fh;my$oldflush=$|;$|=1;print$fh '';$|=$oldflush;select$oldfh;return$retval}sub parse_from_filehandle {my$self=shift;$self->parse_from_file (@_)}sub parse_file {my ($self,$in)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_file ($in)}sub parse_lines {my ($self,@lines)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_lines (@lines)}sub parse_string_document {my ($self,$doc)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_string_document ($doc)}1;
POD_TEXT

$fatpacked{"Pod/Text/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_COLOR';
  package Pod::Text::Color;require 5.004;use Pod::Text ();use Term::ANSIColor qw(colored);use strict;use vars qw(@ISA $VERSION);@ISA=qw(Pod::Text);$VERSION='2.07';sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head1 ($attrs,colored ($text,'bold'))}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head2 ($attrs,colored ($text,'bold'))}sub cmd_b {return colored ($_[2],'bold')}sub cmd_f {return colored ($_[2],'cyan')}sub cmd_i {return colored ($_[2],'yellow')}sub output_code {my ($self,$code)=@_;$code=colored ($code,'green');$self->output ($code)}sub strip_format {my ($self,$text)=@_;$text =~ s/\e\[[\d;]*m//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};my$char='(?:(?:\e\[[\d;]+m)*[^\n])';my$shortchar=$char ."{0,$width}";my$longchar=$char ."{$width}";while (length > $width){if (s/^($shortchar)\s+// || s/^($longchar)//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;$output}1;
POD_TEXT_COLOR

$fatpacked{"Pod/Text/Overstrike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_OVERSTRIKE';
  package Pod::Text::Overstrike;require 5.004;use Pod::Text ();use strict;use vars qw(@ISA $VERSION);@ISA=qw(Pod::Text);$VERSION='2.05';sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/$1\b$1/g;return$self->SUPER::cmd_head1 ($attrs,$text)}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/$1\b$1/g;return$self->SUPER::cmd_head2 ($attrs,$text)}sub cmd_head3 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/_\b$1/g;return$self->SUPER::cmd_head3 ($attrs,$text)}sub cmd_head4 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/_\b$1/g;return$self->SUPER::cmd_head4 ($attrs,$text)}sub heading {my ($self,$text,$indent,$marker)=@_;$self->item ("\n\n")if defined $$self{ITEM};$text .= "\n" if $$self{opt_loose};my$margin=' ' x ($$self{opt_margin}+ $indent);$self->output ($margin .$text ."\n");return ''}sub cmd_b {local $_=$_[0]->strip_format ($_[2]);s/(.)/$1\b$1/g;$_}sub cmd_f {local $_=$_[0]->strip_format ($_[2]);s/(.)/_\b$1/g;$_}sub cmd_i {local $_=$_[0]->strip_format ($_[2]);s/(.)/_\b$1/g;$_}sub output_code {my ($self,$code)=@_;$code =~ s/(.)/$1\b$1/g;$self->output ($code)}sub strip_format {my ($self,$text)=@_;$text =~ s/(.)[\b]\1/$1/g;$text =~ s/_[\b]//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};while (length > $width){my$char='(?:[^\n][\b])?[^\n]';if (s/^((?>$char){0,$width})(?:\Z|\s+)//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}1;
POD_TEXT_OVERSTRIKE

$fatpacked{"Pod/Text/Termcap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_TERMCAP';
  package Pod::Text::Termcap;require 5.004;use Pod::Text ();use POSIX ();use Term::Cap;use strict;use vars qw(@ISA $VERSION);@ISA=qw(Pod::Text);$VERSION='2.08';sub new {my ($self,@args)=@_;my ($ospeed,$term,$termios);$self=$self->SUPER::new (@args);my$home=exists$ENV{HOME}? "$ENV{HOME}/.termcap:" : '';$ENV{TERMPATH}=$home .'/etc/termcap:/usr/share/misc/termcap' .':/usr/share/lib/termcap';eval {$termios=POSIX::Termios->new};if ($@){$ospeed=9600}else {$termios->getattr;$ospeed=$termios->getospeed || 9600}eval {$term=Tgetent Term::Cap {TERM=>undef,OSPEED=>$ospeed}};$$self{BOLD}=$$term{_md}|| "\e[1m";$$self{UNDL}=$$term{_us}|| "\e[4m";$$self{NORM}=$$term{_me}|| "\e[m";unless (defined $$self{width}){$$self{opt_width}=$ENV{COLUMNS}|| $$term{_co}|| 80;$$self{opt_width}-= 2}return$self}sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head1 ($attrs,"$$self{BOLD}$text$$self{NORM}")}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head2 ($attrs,"$$self{BOLD}$text$$self{NORM}")}sub cmd_b {my$self=shift;return "$$self{BOLD}$_[1]$$self{NORM}"}sub cmd_i {my$self=shift;return "$$self{UNDL}$_[1]$$self{NORM}"}sub output_code {my ($self,$code)=@_;$self->output ($$self{BOLD}.$code .$$self{NORM})}sub strip_format {my ($self,$text)=@_;$text =~ s/\Q$$self{BOLD}//g;$text =~ s/\Q$$self{UNDL}//g;$text =~ s/\Q$$self{NORM}//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};my$codes="(?:\Q$$self{BOLD}\E|\Q$$self{UNDL}\E|\Q$$self{NORM}\E)";my$char="(?:$codes*[^\\n])";my$shortchar=$char ."{0,$width}";my$longchar=$char ."{$width}";while (length > $width){if (s/^($shortchar)\s+// || s/^($longchar)//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}1;
POD_TEXT_TERMCAP

$fatpacked{"Pod/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_USAGE';
  package Pod::Usage;use strict;use vars qw($VERSION @ISA @EXPORT);$VERSION='1.64';require 5.006;use Carp;use Config;use Exporter;use File::Spec;@EXPORT=qw(&pod2usage);BEGIN {$Pod::Usage::Formatter ||='Pod::Text';eval "require $Pod::Usage::Formatter";die $@ if $@;@ISA=($Pod::Usage::Formatter)}our$MAX_HEADING_LEVEL=3;sub pod2usage {local($_)=shift;my%opts;if (@_ > 0){%opts=($_,@_)}elsif (!defined $_){$_=''}elsif (ref $_){%opts=%{$_}if (ref($_)eq 'HASH')}elsif (/^[-+]?\d+$/){$opts{'-exitval'}=$_}else {$_ and $opts{'-message'}=$_}%opts=map {my ($key,$val)=($_,$opts{$_});$key =~ s/^(?=\w)/-/;$key =~ /^-msg/i and $key='-message';$key =~ /^-exit/i and $key='-exitval';lc($key)=>$val}(keys%opts);if ((!defined$opts{'-exitval'})&& (!defined$opts{'-verbose'})){$opts{'-exitval'}=2;$opts{'-verbose'}=0}elsif (!defined$opts{'-exitval'}){$opts{'-exitval'}=($opts{'-verbose'}> 0)? 1 : 2}elsif (!defined$opts{'-verbose'}){$opts{'-verbose'}=(lc($opts{'-exitval'})eq 'noexit' || $opts{'-exitval'}< 2)}$opts{'-output'}=(lc($opts{'-exitval'})eq 'noexit' || $opts{'-exitval'}< 2)? \*STDOUT : \*STDERR unless (defined$opts{'-output'});$opts{'-input'}=$0 unless (defined$opts{'-input'});unless ((ref$opts{'-input'})|| (-e $opts{'-input'})){my$basename=$opts{'-input'};my$pathsep=($^O =~ /^(?:dos|os2|MSWin32)$/i)? ';' : (($^O eq 'MacOS' || $^O eq 'VMS')? ',' : ':');my$pathspec=$opts{'-pathlist'}|| $ENV{PATH}|| $ENV{PERL5LIB};my@paths=(ref$pathspec)? @$pathspec : split($pathsep,$pathspec);for my$dirname (@paths){$_=File::Spec->catfile($dirname,$basename)if length;last if (-e $_)&& ($opts{'-input'}=$_)}}my$parser=new Pod::Usage(USAGE_OPTIONS=>\%opts);if ($opts{'-verbose'}==0){$parser->select('(?:SYNOPSIS|USAGE)\s*')}elsif ($opts{'-verbose'}==1){my$opt_re='(?i)' .'(?:OPTIONS|ARGUMENTS)' .'(?:\s*(?:AND|\/)\s*(?:OPTIONS|ARGUMENTS))?';$parser->select('(?:SYNOPSIS|USAGE)\s*',$opt_re,"DESCRIPTION/$opt_re")}elsif ($opts{'-verbose'}>= 2 && $opts{'-verbose'}!=99){$parser->select('.*')}elsif ($opts{'-verbose'}==99){my$sections=$opts{'-sections'};$parser->select((ref$sections)? @$sections : $sections);$opts{'-verbose'}=1}my$progpath=File::Spec->catfile($Config{scriptdirexp}|| $Config{scriptdir},'perldoc');my$version=sprintf("%vd",$^V);if ($Config{versiononly}and $Config{startperl}=~ /\Q$version\E$/){$progpath .= $version}$opts{'-noperldoc'}=1 unless -e $progpath;if (!$opts{'-noperldoc'}and $opts{'-verbose'}>= 2 and!ref($opts{'-input'})and $opts{'-output'}==\*STDOUT){print {$opts{'-output'}}($opts{'-message'},"\n")if($opts{'-message'});if(defined$opts{-input}&& $opts{-input}=~ /^\s*(\S.*?)\s*$/){system($progpath,'-F',$1);if($?){system(($Config{pager}|| $ENV{PAGER}|| '/bin/more'),$1)}}else {croak "Unspecified input file or insecure argument.\n"}}else {$parser->parse_from_file($opts{'-input'},$opts{'-output'})}exit($opts{'-exitval'})unless (lc($opts{'-exitval'})eq 'noexit')}sub new {my$this=shift;my$class=ref($this)|| $this;my%params=@_;my$self={%params};bless$self,$class;if ($self->can('initialize')){$self->initialize()}else {my%opts;for (qw(alt code indent loose margin quotes sentence stderr utf8 width)){my$val=$params{USAGE_OPTIONS}{"-$_"};$opts{$_}=$val if defined$val}$self=$self->SUPER::new(%opts);%$self=(%$self,%params)}return$self}sub _compile_section_spec {my ($section_spec)=@_;my (@regexs,$negated);local $_=$section_spec;s{\\\\}{\001}g;s{\\/}{\002}g;@regexs=split(/\//,$_,$MAX_HEADING_LEVEL);for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$regexs[$i]='.*' unless ((defined$regexs[$i])&& (length$regexs[$i]))}my$bad_regexs=0;for (@regexs){$_ .= '.+' if ($_ eq '!');s{\001}{\\\\}g;s{\002}{\\/}g;$negated=s/^\!//;eval "m{$_}";if ($@){++$bad_regexs;carp qq{Bad regular expression /$_/ in "$section_spec": $@\n}}else {$_='^' .$_ unless (/^\^/);$_=$_ .'$' unless (/\$$/);$_='!' .$_ if ($negated)}}return (!$bad_regexs)? [@regexs ]: undef}sub select {my ($self,@sections)=@_;if ($ISA[0]->can('select')){$self->SUPER::select(@sections)}else {my$add=($sections[0]eq '+')? shift(@sections): '';unless (@sections){delete$self->{USAGE_SELECT}unless ($add);return}$self->{USAGE_SELECT}=[]unless ($add && $self->{USAGE_SELECT});my$sref=$self->{USAGE_SELECT};for my$spec (@sections){my$cs=_compile_section_spec($spec);if (defined$cs){push(@$sref,$cs)}else {carp qq{Ignoring section spec "$spec"!\n}}}}}sub seq_i {return $_[1]}sub _handle_element_end {my ($self,$element)=@_;if ($element eq 'head1'){$self->{USAGE_HEADINGS}=[$$self{PENDING}[-1][1]];if ($self->{USAGE_OPTIONS}->{-verbose}< 2){$$self{PENDING}[-1][1]=~ s/^\s*SYNOPSIS\s*$/USAGE/}}elsif ($element =~ /^head(\d+)$/ && $1){my$idx=$1 - 1;$self->{USAGE_HEADINGS}=[]unless($self->{USAGE_HEADINGS});$self->{USAGE_HEADINGS}->[$idx]=$$self{PENDING}[-1][1]}if ($element =~ /^head\d+$/){$$self{USAGE_SKIPPING}=1;if (!$$self{USAGE_SELECT}||!@{$$self{USAGE_SELECT}}){$$self{USAGE_SKIPPING}=0}else {my@headings=@{$$self{USAGE_HEADINGS}};for my$section_spec (@{$$self{USAGE_SELECT}}){my$match=1;for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$headings[$i]='' unless defined$headings[$i];my$regex=$section_spec->[$i];my$negated=($regex =~ s/^\!//);$match &=($negated ? ($headings[$i]!~ /${regex}/): ($headings[$i]=~ /${regex}/));last unless ($match)}if ($match){$$self{USAGE_SKIPPING}=0;last}}}if($self->{USAGE_OPTIONS}->{-verbose}< 2){local $_=$$self{PENDING}[-1][1];s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;s/\s*$/:/ unless (/:\s*$/);$_ .= "\n";$$self{PENDING}[-1][1]=$_}}if ($$self{USAGE_SKIPPING}&& $element !~ m/^over-/){pop @{$$self{PENDING}}}else {$self->SUPER::_handle_element_end($element)}}sub start_document {my$self=shift;$self->SUPER::start_document();my$msg=$self->{USAGE_OPTIONS}->{-message}or return 1;my$out_fh=$self->output_fh();print$out_fh "$msg\n"}sub begin_pod {my$self=shift;$self->SUPER::begin_pod();my$msg=$self->{USAGE_OPTIONS}->{-message}or return 1;my$out_fh=$self->output_handle();print$out_fh "$msg\n"}sub preprocess_paragraph {my$self=shift;local $_=shift;my$line=shift;if (($self->{USAGE_OPTIONS}->{-verbose}< 2)&& /^=head/){s/^=head1\s+SYNOPSIS\s*$/=head1 USAGE/;s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;s/\s*$/:/ unless (/:\s*$/);$_ .= "\n"}return$self->SUPER::preprocess_paragraph($_)}1;
POD_USAGE

$fatpacked{"Proc/Pidfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PROC_PIDFILE';
  package Proc::Pidfile;$Proc::Pidfile::VERSION='1.06';use 5.006;use strict;use warnings;use Fcntl qw(:flock);use File::Basename qw(basename);use Carp qw/carp croak/;require File::Spec;sub new {my$class=shift;my%args=@_;my$self=bless \%args,$class;unless ($self->{pidfile}){my$basename=basename($0);my$dir=-w "/var/run" ? "/var/run" : File::Spec->tmpdir();croak "Can't write to $dir\n" unless -w $dir;my$pidfile="$dir/$basename.pid";$self->_verbose("pidfile: $pidfile\n");$self->{pidfile}=$pidfile}$self->_create_pidfile();return$self}sub DESTROY {my$self=shift;$self->_destroy_pidfile()}sub pidfile {my$self=shift;return$self->{pidfile}}sub _verbose {my$self=shift;return unless$self->{verbose};print STDERR @_}sub _get_pid {my$self=shift;my$pidfile=$self->{pidfile};$self->_verbose("get pid from $pidfile\n");open(PID,$pidfile)or croak "can't read pid file $pidfile\n";flock(PID,LOCK_SH)or croak "can't lock pid file $pidfile\n";my$pid=<PID>;croak "can't get pid from pidfile $pidfile\n" if not defined($pid);chomp($pid);flock(PID,LOCK_UN);close(PID);$self->_verbose("pid = $pid\n");return$pid}sub _is_running {my$pid=shift;if ($^O eq 'riscos'){require Proc::ProcessTable;my$table=Proc::ProcessTable->new()->table;my%processes=map {$_->pid=>$_}@$table;return exists$processes{$pid}}else {return kill(0,$pid)|| $!{'EPERM'}}}sub _create_pidfile {my$self=shift;my$pidfile=$self->{pidfile};if (-e $pidfile){$self->_verbose("pidfile $pidfile exists\n");my$pid=$self->_get_pid();$self->_verbose("pid in pidfile $pidfile = $pid\n");if (_is_running($pid)){if ($self->{silent}){exit}else {croak "$0 already running: $pid ($pidfile)\n"}}else {$self->_verbose("$pid has died - replacing pidfile\n");open(PID,">$pidfile")or croak "Can't write to $pidfile\n";print PID "$$\n";close(PID)}}else {$self->_verbose("no pidfile $pidfile\n");open(PID,">$pidfile")or croak "Can't write to $pidfile: $!\n";flock(PID,LOCK_EX)or croak "Can't lock pid file $pidfile\n";print PID "$$\n" or croak "Can't write to pid file $pidfile\n";flock(PID,LOCK_UN);close(PID)or croak "Can't close pid file $pidfile: $!\n";$self->_verbose("pidfile $pidfile created\n")}$self->{created}=1}sub _destroy_pidfile {my$self=shift;return unless$self->{created};my$pidfile=$self->{pidfile};$self->_verbose("destroy $pidfile\n");if ($pidfile and -e $pidfile){my$pid=$self->_get_pid();$self->_verbose("pid in $pidfile = $pid\n");if ($pid==$$){$self->_verbose("remove pidfile: $pidfile\n");unlink($pidfile)if$pidfile and -e $pidfile}elsif ($^O ne 'MSWin32' && $^O ne 'riscos'){$self->_verbose("$pidfile not my pidfile - maybe my parent's?\n");my$ppid=getppid();$self->_verbose("parent pid = $ppid\n");if ($ppid!=$pid){carp "pid $pid in $pidfile is not mine ($$) - I am $0 - or my parents ($ppid)\n"}}else {$self->_verbose("$pidfile not my pidfile - can't check if it's my parent's on this OS\n")}}else {carp "pidfile $pidfile doesn't exist\n"}}1;
PROC_PIDFILE

$fatpacked{"TOML/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER';
  package TOML::Parser;use 5.008005;use strict;use warnings;use utf8;use Encode;our$VERSION="0.03";use TOML::Parser::Tokenizer qw/:constant/;use TOML::Parser::Tokenizer::Strict;use TOML::Parser::Util qw/unescape_str/;use Types::Serialiser;sub new {my$class=shift;my$args=(@_==1 and ref $_[0]eq 'HASH')? +shift : +{@_ };return bless +{inflate_datetime=>sub {$_[0]},inflate_boolean=>sub {$_[0]eq 'true' ? Types::Serialiser::true : Types::Serialiser::false},strict_mode=>0,%$args,}=>$class}sub parse_file {my ($self,$file)=@_;open my$fh,'<:encoding(utf-8)',$file or die $!;return$self->parse_fh($fh)}sub parse_fh {my ($self,$fh)=@_;my$src=do {local $/;<$fh>};return$self->parse($src)}sub _tokenizer_class {my$self=shift;return$self->{strict_mode}? 'TOML::Parser::Tokenizer::Strict' : 'TOML::Parser::Tokenizer'}our@TOKENS;our$ROOT;our$CONTEXT;sub parse {my ($self,$src)=@_;local$ROOT={};local$CONTEXT=$ROOT;local@TOKENS=$self->_tokenizer_class->tokenize($src);return$self->_parse_tokens()}sub _parse_tokens {my$self=shift;while (my$token=shift@TOKENS){my ($type,$val)=@$token;if ($type eq TOKEN_TABLE){$self->_parse_table($val)}elsif ($type eq TOKEN_ARRAY_OF_TABLE){$self->_parse_array_of_table($val)}elsif ($type eq TOKEN_KEY){my$token=shift@TOKENS;die "Duplicate key. key:$val" if exists$CONTEXT->{$val};$CONTEXT->{$val}=$self->_parse_value_token($token)}elsif ($type eq TOKEN_COMMENT){}else {die "Unknown case. type:$type"}}return$CONTEXT}sub _parse_table {my ($self,$key)=@_;local$CONTEXT=$ROOT;for my$k (split /\./,$key){if (exists$CONTEXT->{$k}){$CONTEXT=ref$CONTEXT->{$k}eq 'ARRAY' ? $CONTEXT->{$k}->[-1]: ref$CONTEXT->{$k}eq 'HASH' ? $CONTEXT->{$k}: die "invalid structure. $key cannot be `Table`"}else {$CONTEXT=$CONTEXT->{$k}||=+{}}}$self->_parse_tokens()}sub _parse_array_of_table {my ($self,$key)=@_;my@keys=split /\./,$key;my$last_key=pop@keys;local$CONTEXT=$ROOT;for my$k (@keys){if (exists$CONTEXT->{$k}){$CONTEXT=ref$CONTEXT->{$k}eq 'ARRAY' ? $CONTEXT->{$k}->[-1]: ref$CONTEXT->{$k}eq 'HASH' ? $CONTEXT->{$k}: die "invalid structure. $key cannot be `Array of table`."}else {$CONTEXT=$CONTEXT->{$k}||=+{}}}$CONTEXT->{$last_key}=[]unless exists$CONTEXT->{$last_key};die "invalid structure. $key cannot be `Array of table`" unless ref$CONTEXT->{$last_key}eq 'ARRAY';push @{$CONTEXT->{$last_key}}=>$CONTEXT={};$self->_parse_tokens()}sub _parse_value_token {my$self=shift;my$token=shift;my ($type,$val)=@$token;if ($type eq TOKEN_COMMENT){return}elsif ($type eq TOKEN_INTEGER || $type eq TOKEN_FLOAT){return 0+$val}elsif ($type eq TOKEN_BOOLEAN){return$self->inflate_boolean($val)}elsif ($type eq TOKEN_DATETIME){return$self->inflate_datetime($val)}elsif ($type eq TOKEN_STRING){return unescape_str($val)}elsif ($type eq TOKEN_ARRAY_BEGIN){my@data;while (my$token=shift@TOKENS){last if$token->[0]eq TOKEN_ARRAY_END;push@data=>$self->_parse_value_token($token)}return \@data}else {die "Unknown case. type:$type"}}sub inflate_datetime {my$self=shift;return$self->{inflate_datetime}->(@_)}sub inflate_boolean {my$self=shift;return$self->{inflate_boolean}->(@_)}1;
TOML_PARSER

$fatpacked{"TOML/Parser/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER_TOKENIZER';
  package TOML::Parser::Tokenizer;use 5.008005;use strict;use warnings;use utf8;use parent qw/Exporter/;use constant DEBUG=>$ENV{TOML_PARSER_TOKENIZER_DEBUG}? 1 : 0;BEGIN {my@TOKENS=map uc,qw/comment table array_of_table key integer float boolean datetime string array_begin array_end/;my%CONSTANTS=map {("TOKEN_$_"=>$_)}@TOKENS;require constant;constant->import(\%CONSTANTS);our@EXPORT_OK=keys%CONSTANTS;our%EXPORT_TAGS=(constant=>[keys%CONSTANTS],)};sub grammar_regexp {return +{comment=>qr{#(.*)},table=>qr{\[([^.\s\\\]]+(?:\.[^.\s\\\]]+)*)\]},array_of_table=>qr{\[\[([^.\s\\\]]+(?:\.[^.\s\\\]]+)*)\]\]},key=>qr{([^.\s\\]+)\s*=},value=>{datetime=>qr{([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z)},float=>qr{(-?[0-9]*\.[0-9]+)},integer=>qr{(-?[0-9]+)},boolean=>qr{(true|false)},string=>qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\')},array=>{start=>qr{\[},sep=>qr{\s*,\s*},end=>qr{\]},},},}}sub tokenize {my ($class,$src)=@_;local $_=$src;return$class->_tokenize()}sub _tokenize {my$class=shift;my$grammar_regexp=$class->grammar_regexp();my@tokens;until (/\G\z/mgco){if (/\G$grammar_regexp->{comment}/mgc){warn "[TOKEN] COMMENT: $1" if DEBUG;$class->_skip_whitespace();push@tokens=>[TOKEN_COMMENT,$1 || '']}elsif (/\G$grammar_regexp->{array_of_table}/mgc){warn "[TOKEN] ARRAY_OF_TABLE: $1" if DEBUG;$class->_skip_whitespace();push@tokens=>[TOKEN_ARRAY_OF_TABLE,$1]}elsif (/\G$grammar_regexp->{table}/mgc){warn "[TOKEN] TABLE: $1" if DEBUG;$class->_skip_whitespace();push@tokens=>[TOKEN_TABLE,$1]}elsif (/\G$grammar_regexp->{key}/mgc){warn "[TOKEN] KEY: $1" if DEBUG;$class->_skip_whitespace();push@tokens=>[TOKEN_KEY,$1];push@tokens=>$class->_tokenize_value()}elsif (/\G\s+/mgco){$class->_skip_whitespace()}else {$class->_syntax_error()}}return@tokens}sub _tokenize_value {my$class=shift;my$grammar_regexp=$class->grammar_regexp();warn "[CALL] _tokenize_value" if DEBUG;if (/\G$grammar_regexp->{comment}/mgc){warn "[TOKEN] COMMENT: $1" if DEBUG;$class->_skip_whitespace();return [TOKEN_COMMENT,$1 || '']}elsif (/\G$grammar_regexp->{value}->{datetime}/mgc){warn "[TOKEN] DATETIME: $1" if DEBUG;$class->_skip_whitespace();return [TOKEN_DATETIME,$1]}elsif (/\G$grammar_regexp->{value}->{float}/mgc){warn "[TOKEN] FLOAT: $1" if DEBUG;$class->_skip_whitespace();return [TOKEN_FLOAT,$1]}elsif (/\G$grammar_regexp->{value}->{integer}/mgc){warn "[TOKEN] INTEGER: $1" if DEBUG;$class->_skip_whitespace();return [TOKEN_INTEGER,$1]}elsif (/\G$grammar_regexp->{value}->{boolean}/mgc){warn "[TOKEN] BOOLEAN: $1" if DEBUG;$class->_skip_whitespace();return [TOKEN_BOOLEAN,$1]}elsif (/\G$grammar_regexp->{value}->{string}/mgc){warn "[TOKEN] STRING: $1" if DEBUG;$class->_skip_whitespace();return [TOKEN_STRING,$1 || $2 || '']}elsif (/\G$grammar_regexp->{value}->{array}->{start}/mgc){warn "[TOKEN] ARRAY" if DEBUG;$class->_skip_whitespace();return ([TOKEN_ARRAY_BEGIN],$class->_tokenize_array(),[TOKEN_ARRAY_END],)}else {$class->_syntax_error()}}sub _tokenize_array {my$class=shift;my$grammar_regexp=$class->grammar_regexp()->{value}->{array};warn "[CALL] _tokenize_array" if DEBUG;return if /\G(?:$grammar_regexp->{sep})?$grammar_regexp->{end}/smgc;my@tokens=$class->_tokenize_value();while (/\G$grammar_regexp->{sep}/smgc ||!/\G$grammar_regexp->{end}/mgc){last if /\G$grammar_regexp->{end}/mgc;warn "[CONTEXT] _tokenize_array [loop]" if DEBUG;$class->_skip_whitespace();push@tokens=>$class->_tokenize_value();$class->_skip_whitespace()}return@tokens}sub _skip_whitespace {my$class=shift;if (/\G\s+/smgco){warn "[PASS] WHITESPACE" if DEBUG}}sub _syntax_error {shift->_error('Syntax Error')}sub _error {my ($class,$msg)=@_;my$src=$_;my$line=1;my$start=pos$src || 0;while ($src =~ /$/smgco and pos$src <= pos){$start=pos$src;$line++}my$end=pos$src;my$len=pos()- $start - 1;my$trace=join "\n","${msg}: line:$line",substr($src,$start || 0,$end - $start),(' ' x $len).'^';die$trace,"\n"}1;
TOML_PARSER_TOKENIZER

$fatpacked{"TOML/Parser/Tokenizer/Strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER_TOKENIZER_STRICT';
  package TOML::Parser::Tokenizer::Strict;use 5.008005;use strict;use warnings;use utf8;use parent qw/TOML::Parser::Tokenizer/;BEGIN {import TOML::Parser::Tokenizer qw/:constant/}sub grammar_regexp {my$grammar_regexp={%{shift->SUPER::grammar_regexp()}};$grammar_regexp->{value}={%{$grammar_regexp->{value}}};$grammar_regexp->{value}->{string}=qr{"(.*?)(?<!(?<!\\)\\)"};return$grammar_regexp}my%ALLOWED_TOKEN_MAP=(TOKEN_COMMENT()=>1,);our$EXPECT_VALUE_TOKEN;sub _tokenize_value {my$class=shift;my@tokens=$class->SUPER::_tokenize_value();if (defined$EXPECT_VALUE_TOKEN){my$token=$tokens[0][0];if (not exists$ALLOWED_TOKEN_MAP{$token}and $token ne $EXPECT_VALUE_TOKEN){$class->_error("Unexpected token. expected: $EXPECT_VALUE_TOKEN, but got: $token")}}return@tokens}sub _tokenize_array {my$class=shift;local$EXPECT_VALUE_TOKEN;no warnings qw/redefine once/;local*_tokenize_value=do {use warnings qw/redefine once/;my$super=\&_tokenize_value;sub {my@tokens=$super->(@_);$EXPECT_VALUE_TOKEN=$tokens[0][0];no warnings qw/redefine once/;*_tokenize_value=$super;return@tokens}};return$class->SUPER::_tokenize_array()}1;
TOML_PARSER_TOKENIZER_STRICT

$fatpacked{"TOML/Parser/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER_UTIL';
  package TOML::Parser::Util;use 5.008005;use strict;use warnings;use utf8;use parent qw/Exporter/;our@EXPORT_OK=qw/unescape_str/;sub unescape_str {my$str=shift;$str =~ s!\\b !\x08!xmgo;$str =~ s!\\t !\x09!xmgo;$str =~ s!\\n !\x0A!xmgo;$str =~ s!\\f !\x0C!xmgo;$str =~ s!\\r !\x0D!xmgo;$str =~ s!\\" !\x22!xmgo;$str =~ s!\\/ !\x2F!xmgo;$str =~ s!\\\\!\x5C!xmgo;$str =~ s{\\u([0-9A-Fa-f]{4})}{# unicode         (U+XXXX)
          chr hex $1
      }xmgeo;return$str}1;
TOML_PARSER_UTIL

$fatpacked{"boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BOOLEAN';
  use strict;use warnings;package boolean;our$VERSION='0.38';my ($true,$false);use overload '""'=>sub {${$_[0]}},'!'=>sub {${$_[0]}? $false : $true},fallback=>1;use base 'Exporter';@boolean::EXPORT=qw(true false boolean);@boolean::EXPORT_OK=qw(isTrue isFalse isBoolean);%boolean::EXPORT_TAGS=(all=>[@boolean::EXPORT,@boolean::EXPORT_OK],test=>[qw(isTrue isFalse isBoolean)],);sub import {my@options=grep $_ ne '-truth',@_;$_[0]->truth if@options!=@_;@_=@options;goto&Exporter::import}my ($true_val,$false_val,$bool_vals);BEGIN {my$have_readonly=eval {require Readonly};my$t=1;my$f=0;$true=do {bless \$t,'boolean'};$false=do {bless \$f,'boolean'};if ($have_readonly){Readonly::Scalar($t=>$t);Readonly::Scalar($f=>$f)}$true_val=overload::StrVal($true);$false_val=overload::StrVal($false);$bool_vals={$true_val=>1,$false_val=>1}}sub true() {$true}sub false() {$false}sub boolean($) {die "Not enough arguments for boolean::boolean" if scalar(@_)==0;die "Too many arguments for boolean::boolean" if scalar(@_)> 1;return not(defined $_[0])? false : "$_[0]" ? $true : $false}sub isTrue($) {not(defined $_[0])? false : (overload::StrVal($_[0])eq $true_val)? true : false}sub isFalse($) {not(defined $_[0])? false : (overload::StrVal($_[0])eq $false_val)? true : false}sub isBoolean($) {not(defined $_[0])? false : (exists$bool_vals->{overload::StrVal($_[0])})? true : false}sub truth {&Internals::SvREADONLY(\!!0,0);&Internals::SvREADONLY(\!!1,0);${\!!0}=$false;${\!!1}=$true;&Internals::SvREADONLY(\!!0,1);&Internals::SvREADONLY(\!!1,1)}sub TO_JSON {${$_[0]}? \1 : \0}1;
BOOLEAN

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;use strict;use vars qw($VERSION);$VERSION='0.228';sub import {my$class=shift;my$inheritor=caller(0);if (@_ and $_[0]eq '-norequire'){shift @_}else {for (my@filename=@_){if ($_ eq $inheritor){warn "Class '$inheritor' tried to inherit from itself\n"};s{::|'}{/}g;require "$_.pm"}}{no strict 'refs';push @{"$inheritor\::ISA"},@_}};"All your base are belong to us" 
PARENT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl

use strict;
use warnings;
use utf8;
use FindBin;
use lib "$FindBin::Bin/../lib";
use Getopt::Long;
use Pod::Usage;

use Proc::Pidfile;
use Kurado::Agent;
use Kurado::Util;
use Kurado::MQ;
use Kurado::Agent::Collector;
use Kurado::Agent::Config;

my $interval = 1;
my $max_delay = 0;
Getopt::Long::Configure ("no_ignore_case");
GetOptions(
    "self-ip=s"     => \my $self_ip,
    "conf-d=s"   => \my $config_dir,
    "dump"       => \my $dump,
    "mq=s"       => \my $mq,
    "pidfile=s"  => \my $pidfile,
    "interval|i=i" => \$interval,
    "max-delay=i" => \$max_delay,
    "h|help"     => \my $help,
    "v|version"  => \my $version,
);

if ( $version ) {
    print "Kurado::Agent version $Kurado::Agent::VERSION\n";
    print "Try `kurado_agent --help` for more options.\n\n";
    exit 0;
}

if ( $help ) {
    pod2usage(-verbose=>2,-exitval=>0);
}

my $plugins = {};
if ( $config_dir ) {
    eval {
        my $conf = Kurado::Agent::Config->new($config_dir);
        $plugins = $conf->plugins;
    };
    die "Failed to load config: $@\n" if $@;
}

my $collector = Kurado::Agent::Collector->new($plugins);

if ( $dump ) {
    my $message;
    eval {
        $message = $collector->collect("dump");
        $message .= $collector->collect_plugins("dump");
    };
    die "$@\n" if $@;
    print $message;
    exit;
}

if ( !$mq || !$interval) {
    pod2usage(-verbose=>0,-exitval=>1);
}

my $pp;
if ( $pidfile ) {
    $pp = Proc::Pidfile->new( pidfile => $pidfile );
}

$0 = "kurado_agent master";
supervisor(sub {
    $0 = "kurado_agent";
    my $mq = Kurado::MQ->new(server => $mq);
    local $SIG{TERM}  = sub {
        $mq->{stop_loop} = 1;
    };
    $self_ip ||= $mq->{sock}->sockhost;
    warn sprintf('start kurado_agent. mq:%s:%s self_ip:%s interval:%ssec max_delay:%ssec'."\n",
                 $mq->{sock}->peerhost, $mq->{sock}->peerport, $self_ip, $interval*60, $max_delay);
    $mq->timetick_publisher(
        $interval*60,
        $max_delay,
        sub {
            my $message;
            eval {
                $message = $collector->collect($self_ip);
                $message .= $collector->collect_plugins($self_ip);
            };
            die "failed collect metrics: $@\n" if $@;
            return ['kurado-update', $message];
        }
    );
    exit();
}, interval => 3);

1;

__END__

=head1 NAME

kurado_agent - Kurado agent

=head1 SYNOPSIS

  # dry-run 
  % kurado_agent --dump
  
  # run 
  % kurado_agent --interval 1 --mq 127.0.0.1:6379 --conf-d /etc/kurado_agent/conf.d

=head1 DESCRIPTION

Kurado agent

=head1 OPTIONS

=over 4

=item --conf-d

path to config directory. files shuold be '*.toml' (optional)

=item --interval

interval minutes default 1 (60sec)

=item --mq

Redis Server for message queue (required)

=item --self-ip

ip address of this host. If not exists, use socket addr of connection to redis server

=item --pidfile

pidfile

=item --max-delay

max delay second of interval metrics sending. for avoiding thundering herd of "0" seconds

=item -v --version

Display version

=item -h --help

Display help

=back

=head1 AUTHOR

Masahiro Nagano <kazeburo {at} gmail.com>

=head1 LICENSE

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

# Local Variables:
# mode: cperl
# End:





